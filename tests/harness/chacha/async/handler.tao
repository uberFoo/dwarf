// struct Future<T> {
// value: T,
// }

enum PowerEvent {
    On,
    Off,
}

enum Power {
    On,
    Off,
}

enum Event {
    PowerEvent(PowerEvent),
    // This is a no-op for now.
    ColorEvent,
}

struct Color {
    red: float,
    green: float,
    blue: float,
}

struct Light {
    power: Power,
    color: Color,
}

impl Light {
    fn new() -> Light {
        Light {
            power: Power::Off,
            color: Color {
                red: 0.0,
                green: 0.0,
                blue: 0.0,
            },
        }
    }

    async fn send_event(self, event: Event) -> Future<()> {
        match event {
            Event::PowerEvent(power_event) => {
                match power_event {
                    PowerEvent::On => {
                        // No point in turning on if we're already on.
                        if let Power::On = self.power {
                            print("The light is already on!\n");
                            return;
                        }

                        print("Turning on light\n");
                        chacha::sleep(1000);

                        self.power = Power::On;
                        self.color = Color {
                            red: 1.0,
                            green: 1.0,
                            blue: 1.0,
                        };
                    }
                    PowerEvent::Off => {
                        if let Power::Off = self.power {
                            print("The light is already off!\n");
                            return;
                        }

                        print("Turning off light\n");
                        chacha::sleep(1000);

                        self.power = Power::Off;
                        self.color = Color {
                            red: 0.0,
                            green: 0.0,
                            blue: 0.0,
                        };
                    }
                };
            }
            Event::ColorEvent => {}
        };

        Future::<()>
    }
}

fn main() {
    let light = Light::new();
    assert_off(light);

    let event = Event::PowerEvent(PowerEvent::On);
    light.send_event(event).and_then(|| {
        assert_on(light);
    });

    let event = Event::PowerEvent(PowerEvent::Off);
    light.send_event(event).and_then(|| {
        assert_off(light);
    });

    light.send_event(event).and_then(|| {
        assert_off(light);
    });
}

fn assert_off(light: Light) {
    chacha::assert_eq(light.power, Power::Off);
    chacha::assert_eq(light.color.red, 0.0);
    chacha::assert_eq(light.color.green, 0.0);
    chacha::assert_eq(light.color.blue, 0.0);
}

fn assert_on(light: Light) {
    chacha::assert_eq(light.power, Power::On);
    chacha::assert_eq(light.color.red, 1.0);
    chacha::assert_eq(light.color.green, 1.0);
    chacha::assert_eq(light.color.blue, 1.0);
}
