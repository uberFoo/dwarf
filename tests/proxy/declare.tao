// This annotation tells the interpreter that the struct will be a proxy for
// an `ObjectStore` called sarzak. It will find the plugin based on the name.
#[store(model = "sarzak")]
struct SarzakStore {}

// This is just to keep the type checking happy.
#[store(model = "sarzak")]
impl SarzakStore {
    // This is a function that exists on the ObjectStore, and the interpreter
    // will invoke it in the plugin.
    #[proxy(store = "sarzak", object = "ObjectStore", func = "new")]
    fn new() -> Self;
}

// This tells the interpreter that this struct is a proxy for an object called
// "Object" in the store named "sarzak". In this case it's declared above.
#[proxy(store = "sarzak", object = "Object")]
struct Object {
    id: Uuid,
    name: string,
    key_letters: string,
    description: string,
}

impl Object {
    #[proxy(store = "sarzak", object = "Object", func = "new")]
    // fn new(desc: string, kl: string, name: string, store: SarzakStore) -> Self;
    fn new(desc: string, kl: string, name: string) -> Self;

    // This is a static method that will be wired up to a function called
    // `iter_object`.
    #[proxy(store = "sarzak", object = "Object", func = "instances")]
    fn instances() -> [Self];
}

#[store(model = "merlin")]
struct MerlinStore {}

#[store(model = "merlin")]
impl MerlinStore {
    #[proxy(store = "merlin", object = "ObjectStore", func = "new")]
    fn new() -> Self;
}

#[proxy(store = "merlin", object = "Point")]
struct Point {
    id: Uuid,
    subtype: string,
    x: int,
    y: int,
}

impl Point {
    #[proxy(store = "merlin", object = "Point", func = "new_inflection")]
    fn new_inflection(x: int, y: int) -> Self;

    // This is a static method that will be wired up to a function called
    // `iter_object`.
    #[proxy(store = "merlin", object = "Point", func = "instances")]
    fn instances() -> [Self];
}

fn main() {
    // Specifying the type of the lhs forces a type check.
    // This will create an object, but it won't be in the store.
    let object: Object = Object {
        id: Uuid::new(),
        key_letters: "ᚠ",
        name: "Gandalf",
        description: "A wandering wizard",
    };
    // print("{0}\n".format(object));

    // This fails, and well done. We don't want this to be constructable.
    // let store: SarzakStore = SarzakStore {};

    // We create a new store.
    let store = SarzakStore::new();
    print("{0}\n".format(store));

    // And use it here to create an object. This will be saved in the store.
    let gandalf = Object::new("A wandering wizard", "ᚠ", "Gandalf");
    let merlin = Object::new("Magician of Camelot", "M", "Merlin");

    chacha::assert_eq(gandalf.name, "Gandalf");
    chacha::assert_eq(gandalf.description, "A wandering wizard");
    chacha::assert_eq(gandalf.key_letters, "ᚠ");

    chacha::assert_eq(merlin.name, "Merlin");
    chacha::assert_eq(merlin.description, "Magician of Camelot");
    chacha::assert_eq(merlin.key_letters, "M");

    gandalf.name = "Gandalf the Grey";
    chacha::assert_eq(gandalf.name, "Gandalf the Grey");

    for instance in Object::instances() {
        print(instance);
        print("\n");
    }

    let merlin = MerlinStore::new();

    for instance in Point::instances() {
        print(instance);
        print("\n");
    }
}
