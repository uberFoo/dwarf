#[store(model = "sarzak")]
struct SarzakStore {}

#[store(model = "sarzak")]
impl SarzakStore {
    #[proxy(store = "sarzak", object = "ObjectStore", func = "new")]
    fn new() -> Self;

    /// Inter (insert) [`Object`] into the store.
    ///
    #[proxy(store = "sarzak", object = "ObjectStore", func = "inter_object")]
    fn inter_object(self, object: Object);

    /// Exhume (get) [`Object`] from the store.
    ///
    #[proxy(store = "sarzak", object = "ObjectStore", func = "exhume_object")]
    fn exhume_object(self, id: Uuid) -> Option<Object>;

    /// Exhume [`Object`] id from the store by name.
    ///
    #[proxy(
        store = "sarzak",
        object = "ObjectStore",
        func = "exhume_object_id_by_name"
    )]
    fn exhume_object_id_by_name(self, name: string) -> Option<Uuid>;

    /// Get an iterator over the internal `HashMap<&Uuid, Object>`.
    ///
    #[proxy(store = "sarzak", object = "ObjectStore", func = "iter_object")]
    fn iter_object(self) -> [Object];
}

#[proxy(store = "sarzak", object = "Object")]
struct Object {
    id: Uuid,
    name: String,
    key_letters: String,
    description: String,
}

impl Object {
    #[proxy(store = "sarzak", object = "Object", func = "new")]
    fn new(desc: string, kl: string, name: string, store: SarzakStore) -> Self;
}

fn main() {
    // Specifying the type of the lhs forces a type check.
    let object: Object = Object {
        id: Uuid::new(),
        key_letters: "ᚠ",
        name: "Gandalf",
        description: "A wandering wizard",
    };

    // This fails, and well done. We don't want this to be constructable.
    // let store: SarzakStore = SarzakStore {};

    let store = SarzakStore::new();
    // print(store);

    // Object::new("A wandering wizard", "ᚠ", "Gandalf");
}
