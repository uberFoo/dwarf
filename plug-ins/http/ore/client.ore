use std::option::Option;
use std::result::Result;

struct Plugin<T> {
    inner: T,
}
struct HttpClient {
    // This plugin value must point to a valid plugin. The first part of the
    // path is the name, and the second part is a parameter to send to the
    // constructor.
    #[proxy(plugin = "http::http_client")]
    inner: Plugin<HttpClient>,
}

impl HttpClient {
    fn new() -> Self {
        HttpClient {
            inner: Plugin::<HttpClient>::new(),
        }
    }
    // #[proxy(plugin = "http_client", object = "HttpClient", func = "get")]
    async fn get(self, url: String) -> Future<Request> {
        let request = self
            .inner
            .invoke_func("http_client", "HttpClient", "get", [url]);
        Request {
            inner: request,
            plugin: self.inner,
        }
    }
}

// #[proxy(ty = "RequestBuilder")]
struct Request {
    #[proxy(plugin = "http::http_client")]
    plugin: Plugin<HttpClient>,
    inner: int,
}

impl Request {
    async fn send(self) -> Future<Result<Response, Error>> {
        let response: Result<int, int> =
            self.plugin
                .invoke_func("http_client", "Request", "send", [self.inner]);

        match response {
            Result::<int, int>::Err(e) => Result::<Response, Error>::Err(Error {
                inner: e,
                plugin: self.plugin,
            }),
            Result::<int, int>::Ok(r) => Result::<Response, Error>::Ok(Response {
                inner: r,
                plugin: self.plugin,
            }),
        }
    }
}

struct Response {
    #[proxy(plugin = "http::http_client")]
    plugin: Plugin<HttpClient>,
    inner: int,
}

impl Response {
    async fn text(self) -> Future<Result<string, Error>> {
        let text: Result<string, int> =
            self.plugin
                .invoke_func("http_client", "Response", "text", [self.inner]);

        match text {
            Result::<string, int>::Err(e) => Result::<string, Error>::Err(Error {
                inner: e,
                plugin: self.plugin,
            }),
            Result::<string, int>::Ok(t) => Result::<string, Error>::Ok(t),
        }
    }
}

struct Error {
    #[proxy(plugin = "http::http_client")]
    plugin: Plugin<HttpClient>,
    inner: int,
}

// impl Error {
//     // This is a function that exists on the ObjectStore, and the interpreter
//     // will invoke it in the plugin.
//     #[proxy(store = "error", object = "Error", func = "status")]
//     fn status(self) -> Option<int>;
// }
