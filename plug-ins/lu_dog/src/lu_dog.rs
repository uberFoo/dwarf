//! A blank domain
use std::sync::Arc;
use std::sync::RwLock;
use std::{
    fmt::{self, Display},
    path::Path,
};

use abi_stable::{
    export_root_module,
    prefix_type::PrefixTypeTrait,
    sabi_extern_fn,
    sabi_trait::prelude::{TD_CanDowncast, TD_Opaque},
    std_types::{RBox, RErr, ROk, ROption, RResult, RStr, RString, RVec},
};
use dwarf::{
    chacha::value::{FfiProxy, FfiValue, Value},
    plug_in::{Error, Plugin, PluginModRef, PluginModule, PluginType, Plugin_TO},
};
use log::debug;
use uuid::{uuid, Uuid};

pub mod store;
pub mod types;
pub use store::ObjectStore;
pub use types::*;

/// Exports the root module of this library.
///
/// This code isn't run until the layout of the type it returns is checked.
pub fn instantiate_root_module() -> PluginModRef {
    PluginModule { name, id, new }.leak_into_prefix()
}

#[sabi_extern_fn]
pub fn name() -> RStr<'static> {
    "lu_dog".into()
}

#[sabi_extern_fn]
pub fn id() -> RStr<'static> {
    "lu_dog".into()
}

/// Instantiates the plugin.
#[sabi_extern_fn]
pub fn new(args: RVec<FfiValue>) -> RResult<PluginType, Error> {
    match (|| {
        if args.len() == 0 {
            Ok(LuDogStore {
                store: Arc::new(RwLock::new(ObjectStore::new())),
            })
        } else if args.len() == 1 {
            if let FfiValue::String(path) = &args[0] {
                let store = ObjectStore::load(Path::new(&path.as_str())).unwrap();
                Ok(LuDogStore {
                    store: Arc::new(RwLock::new(store)),
                })
            } else {
                Err(Error::Uber("Invalid arguments".into()))
            }
        } else {
            Err(Error::Uber("Invalid arguments".into()))
        }
    })() {
        Ok(this) => ROk(Plugin_TO::from_value(this, TD_Opaque)),
        Err(e) => RErr(e.into()),
    }
}

#[derive(Clone, Debug)]
struct LuDogStore {
    store: Arc<RwLock<ObjectStore>>,
}

impl Display for LuDogStore {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{:?}", self.store)
    }
}

impl Plugin for LuDogStore {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "ObjectStore" => match func {
                    "persist" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(path) = args.pop().unwrap() {
                            self.store
                                .read()
                                .unwrap()
                                .persist(Path::new(&path.as_str()))
                                .unwrap();
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid path".into()))
                        }
                    }

                    "inter_argument" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(argument) = args.pop().unwrap() {
                            let argument = argument.obj.downcast_into::<ArgumentProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_argument(argument.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Argument".into()))
                        }
                    }
                    "exhume_argument" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let argument = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_argument(&id.into())
                                .unwrap();
                            let argument_proxy = ArgumentProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: argument.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(argument_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: ARGUMENT_ID.into(),
                                id: argument.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_a_wait" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(a_wait) = args.pop().unwrap() {
                            let a_wait = a_wait.obj.downcast_into::<AWaitProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_a_wait(a_wait.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid AWait".into()))
                        }
                    }
                    "exhume_a_wait" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let a_wait = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_a_wait(&id.into())
                                .unwrap();
                            let a_wait_proxy = AWaitProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: a_wait.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(a_wait_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: A_WAIT_ID.into(),
                                id: a_wait.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_binary" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(binary) = args.pop().unwrap() {
                            let binary = binary.obj.downcast_into::<BinaryProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_binary(binary.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Binary".into()))
                        }
                    }
                    "exhume_binary" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let binary = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_binary(&id.into())
                                .unwrap();
                            let binary_proxy = BinaryProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: binary.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(binary_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: BINARY_ID.into(),
                                id: binary.read().unwrap().id().into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_block" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(block) = args.pop().unwrap() {
                            let block = block.obj.downcast_into::<BlockProxy>().unwrap();
                            self.store.write().unwrap().inter_block(block.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Block".into()))
                        }
                    }
                    "exhume_block" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let block =
                                self.store.read().unwrap().exhume_block(&id.into()).unwrap();
                            let block_proxy = BlockProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: block.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(block_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: BLOCK_ID.into(),
                                id: block.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_body" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(body) = args.pop().unwrap() {
                            let body = body.obj.downcast_into::<BodyProxy>().unwrap();
                            self.store.write().unwrap().inter_body(body.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Body".into()))
                        }
                    }
                    "exhume_body" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let body = self.store.read().unwrap().exhume_body(&id.into()).unwrap();
                            let body_proxy = BodyProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: body.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(body_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: BODY_ID.into(),
                                id: body.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_boolean_literal" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(boolean_literal) = args.pop().unwrap() {
                            let boolean_literal = boolean_literal
                                .obj
                                .downcast_into::<BooleanLiteralProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_boolean_literal(boolean_literal.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid BooleanLiteral".into()))
                        }
                    }
                    "exhume_boolean_literal" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let boolean_literal = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_boolean_literal(&id.into())
                                .unwrap();
                            let boolean_literal_proxy = BooleanLiteralProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: boolean_literal.clone(),
                                store: self.store.clone(),
                            };
                            let plugin =
                                Plugin_TO::from_value(boolean_literal_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: BOOLEAN_LITERAL_ID.into(),
                                id: boolean_literal.read().unwrap().id().into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_boolean_operator" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(boolean_operator) = args.pop().unwrap() {
                            let boolean_operator = boolean_operator
                                .obj
                                .downcast_into::<BooleanOperatorProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_boolean_operator(boolean_operator.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid BooleanOperator".into()))
                        }
                    }
                    "exhume_boolean_operator" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let boolean_operator = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_boolean_operator(&id.into())
                                .unwrap();
                            let boolean_operator_proxy = BooleanOperatorProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: boolean_operator.clone(),
                                store: self.store.clone(),
                            };
                            let plugin =
                                Plugin_TO::from_value(boolean_operator_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: BOOLEAN_OPERATOR_ID.into(),
                                id: boolean_operator.read().unwrap().id().into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_call" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(call) = args.pop().unwrap() {
                            let call = call.obj.downcast_into::<CallProxy>().unwrap();
                            self.store.write().unwrap().inter_call(call.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Call".into()))
                        }
                    }
                    "exhume_call" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let call = self.store.read().unwrap().exhume_call(&id.into()).unwrap();
                            let call_proxy = CallProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: call.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(call_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: CALL_ID.into(),
                                id: call.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_comparison" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(comparison) = args.pop().unwrap() {
                            let comparison =
                                comparison.obj.downcast_into::<ComparisonProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_comparison(comparison.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Comparison".into()))
                        }
                    }
                    "exhume_comparison" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let comparison = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_comparison(&id.into())
                                .unwrap();
                            let comparison_proxy = ComparisonProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: comparison.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(comparison_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: COMPARISON_ID.into(),
                                id: comparison.read().unwrap().id().into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_data_structure" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(data_structure) = args.pop().unwrap() {
                            let data_structure = data_structure
                                .obj
                                .downcast_into::<DataStructureProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_data_structure(data_structure.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid DataStructure".into()))
                        }
                    }
                    "exhume_data_structure" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let data_structure = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_data_structure(&id.into())
                                .unwrap();
                            let data_structure_proxy = DataStructureProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: data_structure.clone(),
                                store: self.store.clone(),
                            };
                            let plugin =
                                Plugin_TO::from_value(data_structure_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: DATA_STRUCTURE_ID.into(),
                                id: data_structure.read().unwrap().id().into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_dwarf_source_file" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(dwarf_source_file) = args.pop().unwrap() {
                            let dwarf_source_file = dwarf_source_file
                                .obj
                                .downcast_into::<DwarfSourceFileProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_dwarf_source_file(dwarf_source_file.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid DwarfSourceFile".into()))
                        }
                    }
                    "exhume_dwarf_source_file" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let dwarf_source_file = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_dwarf_source_file(&id.into())
                                .unwrap();
                            let dwarf_source_file_proxy = DwarfSourceFileProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: dwarf_source_file.clone(),
                                store: self.store.clone(),
                            };
                            let plugin =
                                Plugin_TO::from_value(dwarf_source_file_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: DWARF_SOURCE_FILE_ID.into(),
                                id: dwarf_source_file.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_enum_field" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(enum_field) = args.pop().unwrap() {
                            let enum_field =
                                enum_field.obj.downcast_into::<EnumFieldProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_enum_field(enum_field.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid EnumField".into()))
                        }
                    }
                    "exhume_enum_field" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let enum_field = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_enum_field(&id.into())
                                .unwrap();
                            let enum_field_proxy = EnumFieldProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: enum_field.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(enum_field_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: ENUM_FIELD_ID.into(),
                                id: enum_field.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_enumeration" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(enumeration) = args.pop().unwrap() {
                            let enumeration =
                                enumeration.obj.downcast_into::<EnumerationProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_enumeration(enumeration.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Enumeration".into()))
                        }
                    }
                    "exhume_enumeration" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let enumeration = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_enumeration(&id.into())
                                .unwrap();
                            let enumeration_proxy = EnumerationProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: enumeration.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(enumeration_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: ENUMERATION_ID.into(),
                                id: enumeration.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_expression" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(expression) = args.pop().unwrap() {
                            let expression =
                                expression.obj.downcast_into::<ExpressionProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_expression(expression.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Expression".into()))
                        }
                    }
                    "exhume_expression" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let expression = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_expression(&id.into())
                                .unwrap();
                            let expression_proxy = ExpressionProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: expression.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(expression_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: EXPRESSION_ID.into(),
                                id: expression.read().unwrap().id().into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_expression_statement" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(expression_statement) = args.pop().unwrap() {
                            let expression_statement = expression_statement
                                .obj
                                .downcast_into::<ExpressionStatementProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_expression_statement(expression_statement.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid ExpressionStatement".into()))
                        }
                    }
                    "exhume_expression_statement" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let expression_statement = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_expression_statement(&id.into())
                                .unwrap();
                            let expression_statement_proxy = ExpressionStatementProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: expression_statement.clone(),
                                store: self.store.clone(),
                            };
                            let plugin =
                                Plugin_TO::from_value(expression_statement_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: EXPRESSION_STATEMENT_ID.into(),
                                id: expression_statement.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_external_implementation" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(external_implementation) = args.pop().unwrap() {
                            let external_implementation = external_implementation
                                .obj
                                .downcast_into::<ExternalImplementationProxy>()
                                .unwrap();
                            self.store.write().unwrap().inter_external_implementation(
                                external_implementation.inner.clone(),
                            );
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid ExternalImplementation".into()))
                        }
                    }
                    "exhume_external_implementation" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let external_implementation = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_external_implementation(&id.into())
                                .unwrap();
                            let external_implementation_proxy = ExternalImplementationProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: external_implementation.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(
                                external_implementation_proxy,
                                TD_CanDowncast,
                            );
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: EXTERNAL_IMPLEMENTATION_ID.into(),
                                id: external_implementation.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_field" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(field) = args.pop().unwrap() {
                            let field = field.obj.downcast_into::<FieldProxy>().unwrap();
                            self.store.write().unwrap().inter_field(field.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Field".into()))
                        }
                    }
                    "exhume_field" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let field =
                                self.store.read().unwrap().exhume_field(&id.into()).unwrap();
                            let field_proxy = FieldProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: field.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(field_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: FIELD_ID.into(),
                                id: field.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_field_access" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(field_access) = args.pop().unwrap() {
                            let field_access = field_access
                                .obj
                                .downcast_into::<FieldAccessProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_field_access(field_access.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid FieldAccess".into()))
                        }
                    }
                    "exhume_field_access" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let field_access = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_field_access(&id.into())
                                .unwrap();
                            let field_access_proxy = FieldAccessProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: field_access.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(field_access_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: FIELD_ACCESS_ID.into(),
                                id: field_access.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_field_access_target" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(field_access_target) = args.pop().unwrap() {
                            let field_access_target = field_access_target
                                .obj
                                .downcast_into::<FieldAccessTargetProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_field_access_target(field_access_target.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid FieldAccessTarget".into()))
                        }
                    }
                    "exhume_field_access_target" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let field_access_target = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_field_access_target(&id.into())
                                .unwrap();
                            let field_access_target_proxy = FieldAccessTargetProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: field_access_target.clone(),
                                store: self.store.clone(),
                            };
                            let plugin =
                                Plugin_TO::from_value(field_access_target_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: FIELD_ACCESS_TARGET_ID.into(),
                                id: field_access_target.read().unwrap().id().into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_field_expression" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(field_expression) = args.pop().unwrap() {
                            let field_expression = field_expression
                                .obj
                                .downcast_into::<FieldExpressionProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_field_expression(field_expression.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid FieldExpression".into()))
                        }
                    }
                    "exhume_field_expression" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let field_expression = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_field_expression(&id.into())
                                .unwrap();
                            let field_expression_proxy = FieldExpressionProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: field_expression.clone(),
                                store: self.store.clone(),
                            };
                            let plugin =
                                Plugin_TO::from_value(field_expression_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: FIELD_EXPRESSION_ID.into(),
                                id: field_expression.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_float_literal" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(float_literal) = args.pop().unwrap() {
                            let float_literal = float_literal
                                .obj
                                .downcast_into::<FloatLiteralProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_float_literal(float_literal.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid FloatLiteral".into()))
                        }
                    }
                    "exhume_float_literal" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let float_literal = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_float_literal(&id.into())
                                .unwrap();
                            let float_literal_proxy = FloatLiteralProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: float_literal.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(float_literal_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: FLOAT_LITERAL_ID.into(),
                                id: float_literal.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_for_loop" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(for_loop) = args.pop().unwrap() {
                            let for_loop = for_loop.obj.downcast_into::<ForLoopProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_for_loop(for_loop.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid ForLoop".into()))
                        }
                    }
                    "exhume_for_loop" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let for_loop = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_for_loop(&id.into())
                                .unwrap();
                            let for_loop_proxy = ForLoopProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: for_loop.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(for_loop_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: FOR_LOOP_ID.into(),
                                id: for_loop.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_function" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(function) = args.pop().unwrap() {
                            let function = function.obj.downcast_into::<FunctionProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_function(function.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Function".into()))
                        }
                    }
                    "exhume_function" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let function = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_function(&id.into())
                                .unwrap();
                            let function_proxy = FunctionProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: function.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(function_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: FUNCTION_ID.into(),
                                id: function.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_x_future" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(x_future) = args.pop().unwrap() {
                            let x_future = x_future.obj.downcast_into::<XFutureProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_x_future(x_future.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid XFuture".into()))
                        }
                    }
                    "exhume_x_future" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let x_future = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_x_future(&id.into())
                                .unwrap();
                            let x_future_proxy = XFutureProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: x_future.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(x_future_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: X_FUTURE_ID.into(),
                                id: x_future.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_generic" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(generic) = args.pop().unwrap() {
                            let generic = generic.obj.downcast_into::<GenericProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_generic(generic.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Generic".into()))
                        }
                    }
                    "exhume_generic" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let generic = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_generic(&id.into())
                                .unwrap();
                            let generic_proxy = GenericProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: generic.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(generic_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: GENERIC_ID.into(),
                                id: generic.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_grouped" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(grouped) = args.pop().unwrap() {
                            let grouped = grouped.obj.downcast_into::<GroupedProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_grouped(grouped.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Grouped".into()))
                        }
                    }
                    "exhume_grouped" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let grouped = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_grouped(&id.into())
                                .unwrap();
                            let grouped_proxy = GroupedProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: grouped.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(grouped_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: GROUPED_ID.into(),
                                id: grouped.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_x_if" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(x_if) = args.pop().unwrap() {
                            let x_if = x_if.obj.downcast_into::<XIfProxy>().unwrap();
                            self.store.write().unwrap().inter_x_if(x_if.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid XIf".into()))
                        }
                    }
                    "exhume_x_if" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let x_if = self.store.read().unwrap().exhume_x_if(&id.into()).unwrap();
                            let x_if_proxy = XIfProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: x_if.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(x_if_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: X_IF_ID.into(),
                                id: x_if.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_implementation_block" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(implementation_block) = args.pop().unwrap() {
                            let implementation_block = implementation_block
                                .obj
                                .downcast_into::<ImplementationBlockProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_implementation_block(implementation_block.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid ImplementationBlock".into()))
                        }
                    }
                    "exhume_implementation_block" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let implementation_block = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_implementation_block(&id.into())
                                .unwrap();
                            let implementation_block_proxy = ImplementationBlockProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: implementation_block.clone(),
                                store: self.store.clone(),
                            };
                            let plugin =
                                Plugin_TO::from_value(implementation_block_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: IMPLEMENTATION_BLOCK_ID.into(),
                                id: implementation_block.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_import" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(import) = args.pop().unwrap() {
                            let import = import.obj.downcast_into::<ImportProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_import(import.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Import".into()))
                        }
                    }
                    "exhume_import" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let import = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_import(&id.into())
                                .unwrap();
                            let import_proxy = ImportProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: import.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(import_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: IMPORT_ID.into(),
                                id: import.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_index" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(index) = args.pop().unwrap() {
                            let index = index.obj.downcast_into::<IndexProxy>().unwrap();
                            self.store.write().unwrap().inter_index(index.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Index".into()))
                        }
                    }
                    "exhume_index" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let index =
                                self.store.read().unwrap().exhume_index(&id.into()).unwrap();
                            let index_proxy = IndexProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: index.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(index_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: INDEX_ID.into(),
                                id: index.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_integer_literal" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(integer_literal) = args.pop().unwrap() {
                            let integer_literal = integer_literal
                                .obj
                                .downcast_into::<IntegerLiteralProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_integer_literal(integer_literal.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid IntegerLiteral".into()))
                        }
                    }
                    "exhume_integer_literal" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let integer_literal = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_integer_literal(&id.into())
                                .unwrap();
                            let integer_literal_proxy = IntegerLiteralProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: integer_literal.clone(),
                                store: self.store.clone(),
                            };
                            let plugin =
                                Plugin_TO::from_value(integer_literal_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: INTEGER_LITERAL_ID.into(),
                                id: integer_literal.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_item" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(item) = args.pop().unwrap() {
                            let item = item.obj.downcast_into::<ItemProxy>().unwrap();
                            self.store.write().unwrap().inter_item(item.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Item".into()))
                        }
                    }
                    "exhume_item" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let item = self.store.read().unwrap().exhume_item(&id.into()).unwrap();
                            let item_proxy = ItemProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: item.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(item_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: ITEM_ID.into(),
                                id: item.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_lambda" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(lambda) = args.pop().unwrap() {
                            let lambda = lambda.obj.downcast_into::<LambdaProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_lambda(lambda.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Lambda".into()))
                        }
                    }
                    "exhume_lambda" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let lambda = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_lambda(&id.into())
                                .unwrap();
                            let lambda_proxy = LambdaProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: lambda.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(lambda_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: LAMBDA_ID.into(),
                                id: lambda.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_lambda_parameter" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(lambda_parameter) = args.pop().unwrap() {
                            let lambda_parameter = lambda_parameter
                                .obj
                                .downcast_into::<LambdaParameterProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_lambda_parameter(lambda_parameter.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid LambdaParameter".into()))
                        }
                    }
                    "exhume_lambda_parameter" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let lambda_parameter = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_lambda_parameter(&id.into())
                                .unwrap();
                            let lambda_parameter_proxy = LambdaParameterProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: lambda_parameter.clone(),
                                store: self.store.clone(),
                            };
                            let plugin =
                                Plugin_TO::from_value(lambda_parameter_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: LAMBDA_PARAMETER_ID.into(),
                                id: lambda_parameter.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_let_statement" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(let_statement) = args.pop().unwrap() {
                            let let_statement = let_statement
                                .obj
                                .downcast_into::<LetStatementProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_let_statement(let_statement.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid LetStatement".into()))
                        }
                    }
                    "exhume_let_statement" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let let_statement = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_let_statement(&id.into())
                                .unwrap();
                            let let_statement_proxy = LetStatementProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: let_statement.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(let_statement_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: LET_STATEMENT_ID.into(),
                                id: let_statement.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_list" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(list) = args.pop().unwrap() {
                            let list = list.obj.downcast_into::<ListProxy>().unwrap();
                            self.store.write().unwrap().inter_list(list.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid List".into()))
                        }
                    }
                    "exhume_list" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let list = self.store.read().unwrap().exhume_list(&id.into()).unwrap();
                            let list_proxy = ListProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: list.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(list_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: LIST_ID.into(),
                                id: list.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_list_element" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(list_element) = args.pop().unwrap() {
                            let list_element = list_element
                                .obj
                                .downcast_into::<ListElementProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_list_element(list_element.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid ListElement".into()))
                        }
                    }
                    "exhume_list_element" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let list_element = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_list_element(&id.into())
                                .unwrap();
                            let list_element_proxy = ListElementProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: list_element.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(list_element_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: LIST_ELEMENT_ID.into(),
                                id: list_element.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_list_expression" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(list_expression) = args.pop().unwrap() {
                            let list_expression = list_expression
                                .obj
                                .downcast_into::<ListExpressionProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_list_expression(list_expression.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid ListExpression".into()))
                        }
                    }
                    "exhume_list_expression" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let list_expression = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_list_expression(&id.into())
                                .unwrap();
                            let list_expression_proxy = ListExpressionProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: list_expression.clone(),
                                store: self.store.clone(),
                            };
                            let plugin =
                                Plugin_TO::from_value(list_expression_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: LIST_EXPRESSION_ID.into(),
                                id: list_expression.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_literal" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(literal) = args.pop().unwrap() {
                            let literal = literal.obj.downcast_into::<LiteralProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_literal(literal.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Literal".into()))
                        }
                    }
                    "exhume_literal" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let literal = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_literal(&id.into())
                                .unwrap();
                            let literal_proxy = LiteralProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: literal.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(literal_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: LITERAL_ID.into(),
                                id: literal.read().unwrap().id().into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_local_variable" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(local_variable) = args.pop().unwrap() {
                            let local_variable = local_variable
                                .obj
                                .downcast_into::<LocalVariableProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_local_variable(local_variable.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid LocalVariable".into()))
                        }
                    }
                    "exhume_local_variable" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let local_variable = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_local_variable(&id.into())
                                .unwrap();
                            let local_variable_proxy = LocalVariableProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: local_variable.clone(),
                                store: self.store.clone(),
                            };
                            let plugin =
                                Plugin_TO::from_value(local_variable_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: LOCAL_VARIABLE_ID.into(),
                                id: local_variable.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_x_macro" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(x_macro) = args.pop().unwrap() {
                            let x_macro = x_macro.obj.downcast_into::<XMacroProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_x_macro(x_macro.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid XMacro".into()))
                        }
                    }
                    "exhume_x_macro" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let x_macro = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_x_macro(&id.into())
                                .unwrap();
                            let x_macro_proxy = XMacroProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: x_macro.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(x_macro_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: X_MACRO_ID.into(),
                                id: x_macro.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_x_match" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(x_match) = args.pop().unwrap() {
                            let x_match = x_match.obj.downcast_into::<XMatchProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_x_match(x_match.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid XMatch".into()))
                        }
                    }
                    "exhume_x_match" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let x_match = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_x_match(&id.into())
                                .unwrap();
                            let x_match_proxy = XMatchProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: x_match.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(x_match_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: X_MATCH_ID.into(),
                                id: x_match.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_method_call" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(method_call) = args.pop().unwrap() {
                            let method_call =
                                method_call.obj.downcast_into::<MethodCallProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_method_call(method_call.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid MethodCall".into()))
                        }
                    }
                    "exhume_method_call" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let method_call = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_method_call(&id.into())
                                .unwrap();
                            let method_call_proxy = MethodCallProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: method_call.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(method_call_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: METHOD_CALL_ID.into(),
                                id: method_call.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_named_field_expression" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(named_field_expression) = args.pop().unwrap() {
                            let named_field_expression = named_field_expression
                                .obj
                                .downcast_into::<NamedFieldExpressionProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_named_field_expression(named_field_expression.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid NamedFieldExpression".into()))
                        }
                    }
                    "exhume_named_field_expression" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let named_field_expression = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_named_field_expression(&id.into())
                                .unwrap();
                            let named_field_expression_proxy = NamedFieldExpressionProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: named_field_expression.clone(),
                                store: self.store.clone(),
                            };
                            let plugin =
                                Plugin_TO::from_value(named_field_expression_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: NAMED_FIELD_EXPRESSION_ID.into(),
                                id: named_field_expression.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_z_object_store" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(z_object_store) = args.pop().unwrap() {
                            let z_object_store = z_object_store
                                .obj
                                .downcast_into::<ZObjectStoreProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_z_object_store(z_object_store.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid ZObjectStore".into()))
                        }
                    }
                    "exhume_z_object_store" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let z_object_store = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_z_object_store(&id.into())
                                .unwrap();
                            let z_object_store_proxy = ZObjectStoreProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: z_object_store.clone(),
                                store: self.store.clone(),
                            };
                            let plugin =
                                Plugin_TO::from_value(z_object_store_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: Z_OBJECT_STORE_ID.into(),
                                id: z_object_store.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_object_wrapper" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(object_wrapper) = args.pop().unwrap() {
                            let object_wrapper = object_wrapper
                                .obj
                                .downcast_into::<ObjectWrapperProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_object_wrapper(object_wrapper.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid ObjectWrapper".into()))
                        }
                    }
                    "exhume_object_wrapper" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let object_wrapper = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_object_wrapper(&id.into())
                                .unwrap();
                            let object_wrapper_proxy = ObjectWrapperProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: object_wrapper.clone(),
                                store: self.store.clone(),
                            };
                            let plugin =
                                Plugin_TO::from_value(object_wrapper_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: OBJECT_WRAPPER_ID.into(),
                                id: object_wrapper.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_operator" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(operator) = args.pop().unwrap() {
                            let operator = operator.obj.downcast_into::<OperatorProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_operator(operator.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Operator".into()))
                        }
                    }
                    "exhume_operator" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let operator = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_operator(&id.into())
                                .unwrap();
                            let operator_proxy = OperatorProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: operator.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(operator_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: OPERATOR_ID.into(),
                                id: operator.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_parameter" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(parameter) = args.pop().unwrap() {
                            let parameter =
                                parameter.obj.downcast_into::<ParameterProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_parameter(parameter.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Parameter".into()))
                        }
                    }
                    "exhume_parameter" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let parameter = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_parameter(&id.into())
                                .unwrap();
                            let parameter_proxy = ParameterProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: parameter.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(parameter_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: PARAMETER_ID.into(),
                                id: parameter.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_x_path" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(x_path) = args.pop().unwrap() {
                            let x_path = x_path.obj.downcast_into::<XPathProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_x_path(x_path.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid XPath".into()))
                        }
                    }
                    "exhume_x_path" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let x_path = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_x_path(&id.into())
                                .unwrap();
                            let x_path_proxy = XPathProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: x_path.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(x_path_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: X_PATH_ID.into(),
                                id: x_path.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_path_element" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(path_element) = args.pop().unwrap() {
                            let path_element = path_element
                                .obj
                                .downcast_into::<PathElementProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_path_element(path_element.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid PathElement".into()))
                        }
                    }
                    "exhume_path_element" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let path_element = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_path_element(&id.into())
                                .unwrap();
                            let path_element_proxy = PathElementProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: path_element.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(path_element_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: PATH_ELEMENT_ID.into(),
                                id: path_element.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_pattern" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(pattern) = args.pop().unwrap() {
                            let pattern = pattern.obj.downcast_into::<PatternProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_pattern(pattern.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Pattern".into()))
                        }
                    }
                    "exhume_pattern" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let pattern = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_pattern(&id.into())
                                .unwrap();
                            let pattern_proxy = PatternProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: pattern.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(pattern_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: PATTERN_ID.into(),
                                id: pattern.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_x_plugin" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(x_plugin) = args.pop().unwrap() {
                            let x_plugin = x_plugin.obj.downcast_into::<XPluginProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_x_plugin(x_plugin.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid XPlugin".into()))
                        }
                    }
                    "exhume_x_plugin" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let x_plugin = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_x_plugin(&id.into())
                                .unwrap();
                            let x_plugin_proxy = XPluginProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: x_plugin.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(x_plugin_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: X_PLUGIN_ID.into(),
                                id: x_plugin.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_x_print" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(x_print) = args.pop().unwrap() {
                            let x_print = x_print.obj.downcast_into::<XPrintProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_x_print(x_print.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid XPrint".into()))
                        }
                    }
                    "exhume_x_print" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let x_print = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_x_print(&id.into())
                                .unwrap();
                            let x_print_proxy = XPrintProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: x_print.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(x_print_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: X_PRINT_ID.into(),
                                id: x_print.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_range_expression" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(range_expression) = args.pop().unwrap() {
                            let range_expression = range_expression
                                .obj
                                .downcast_into::<RangeExpressionProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_range_expression(range_expression.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid RangeExpression".into()))
                        }
                    }
                    "exhume_range_expression" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let range_expression = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_range_expression(&id.into())
                                .unwrap();
                            let range_expression_proxy = RangeExpressionProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: range_expression.clone(),
                                store: self.store.clone(),
                            };
                            let plugin =
                                Plugin_TO::from_value(range_expression_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: RANGE_EXPRESSION_ID.into(),
                                id: range_expression.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_result_statement" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(result_statement) = args.pop().unwrap() {
                            let result_statement = result_statement
                                .obj
                                .downcast_into::<ResultStatementProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_result_statement(result_statement.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid ResultStatement".into()))
                        }
                    }
                    "exhume_result_statement" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let result_statement = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_result_statement(&id.into())
                                .unwrap();
                            let result_statement_proxy = ResultStatementProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: result_statement.clone(),
                                store: self.store.clone(),
                            };
                            let plugin =
                                Plugin_TO::from_value(result_statement_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: RESULT_STATEMENT_ID.into(),
                                id: result_statement.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_x_return" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(x_return) = args.pop().unwrap() {
                            let x_return = x_return.obj.downcast_into::<XReturnProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_x_return(x_return.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid XReturn".into()))
                        }
                    }
                    "exhume_x_return" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let x_return = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_x_return(&id.into())
                                .unwrap();
                            let x_return_proxy = XReturnProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: x_return.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(x_return_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: X_RETURN_ID.into(),
                                id: x_return.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_span" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(span) = args.pop().unwrap() {
                            let span = span.obj.downcast_into::<SpanProxy>().unwrap();
                            self.store.write().unwrap().inter_span(span.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Span".into()))
                        }
                    }
                    "exhume_span" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let span = self.store.read().unwrap().exhume_span(&id.into()).unwrap();
                            let span_proxy = SpanProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: span.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(span_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: SPAN_ID.into(),
                                id: span.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_statement" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(statement) = args.pop().unwrap() {
                            let statement =
                                statement.obj.downcast_into::<StatementProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_statement(statement.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Statement".into()))
                        }
                    }
                    "exhume_statement" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let statement = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_statement(&id.into())
                                .unwrap();
                            let statement_proxy = StatementProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: statement.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(statement_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: STATEMENT_ID.into(),
                                id: statement.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_static_method_call" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(static_method_call) = args.pop().unwrap() {
                            let static_method_call = static_method_call
                                .obj
                                .downcast_into::<StaticMethodCallProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_static_method_call(static_method_call.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid StaticMethodCall".into()))
                        }
                    }
                    "exhume_static_method_call" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let static_method_call = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_static_method_call(&id.into())
                                .unwrap();
                            let static_method_call_proxy = StaticMethodCallProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: static_method_call.clone(),
                                store: self.store.clone(),
                            };
                            let plugin =
                                Plugin_TO::from_value(static_method_call_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: STATIC_METHOD_CALL_ID.into(),
                                id: static_method_call.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_string_literal" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(string_literal) = args.pop().unwrap() {
                            let string_literal = string_literal
                                .obj
                                .downcast_into::<StringLiteralProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_string_literal(string_literal.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid StringLiteral".into()))
                        }
                    }
                    "exhume_string_literal" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let string_literal = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_string_literal(&id.into())
                                .unwrap();
                            let string_literal_proxy = StringLiteralProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: string_literal.clone(),
                                store: self.store.clone(),
                            };
                            let plugin =
                                Plugin_TO::from_value(string_literal_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: STRING_LITERAL_ID.into(),
                                id: string_literal.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_woog_struct" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(woog_struct) = args.pop().unwrap() {
                            let woog_struct =
                                woog_struct.obj.downcast_into::<WoogStructProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_woog_struct(woog_struct.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid WoogStruct".into()))
                        }
                    }
                    "exhume_woog_struct" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let woog_struct = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_woog_struct(&id.into())
                                .unwrap();
                            let woog_struct_proxy = WoogStructProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: woog_struct.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(woog_struct_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: WOOG_STRUCT_ID.into(),
                                id: woog_struct.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_struct_expression" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(struct_expression) = args.pop().unwrap() {
                            let struct_expression = struct_expression
                                .obj
                                .downcast_into::<StructExpressionProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_struct_expression(struct_expression.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid StructExpression".into()))
                        }
                    }
                    "exhume_struct_expression" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let struct_expression = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_struct_expression(&id.into())
                                .unwrap();
                            let struct_expression_proxy = StructExpressionProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: struct_expression.clone(),
                                store: self.store.clone(),
                            };
                            let plugin =
                                Plugin_TO::from_value(struct_expression_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: STRUCT_EXPRESSION_ID.into(),
                                id: struct_expression.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_struct_field" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(struct_field) = args.pop().unwrap() {
                            let struct_field = struct_field
                                .obj
                                .downcast_into::<StructFieldProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_struct_field(struct_field.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid StructField".into()))
                        }
                    }
                    "exhume_struct_field" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let struct_field = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_struct_field(&id.into())
                                .unwrap();
                            let struct_field_proxy = StructFieldProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: struct_field.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(struct_field_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: STRUCT_FIELD_ID.into(),
                                id: struct_field.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_struct_generic" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(struct_generic) = args.pop().unwrap() {
                            let struct_generic = struct_generic
                                .obj
                                .downcast_into::<StructGenericProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_struct_generic(struct_generic.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid StructGeneric".into()))
                        }
                    }
                    "exhume_struct_generic" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let struct_generic = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_struct_generic(&id.into())
                                .unwrap();
                            let struct_generic_proxy = StructGenericProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: struct_generic.clone(),
                                store: self.store.clone(),
                            };
                            let plugin =
                                Plugin_TO::from_value(struct_generic_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: STRUCT_GENERIC_ID.into(),
                                id: struct_generic.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_tuple_field" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(tuple_field) = args.pop().unwrap() {
                            let tuple_field =
                                tuple_field.obj.downcast_into::<TupleFieldProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_tuple_field(tuple_field.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid TupleField".into()))
                        }
                    }
                    "exhume_tuple_field" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let tuple_field = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_tuple_field(&id.into())
                                .unwrap();
                            let tuple_field_proxy = TupleFieldProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: tuple_field.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(tuple_field_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: TUPLE_FIELD_ID.into(),
                                id: tuple_field.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_type_cast" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(type_cast) = args.pop().unwrap() {
                            let type_cast = type_cast.obj.downcast_into::<TypeCastProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_type_cast(type_cast.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid TypeCast".into()))
                        }
                    }
                    "exhume_type_cast" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let type_cast = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_type_cast(&id.into())
                                .unwrap();
                            let type_cast_proxy = TypeCastProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: type_cast.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(type_cast_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: TYPE_CAST_ID.into(),
                                id: type_cast.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_unary" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(unary) = args.pop().unwrap() {
                            let unary = unary.obj.downcast_into::<UnaryProxy>().unwrap();
                            self.store.write().unwrap().inter_unary(unary.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Unary".into()))
                        }
                    }
                    "exhume_unary" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let unary =
                                self.store.read().unwrap().exhume_unary(&id.into()).unwrap();
                            let unary_proxy = UnaryProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: unary.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(unary_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: UNARY_ID.into(),
                                id: unary.read().unwrap().id().into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_unit" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(unit) = args.pop().unwrap() {
                            let unit = unit.obj.downcast_into::<UnitProxy>().unwrap();
                            self.store.write().unwrap().inter_unit(unit.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Unit".into()))
                        }
                    }
                    "exhume_unit" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let unit = self.store.read().unwrap().exhume_unit(&id.into()).unwrap();
                            let unit_proxy = UnitProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: unit.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(unit_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: UNIT_ID.into(),
                                id: unit.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_unnamed_field_expression" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(unnamed_field_expression) = args.pop().unwrap() {
                            let unnamed_field_expression = unnamed_field_expression
                                .obj
                                .downcast_into::<UnnamedFieldExpressionProxy>()
                                .unwrap();
                            self.store.write().unwrap().inter_unnamed_field_expression(
                                unnamed_field_expression.inner.clone(),
                            );
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid UnnamedFieldExpression".into()))
                        }
                    }
                    "exhume_unnamed_field_expression" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let unnamed_field_expression = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_unnamed_field_expression(&id.into())
                                .unwrap();
                            let unnamed_field_expression_proxy = UnnamedFieldExpressionProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: unnamed_field_expression.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(
                                unnamed_field_expression_proxy,
                                TD_CanDowncast,
                            );
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: UNNAMED_FIELD_EXPRESSION_ID.into(),
                                id: unnamed_field_expression.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_x_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(x_value) = args.pop().unwrap() {
                            let x_value = x_value.obj.downcast_into::<XValueProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_x_value(x_value.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid XValue".into()))
                        }
                    }
                    "exhume_x_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let x_value = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_x_value(&id.into())
                                .unwrap();
                            let x_value_proxy = XValueProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: x_value.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(x_value_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: X_VALUE_ID.into(),
                                id: x_value.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_value_type" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(value_type) = args.pop().unwrap() {
                            let value_type =
                                value_type.obj.downcast_into::<ValueTypeProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_value_type(value_type.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid ValueType".into()))
                        }
                    }
                    "exhume_value_type" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let value_type = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_value_type(&id.into())
                                .unwrap();
                            let value_type_proxy = ValueTypeProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: value_type.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(value_type_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: VALUE_TYPE_ID.into(),
                                id: value_type.read().unwrap().id().into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_variable" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(variable) = args.pop().unwrap() {
                            let variable = variable.obj.downcast_into::<VariableProxy>().unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_variable(variable.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid Variable".into()))
                        }
                    }
                    "exhume_variable" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let variable = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_variable(&id.into())
                                .unwrap();
                            let variable_proxy = VariableProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: variable.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(variable_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: VARIABLE_ID.into(),
                                id: variable.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    "inter_variable_expression" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::PlugIn(variable_expression) = args.pop().unwrap() {
                            let variable_expression = variable_expression
                                .obj
                                .downcast_into::<VariableExpressionProxy>()
                                .unwrap();
                            self.store
                                .write()
                                .unwrap()
                                .inter_variable_expression(variable_expression.inner.clone());
                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber("Invalid VariableExpression".into()))
                        }
                    }
                    "exhume_variable_expression" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }
                        if let FfiValue::Uuid(id) = args.pop().unwrap() {
                            let variable_expression = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_variable_expression(&id.into())
                                .unwrap();
                            let variable_expression_proxy = VariableExpressionProxy {
                                // ðŸš§ This bothers me deeply. I know that I've given
                                // this some thought already, and I really need to
                                // document the outcome so that I can stop worrying
                                // over it.
                                inner: variable_expression.clone(),
                                store: self.store.clone(),
                            };
                            let plugin =
                                Plugin_TO::from_value(variable_expression_proxy, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: VARIABLE_EXPRESSION_ID.into(),
                                id: variable_expression.read().unwrap().id.into(), // a
                                plugin: plugin.clone(),
                            };

                            Ok(FfiValue::ProxyType(proxy))
                        } else {
                            Err(Error::Uber("Invalid id".into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Argument" => match func {
                    "new" => {
                        if args.len() != 4 {
                            return Err(Error::Uber("Expected 4 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Argument, Error> {
                            let id = Uuid::new_v4();
                            let argument = Argument {
                                id,
                                position: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                expression: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                function: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                next: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(argument)
                        })() {
                            Ok(argument) => {
                                let argument = Arc::new(RwLock::new(argument));
                                self.store.write().unwrap().inter_argument(argument.clone());
                                let this = ArgumentProxy {
                                    inner: argument.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: ARGUMENT_ID.into(),
                                    id: argument.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for argument in self.store.read().unwrap().iter_argument() {
                            let this = ArgumentProxy {
                                inner: argument.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: ARGUMENT_ID.into(),
                                id: argument.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "AWait" => match func {
                    "new" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<AWait, Error> {
                            let id = Uuid::new_v4();
                            let a_wait = AWait {
                                id,
                                x_future: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(a_wait)
                        })() {
                            Ok(a_wait) => {
                                let a_wait = Arc::new(RwLock::new(a_wait));
                                self.store.write().unwrap().inter_a_wait(a_wait.clone());
                                let this = AWaitProxy {
                                    inner: a_wait.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: A_WAIT_ID.into(),
                                    id: a_wait.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for a_wait in self.store.read().unwrap().iter_a_wait() {
                            let this = AWaitProxy {
                                inner: a_wait.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: A_WAIT_ID.into(),
                                id: a_wait.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Binary" => match func {
                    "new_addition" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Arc<RwLock<Binary>>, Error> {
                            let addition =
                                self.store.read().unwrap().exhume_binary(&ADDITION).unwrap();

                            Ok(addition)
                        })() {
                            Ok(addition) => {
                                let this = BinaryProxy {
                                    inner: addition.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: ADDITION.into(),
                                    id: addition.read().unwrap().id().into(),
                                    plugin: plugin.clone(),
                                };
                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_assignment" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Arc<RwLock<Binary>>, Error> {
                            let assignment = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_binary(&ASSIGNMENT)
                                .unwrap();

                            Ok(assignment)
                        })() {
                            Ok(assignment) => {
                                let this = BinaryProxy {
                                    inner: assignment.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: ASSIGNMENT.into(),
                                    id: assignment.read().unwrap().id().into(),
                                    plugin: plugin.clone(),
                                };
                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_boolean_operator" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Binary, Error> {
                            let boolean_operator = Binary::BooleanOperator(
                                value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            );

                            Ok(boolean_operator)
                        })() {
                            Ok(boolean_operator) => {
                                let boolean_operator = Arc::new(RwLock::new(boolean_operator));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_binary(boolean_operator.clone());
                                let this = BinaryProxy {
                                    inner: boolean_operator.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: BINARY_ID.into(),
                                    id: boolean_operator.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_division" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Arc<RwLock<Binary>>, Error> {
                            let division =
                                self.store.read().unwrap().exhume_binary(&DIVISION).unwrap();

                            Ok(division)
                        })() {
                            Ok(division) => {
                                let this = BinaryProxy {
                                    inner: division.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: DIVISION.into(),
                                    id: division.read().unwrap().id().into(),
                                    plugin: plugin.clone(),
                                };
                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_multiplication" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Arc<RwLock<Binary>>, Error> {
                            let multiplication = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_binary(&MULTIPLICATION)
                                .unwrap();

                            Ok(multiplication)
                        })() {
                            Ok(multiplication) => {
                                let this = BinaryProxy {
                                    inner: multiplication.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: MULTIPLICATION.into(),
                                    id: multiplication.read().unwrap().id().into(),
                                    plugin: plugin.clone(),
                                };
                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_subtraction" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Arc<RwLock<Binary>>, Error> {
                            let subtraction = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_binary(&SUBTRACTION)
                                .unwrap();

                            Ok(subtraction)
                        })() {
                            Ok(subtraction) => {
                                let this = BinaryProxy {
                                    inner: subtraction.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: SUBTRACTION.into(),
                                    id: subtraction.read().unwrap().id().into(),
                                    plugin: plugin.clone(),
                                };
                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for binary in self.store.read().unwrap().iter_binary() {
                            let this = BinaryProxy {
                                inner: binary.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: BINARY_ID.into(),
                                id: binary.read().unwrap().id().into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Block" => match func {
                    "new" => {
                        if args.len() != 3 {
                            return Err(Error::Uber("Expected 3 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Block, Error> {
                            let id = Uuid::new_v4();
                            let block = Block {
                                id,
                                a_sink: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                parent: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                statement: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(block)
                        })() {
                            Ok(block) => {
                                let block = Arc::new(RwLock::new(block));
                                self.store.write().unwrap().inter_block(block.clone());
                                let this = BlockProxy {
                                    inner: block.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: BLOCK_ID.into(),
                                    id: block.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for block in self.store.read().unwrap().iter_block() {
                            let this = BlockProxy {
                                inner: block.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: BLOCK_ID.into(),
                                id: block.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Body" => match func {
                    "new_block" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Body, Error> {
                            let id = Uuid::new_v4();
                            let block = Body {
                                id,
                                subtype: BodyEnum::Block(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                a_sink: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(block)
                        })() {
                            Ok(block) => {
                                let block = Arc::new(RwLock::new(block));
                                self.store.write().unwrap().inter_body(block.clone());
                                let this = BodyProxy {
                                    inner: block.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: BODY_ID.into(),
                                    id: block.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_external_implementation" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Body, Error> {
                            let id = Uuid::new_v4();
                            let external_implementation = Body {
                                id,
                                subtype: BodyEnum::ExternalImplementation(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                a_sink: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(external_implementation)
                        })() {
                            Ok(external_implementation) => {
                                let external_implementation =
                                    Arc::new(RwLock::new(external_implementation));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_body(external_implementation.clone());
                                let this = BodyProxy {
                                    inner: external_implementation.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: BODY_ID.into(),
                                    id: external_implementation.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for body in self.store.read().unwrap().iter_body() {
                            let this = BodyProxy {
                                inner: body.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: BODY_ID.into(),
                                id: body.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "BooleanLiteral" => match func {
                    "new_false_literal" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Arc<RwLock<BooleanLiteral>>, Error> {
                            let false_literal = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_boolean_literal(&FALSE_LITERAL)
                                .unwrap();

                            Ok(false_literal)
                        })() {
                            Ok(false_literal) => {
                                let this = BooleanLiteralProxy {
                                    inner: false_literal.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: FALSE_LITERAL.into(),
                                    id: false_literal.read().unwrap().id().into(),
                                    plugin: plugin.clone(),
                                };
                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_true_literal" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Arc<RwLock<BooleanLiteral>>, Error> {
                            let true_literal = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_boolean_literal(&TRUE_LITERAL)
                                .unwrap();

                            Ok(true_literal)
                        })() {
                            Ok(true_literal) => {
                                let this = BooleanLiteralProxy {
                                    inner: true_literal.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: TRUE_LITERAL.into(),
                                    id: true_literal.read().unwrap().id().into(),
                                    plugin: plugin.clone(),
                                };
                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for boolean_literal in self.store.read().unwrap().iter_boolean_literal() {
                            let this = BooleanLiteralProxy {
                                inner: boolean_literal.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: BOOLEAN_LITERAL_ID.into(),
                                id: boolean_literal.read().unwrap().id().into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "BooleanOperator" => match func {
                    "new_and" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Arc<RwLock<BooleanOperator>>, Error> {
                            let and = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_boolean_operator(&AND)
                                .unwrap();

                            Ok(and)
                        })() {
                            Ok(and) => {
                                let this = BooleanOperatorProxy {
                                    inner: and.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: AND.into(),
                                    id: and.read().unwrap().id().into(),
                                    plugin: plugin.clone(),
                                };
                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_or" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Arc<RwLock<BooleanOperator>>, Error> {
                            let or = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_boolean_operator(&OR)
                                .unwrap();

                            Ok(or)
                        })() {
                            Ok(or) => {
                                let this = BooleanOperatorProxy {
                                    inner: or.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: OR.into(),
                                    id: or.read().unwrap().id().into(),
                                    plugin: plugin.clone(),
                                };
                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for boolean_operator in self.store.read().unwrap().iter_boolean_operator() {
                            let this = BooleanOperatorProxy {
                                inner: boolean_operator.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: BOOLEAN_OPERATOR_ID.into(),
                                id: boolean_operator.read().unwrap().id().into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Call" => match func {
                    "new_function_call" => {
                        if args.len() != 3 {
                            return Err(Error::Uber("Expected 3 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Call, Error> {
                            let id = Uuid::new_v4();
                            let function_call = Call {
                                id,
                                subtype: CallEnum::FunctionCall(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                arg_check: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                argument: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                expression: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(function_call)
                        })() {
                            Ok(function_call) => {
                                let function_call = Arc::new(RwLock::new(function_call));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_call(function_call.clone());
                                let this = CallProxy {
                                    inner: function_call.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: CALL_ID.into(),
                                    id: function_call.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_macro_call" => {
                        if args.len() != 3 {
                            return Err(Error::Uber("Expected 3 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Call, Error> {
                            let id = Uuid::new_v4();
                            let macro_call = Call {
                                id,
                                subtype: CallEnum::MacroCall(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                arg_check: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                argument: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                expression: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(macro_call)
                        })() {
                            Ok(macro_call) => {
                                let macro_call = Arc::new(RwLock::new(macro_call));
                                self.store.write().unwrap().inter_call(macro_call.clone());
                                let this = CallProxy {
                                    inner: macro_call.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: CALL_ID.into(),
                                    id: macro_call.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_method_call" => {
                        if args.len() != 3 {
                            return Err(Error::Uber("Expected 3 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Call, Error> {
                            let id = Uuid::new_v4();
                            let method_call = Call {
                                id,
                                subtype: CallEnum::MethodCall(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                arg_check: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                argument: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                expression: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(method_call)
                        })() {
                            Ok(method_call) => {
                                let method_call = Arc::new(RwLock::new(method_call));
                                self.store.write().unwrap().inter_call(method_call.clone());
                                let this = CallProxy {
                                    inner: method_call.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: CALL_ID.into(),
                                    id: method_call.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_static_method_call" => {
                        if args.len() != 3 {
                            return Err(Error::Uber("Expected 3 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Call, Error> {
                            let id = Uuid::new_v4();
                            let static_method_call = Call {
                                id,
                                subtype: CallEnum::StaticMethodCall(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                arg_check: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                argument: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                expression: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(static_method_call)
                        })() {
                            Ok(static_method_call) => {
                                let static_method_call = Arc::new(RwLock::new(static_method_call));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_call(static_method_call.clone());
                                let this = CallProxy {
                                    inner: static_method_call.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: CALL_ID.into(),
                                    id: static_method_call.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for call in self.store.read().unwrap().iter_call() {
                            let this = CallProxy {
                                inner: call.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: CALL_ID.into(),
                                id: call.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Comparison" => match func {
                    "new_equal" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Arc<RwLock<Comparison>>, Error> {
                            let equal = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_comparison(&EQUAL)
                                .unwrap();

                            Ok(equal)
                        })() {
                            Ok(equal) => {
                                let this = ComparisonProxy {
                                    inner: equal.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EQUAL.into(),
                                    id: equal.read().unwrap().id().into(),
                                    plugin: plugin.clone(),
                                };
                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_greater_than" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Arc<RwLock<Comparison>>, Error> {
                            let greater_than = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_comparison(&GREATER_THAN)
                                .unwrap();

                            Ok(greater_than)
                        })() {
                            Ok(greater_than) => {
                                let this = ComparisonProxy {
                                    inner: greater_than.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: GREATER_THAN.into(),
                                    id: greater_than.read().unwrap().id().into(),
                                    plugin: plugin.clone(),
                                };
                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_greater_than_or_equal" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Arc<RwLock<Comparison>>, Error> {
                            let greater_than_or_equal = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_comparison(&GREATER_THAN_OR_EQUAL)
                                .unwrap();

                            Ok(greater_than_or_equal)
                        })() {
                            Ok(greater_than_or_equal) => {
                                let this = ComparisonProxy {
                                    inner: greater_than_or_equal.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: GREATER_THAN_OR_EQUAL.into(),
                                    id: greater_than_or_equal.read().unwrap().id().into(),
                                    plugin: plugin.clone(),
                                };
                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_less_than" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Arc<RwLock<Comparison>>, Error> {
                            let less_than = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_comparison(&LESS_THAN)
                                .unwrap();

                            Ok(less_than)
                        })() {
                            Ok(less_than) => {
                                let this = ComparisonProxy {
                                    inner: less_than.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: LESS_THAN.into(),
                                    id: less_than.read().unwrap().id().into(),
                                    plugin: plugin.clone(),
                                };
                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_less_than_or_equal" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Arc<RwLock<Comparison>>, Error> {
                            let less_than_or_equal = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_comparison(&LESS_THAN_OR_EQUAL)
                                .unwrap();

                            Ok(less_than_or_equal)
                        })() {
                            Ok(less_than_or_equal) => {
                                let this = ComparisonProxy {
                                    inner: less_than_or_equal.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: LESS_THAN_OR_EQUAL.into(),
                                    id: less_than_or_equal.read().unwrap().id().into(),
                                    plugin: plugin.clone(),
                                };
                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_not_equal" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Arc<RwLock<Comparison>>, Error> {
                            let not_equal = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_comparison(&NOT_EQUAL)
                                .unwrap();

                            Ok(not_equal)
                        })() {
                            Ok(not_equal) => {
                                let this = ComparisonProxy {
                                    inner: not_equal.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: NOT_EQUAL.into(),
                                    id: not_equal.read().unwrap().id().into(),
                                    plugin: plugin.clone(),
                                };
                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for comparison in self.store.read().unwrap().iter_comparison() {
                            let this = ComparisonProxy {
                                inner: comparison.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: COMPARISON_ID.into(),
                                id: comparison.read().unwrap().id().into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "DataStructure" => match func {
                    "new_enumeration" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<DataStructure, Error> {
                            let enumeration = DataStructure::Enumeration(
                                value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            );

                            Ok(enumeration)
                        })() {
                            Ok(enumeration) => {
                                let enumeration = Arc::new(RwLock::new(enumeration));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_data_structure(enumeration.clone());
                                let this = DataStructureProxy {
                                    inner: enumeration.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: DATA_STRUCTURE_ID.into(),
                                    id: enumeration.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_woog_struct" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<DataStructure, Error> {
                            let woog_struct = DataStructure::WoogStruct(
                                value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            );

                            Ok(woog_struct)
                        })() {
                            Ok(woog_struct) => {
                                let woog_struct = Arc::new(RwLock::new(woog_struct));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_data_structure(woog_struct.clone());
                                let this = DataStructureProxy {
                                    inner: woog_struct.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: DATA_STRUCTURE_ID.into(),
                                    id: woog_struct.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for data_structure in self.store.read().unwrap().iter_data_structure() {
                            let this = DataStructureProxy {
                                inner: data_structure.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: DATA_STRUCTURE_ID.into(),
                                id: data_structure.read().unwrap().id().into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "DwarfSourceFile" => match func {
                    "new" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<DwarfSourceFile, Error> {
                            let id = Uuid::new_v4();
                            let dwarf_source_file = DwarfSourceFile {
                                id,
                                source: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(dwarf_source_file)
                        })() {
                            Ok(dwarf_source_file) => {
                                let dwarf_source_file = Arc::new(RwLock::new(dwarf_source_file));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_dwarf_source_file(dwarf_source_file.clone());
                                let this = DwarfSourceFileProxy {
                                    inner: dwarf_source_file.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: DWARF_SOURCE_FILE_ID.into(),
                                    id: dwarf_source_file.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for dwarf_source_file in self.store.read().unwrap().iter_dwarf_source_file()
                        {
                            let this = DwarfSourceFileProxy {
                                inner: dwarf_source_file.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: DWARF_SOURCE_FILE_ID.into(),
                                id: dwarf_source_file.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "EnumField" => match func {
                    "new_struct_field" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<EnumField, Error> {
                            let id = Uuid::new_v4();
                            let struct_field = EnumField {
                                id,
                                subtype: EnumFieldEnum::StructField(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                name: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                woog_enum: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(struct_field)
                        })() {
                            Ok(struct_field) => {
                                let struct_field = Arc::new(RwLock::new(struct_field));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_enum_field(struct_field.clone());
                                let this = EnumFieldProxy {
                                    inner: struct_field.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: ENUM_FIELD_ID.into(),
                                    id: struct_field.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_tuple_field" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<EnumField, Error> {
                            let id = Uuid::new_v4();
                            let tuple_field = EnumField {
                                id,
                                subtype: EnumFieldEnum::TupleField(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                name: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                woog_enum: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(tuple_field)
                        })() {
                            Ok(tuple_field) => {
                                let tuple_field = Arc::new(RwLock::new(tuple_field));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_enum_field(tuple_field.clone());
                                let this = EnumFieldProxy {
                                    inner: tuple_field.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: ENUM_FIELD_ID.into(),
                                    id: tuple_field.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_unit" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<EnumField, Error> {
                            let id = Uuid::new_v4();
                            let unit = EnumField {
                                id,
                                subtype: EnumFieldEnum::Unit(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                name: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                woog_enum: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(unit)
                        })() {
                            Ok(unit) => {
                                let unit = Arc::new(RwLock::new(unit));
                                self.store.write().unwrap().inter_enum_field(unit.clone());
                                let this = EnumFieldProxy {
                                    inner: unit.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: ENUM_FIELD_ID.into(),
                                    id: unit.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for enum_field in self.store.read().unwrap().iter_enum_field() {
                            let this = EnumFieldProxy {
                                inner: enum_field.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: ENUM_FIELD_ID.into(),
                                id: enum_field.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Enumeration" => match func {
                    "new" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Enumeration, Error> {
                            let id = Uuid::new_v4();
                            let enumeration = Enumeration {
                                id,
                                name: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                implementation: value_args.pop().unwrap().try_into().map_err(
                                    |e| Error::Uber(format!("Error converting value: {e}").into()),
                                )?,
                            };

                            Ok(enumeration)
                        })() {
                            Ok(enumeration) => {
                                let enumeration = Arc::new(RwLock::new(enumeration));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_enumeration(enumeration.clone());
                                let this = EnumerationProxy {
                                    inner: enumeration.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: ENUMERATION_ID.into(),
                                    id: enumeration.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for enumeration in self.store.read().unwrap().iter_enumeration() {
                            let this = EnumerationProxy {
                                inner: enumeration.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: ENUMERATION_ID.into(),
                                id: enumeration.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Expression" => match func {
                    "new_a_wait" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Expression, Error> {
                            let a_wait =
                                Expression::AWait(value_args.pop().unwrap().try_into().map_err(
                                    |e| Error::Uber(format!("Error converting value: {e}").into()),
                                )?);

                            Ok(a_wait)
                        })() {
                            Ok(a_wait) => {
                                let a_wait = Arc::new(RwLock::new(a_wait));
                                self.store.write().unwrap().inter_expression(a_wait.clone());
                                let this = ExpressionProxy {
                                    inner: a_wait.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EXPRESSION_ID.into(),
                                    id: a_wait.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_block" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Expression, Error> {
                            let block =
                                Expression::Block(value_args.pop().unwrap().try_into().map_err(
                                    |e| Error::Uber(format!("Error converting value: {e}").into()),
                                )?);

                            Ok(block)
                        })() {
                            Ok(block) => {
                                let block = Arc::new(RwLock::new(block));
                                self.store.write().unwrap().inter_expression(block.clone());
                                let this = ExpressionProxy {
                                    inner: block.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EXPRESSION_ID.into(),
                                    id: block.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_call" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Expression, Error> {
                            let call =
                                Expression::Call(value_args.pop().unwrap().try_into().map_err(
                                    |e| Error::Uber(format!("Error converting value: {e}").into()),
                                )?);

                            Ok(call)
                        })() {
                            Ok(call) => {
                                let call = Arc::new(RwLock::new(call));
                                self.store.write().unwrap().inter_expression(call.clone());
                                let this = ExpressionProxy {
                                    inner: call.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EXPRESSION_ID.into(),
                                    id: call.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_debugger" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Arc<RwLock<Expression>>, Error> {
                            let debugger = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_expression(&DEBUGGER)
                                .unwrap();

                            Ok(debugger)
                        })() {
                            Ok(debugger) => {
                                let this = ExpressionProxy {
                                    inner: debugger.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: DEBUGGER.into(),
                                    id: debugger.read().unwrap().id().into(),
                                    plugin: plugin.clone(),
                                };
                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_empty_expression" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Arc<RwLock<Expression>>, Error> {
                            let empty_expression = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_expression(&EMPTY_EXPRESSION)
                                .unwrap();

                            Ok(empty_expression)
                        })() {
                            Ok(empty_expression) => {
                                let this = ExpressionProxy {
                                    inner: empty_expression.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EMPTY_EXPRESSION.into(),
                                    id: empty_expression.read().unwrap().id().into(),
                                    plugin: plugin.clone(),
                                };
                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_field_access" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Expression, Error> {
                            let field_access = Expression::FieldAccess(
                                value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            );

                            Ok(field_access)
                        })() {
                            Ok(field_access) => {
                                let field_access = Arc::new(RwLock::new(field_access));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_expression(field_access.clone());
                                let this = ExpressionProxy {
                                    inner: field_access.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EXPRESSION_ID.into(),
                                    id: field_access.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_field_expression" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Expression, Error> {
                            let field_expression = Expression::FieldExpression(
                                value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            );

                            Ok(field_expression)
                        })() {
                            Ok(field_expression) => {
                                let field_expression = Arc::new(RwLock::new(field_expression));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_expression(field_expression.clone());
                                let this = ExpressionProxy {
                                    inner: field_expression.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EXPRESSION_ID.into(),
                                    id: field_expression.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_for_loop" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Expression, Error> {
                            let for_loop =
                                Expression::ForLoop(value_args.pop().unwrap().try_into().map_err(
                                    |e| Error::Uber(format!("Error converting value: {e}").into()),
                                )?);

                            Ok(for_loop)
                        })() {
                            Ok(for_loop) => {
                                let for_loop = Arc::new(RwLock::new(for_loop));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_expression(for_loop.clone());
                                let this = ExpressionProxy {
                                    inner: for_loop.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EXPRESSION_ID.into(),
                                    id: for_loop.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_grouped" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Expression, Error> {
                            let grouped =
                                Expression::Grouped(value_args.pop().unwrap().try_into().map_err(
                                    |e| Error::Uber(format!("Error converting value: {e}").into()),
                                )?);

                            Ok(grouped)
                        })() {
                            Ok(grouped) => {
                                let grouped = Arc::new(RwLock::new(grouped));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_expression(grouped.clone());
                                let this = ExpressionProxy {
                                    inner: grouped.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EXPRESSION_ID.into(),
                                    id: grouped.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_x_if" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Expression, Error> {
                            let x_if =
                                Expression::XIf(value_args.pop().unwrap().try_into().map_err(
                                    |e| Error::Uber(format!("Error converting value: {e}").into()),
                                )?);

                            Ok(x_if)
                        })() {
                            Ok(x_if) => {
                                let x_if = Arc::new(RwLock::new(x_if));
                                self.store.write().unwrap().inter_expression(x_if.clone());
                                let this = ExpressionProxy {
                                    inner: x_if.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EXPRESSION_ID.into(),
                                    id: x_if.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_index" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Expression, Error> {
                            let index =
                                Expression::Index(value_args.pop().unwrap().try_into().map_err(
                                    |e| Error::Uber(format!("Error converting value: {e}").into()),
                                )?);

                            Ok(index)
                        })() {
                            Ok(index) => {
                                let index = Arc::new(RwLock::new(index));
                                self.store.write().unwrap().inter_expression(index.clone());
                                let this = ExpressionProxy {
                                    inner: index.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EXPRESSION_ID.into(),
                                    id: index.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_lambda" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Expression, Error> {
                            let lambda =
                                Expression::Lambda(value_args.pop().unwrap().try_into().map_err(
                                    |e| Error::Uber(format!("Error converting value: {e}").into()),
                                )?);

                            Ok(lambda)
                        })() {
                            Ok(lambda) => {
                                let lambda = Arc::new(RwLock::new(lambda));
                                self.store.write().unwrap().inter_expression(lambda.clone());
                                let this = ExpressionProxy {
                                    inner: lambda.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EXPRESSION_ID.into(),
                                    id: lambda.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_list_element" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Expression, Error> {
                            let list_element = Expression::ListElement(
                                value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            );

                            Ok(list_element)
                        })() {
                            Ok(list_element) => {
                                let list_element = Arc::new(RwLock::new(list_element));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_expression(list_element.clone());
                                let this = ExpressionProxy {
                                    inner: list_element.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EXPRESSION_ID.into(),
                                    id: list_element.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_list_expression" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Expression, Error> {
                            let list_expression = Expression::ListExpression(
                                value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            );

                            Ok(list_expression)
                        })() {
                            Ok(list_expression) => {
                                let list_expression = Arc::new(RwLock::new(list_expression));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_expression(list_expression.clone());
                                let this = ExpressionProxy {
                                    inner: list_expression.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EXPRESSION_ID.into(),
                                    id: list_expression.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_literal" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Expression, Error> {
                            let literal =
                                Expression::Literal(value_args.pop().unwrap().try_into().map_err(
                                    |e| Error::Uber(format!("Error converting value: {e}").into()),
                                )?);

                            Ok(literal)
                        })() {
                            Ok(literal) => {
                                let literal = Arc::new(RwLock::new(literal));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_expression(literal.clone());
                                let this = ExpressionProxy {
                                    inner: literal.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EXPRESSION_ID.into(),
                                    id: literal.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_x_match" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Expression, Error> {
                            let x_match =
                                Expression::XMatch(value_args.pop().unwrap().try_into().map_err(
                                    |e| Error::Uber(format!("Error converting value: {e}").into()),
                                )?);

                            Ok(x_match)
                        })() {
                            Ok(x_match) => {
                                let x_match = Arc::new(RwLock::new(x_match));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_expression(x_match.clone());
                                let this = ExpressionProxy {
                                    inner: x_match.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EXPRESSION_ID.into(),
                                    id: x_match.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_operator" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Expression, Error> {
                            let operator = Expression::Operator(
                                value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            );

                            Ok(operator)
                        })() {
                            Ok(operator) => {
                                let operator = Arc::new(RwLock::new(operator));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_expression(operator.clone());
                                let this = ExpressionProxy {
                                    inner: operator.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EXPRESSION_ID.into(),
                                    id: operator.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_x_path" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Expression, Error> {
                            let x_path =
                                Expression::XPath(value_args.pop().unwrap().try_into().map_err(
                                    |e| Error::Uber(format!("Error converting value: {e}").into()),
                                )?);

                            Ok(x_path)
                        })() {
                            Ok(x_path) => {
                                let x_path = Arc::new(RwLock::new(x_path));
                                self.store.write().unwrap().inter_expression(x_path.clone());
                                let this = ExpressionProxy {
                                    inner: x_path.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EXPRESSION_ID.into(),
                                    id: x_path.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_x_print" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Expression, Error> {
                            let x_print =
                                Expression::XPrint(value_args.pop().unwrap().try_into().map_err(
                                    |e| Error::Uber(format!("Error converting value: {e}").into()),
                                )?);

                            Ok(x_print)
                        })() {
                            Ok(x_print) => {
                                let x_print = Arc::new(RwLock::new(x_print));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_expression(x_print.clone());
                                let this = ExpressionProxy {
                                    inner: x_print.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EXPRESSION_ID.into(),
                                    id: x_print.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_range_expression" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Expression, Error> {
                            let range_expression = Expression::RangeExpression(
                                value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            );

                            Ok(range_expression)
                        })() {
                            Ok(range_expression) => {
                                let range_expression = Arc::new(RwLock::new(range_expression));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_expression(range_expression.clone());
                                let this = ExpressionProxy {
                                    inner: range_expression.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EXPRESSION_ID.into(),
                                    id: range_expression.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_x_return" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Expression, Error> {
                            let x_return =
                                Expression::XReturn(value_args.pop().unwrap().try_into().map_err(
                                    |e| Error::Uber(format!("Error converting value: {e}").into()),
                                )?);

                            Ok(x_return)
                        })() {
                            Ok(x_return) => {
                                let x_return = Arc::new(RwLock::new(x_return));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_expression(x_return.clone());
                                let this = ExpressionProxy {
                                    inner: x_return.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EXPRESSION_ID.into(),
                                    id: x_return.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_struct_expression" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Expression, Error> {
                            let struct_expression = Expression::StructExpression(
                                value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            );

                            Ok(struct_expression)
                        })() {
                            Ok(struct_expression) => {
                                let struct_expression = Arc::new(RwLock::new(struct_expression));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_expression(struct_expression.clone());
                                let this = ExpressionProxy {
                                    inner: struct_expression.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EXPRESSION_ID.into(),
                                    id: struct_expression.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_type_cast" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Expression, Error> {
                            let type_cast = Expression::TypeCast(
                                value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            );

                            Ok(type_cast)
                        })() {
                            Ok(type_cast) => {
                                let type_cast = Arc::new(RwLock::new(type_cast));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_expression(type_cast.clone());
                                let this = ExpressionProxy {
                                    inner: type_cast.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EXPRESSION_ID.into(),
                                    id: type_cast.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_variable_expression" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Expression, Error> {
                            let variable_expression = Expression::VariableExpression(
                                value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            );

                            Ok(variable_expression)
                        })() {
                            Ok(variable_expression) => {
                                let variable_expression =
                                    Arc::new(RwLock::new(variable_expression));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_expression(variable_expression.clone());
                                let this = ExpressionProxy {
                                    inner: variable_expression.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EXPRESSION_ID.into(),
                                    id: variable_expression.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for expression in self.store.read().unwrap().iter_expression() {
                            let this = ExpressionProxy {
                                inner: expression.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: EXPRESSION_ID.into(),
                                id: expression.read().unwrap().id().into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "ExpressionStatement" => match func {
                    "new" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<ExpressionStatement, Error> {
                            let id = Uuid::new_v4();
                            let expression_statement = ExpressionStatement {
                                id,
                                expression: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(expression_statement)
                        })() {
                            Ok(expression_statement) => {
                                let expression_statement =
                                    Arc::new(RwLock::new(expression_statement));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_expression_statement(expression_statement.clone());
                                let this = ExpressionStatementProxy {
                                    inner: expression_statement.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EXPRESSION_STATEMENT_ID.into(),
                                    id: expression_statement.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for expression_statement in
                            self.store.read().unwrap().iter_expression_statement()
                        {
                            let this = ExpressionStatementProxy {
                                inner: expression_statement.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: EXPRESSION_STATEMENT_ID.into(),
                                id: expression_statement.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "ExternalImplementation" => match func {
                    "new" => {
                        if args.len() != 3 {
                            return Err(Error::Uber("Expected 3 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<ExternalImplementation, Error> {
                            let id = Uuid::new_v4();
                            let external_implementation = ExternalImplementation {
                                id,
                                function: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                x_model: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                object: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(external_implementation)
                        })() {
                            Ok(external_implementation) => {
                                let external_implementation =
                                    Arc::new(RwLock::new(external_implementation));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_external_implementation(external_implementation.clone());
                                let this = ExternalImplementationProxy {
                                    inner: external_implementation.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EXTERNAL_IMPLEMENTATION_ID.into(),
                                    id: external_implementation.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for external_implementation in
                            self.store.read().unwrap().iter_external_implementation()
                        {
                            let this = ExternalImplementationProxy {
                                inner: external_implementation.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: EXTERNAL_IMPLEMENTATION_ID.into(),
                                id: external_implementation.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Field" => match func {
                    "new" => {
                        if args.len() != 3 {
                            return Err(Error::Uber("Expected 3 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Field, Error> {
                            let id = Uuid::new_v4();
                            let field = Field {
                                id,
                                name: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                x_model: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                ty: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(field)
                        })() {
                            Ok(field) => {
                                let field = Arc::new(RwLock::new(field));
                                self.store.write().unwrap().inter_field(field.clone());
                                let this = FieldProxy {
                                    inner: field.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: FIELD_ID.into(),
                                    id: field.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for field in self.store.read().unwrap().iter_field() {
                            let this = FieldProxy {
                                inner: field.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: FIELD_ID.into(),
                                id: field.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "FieldAccess" => match func {
                    "new" => {
                        if args.len() != 3 {
                            return Err(Error::Uber("Expected 3 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<FieldAccess, Error> {
                            let id = Uuid::new_v4();
                            let field_access = FieldAccess {
                                id,
                                expression: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                field: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                woog_struct: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(field_access)
                        })() {
                            Ok(field_access) => {
                                let field_access = Arc::new(RwLock::new(field_access));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_field_access(field_access.clone());
                                let this = FieldAccessProxy {
                                    inner: field_access.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: FIELD_ACCESS_ID.into(),
                                    id: field_access.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for field_access in self.store.read().unwrap().iter_field_access() {
                            let this = FieldAccessProxy {
                                inner: field_access.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: FIELD_ACCESS_ID.into(),
                                id: field_access.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "FieldAccessTarget" => match func {
                    "new_enum_field" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<FieldAccessTarget, Error> {
                            let enum_field = FieldAccessTarget::EnumField(
                                value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            );

                            Ok(enum_field)
                        })() {
                            Ok(enum_field) => {
                                let enum_field = Arc::new(RwLock::new(enum_field));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_field_access_target(enum_field.clone());
                                let this = FieldAccessTargetProxy {
                                    inner: enum_field.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: FIELD_ACCESS_TARGET_ID.into(),
                                    id: enum_field.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_field" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<FieldAccessTarget, Error> {
                            let field = FieldAccessTarget::Field(
                                value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            );

                            Ok(field)
                        })() {
                            Ok(field) => {
                                let field = Arc::new(RwLock::new(field));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_field_access_target(field.clone());
                                let this = FieldAccessTargetProxy {
                                    inner: field.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: FIELD_ACCESS_TARGET_ID.into(),
                                    id: field.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_function" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<FieldAccessTarget, Error> {
                            let function = FieldAccessTarget::Function(
                                value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            );

                            Ok(function)
                        })() {
                            Ok(function) => {
                                let function = Arc::new(RwLock::new(function));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_field_access_target(function.clone());
                                let this = FieldAccessTargetProxy {
                                    inner: function.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: FIELD_ACCESS_TARGET_ID.into(),
                                    id: function.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for field_access_target in
                            self.store.read().unwrap().iter_field_access_target()
                        {
                            let this = FieldAccessTargetProxy {
                                inner: field_access_target.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: FIELD_ACCESS_TARGET_ID.into(),
                                id: field_access_target.read().unwrap().id().into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "FieldExpression" => match func {
                    "new_named_field_expression" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<FieldExpression, Error> {
                            let id = Uuid::new_v4();
                            let named_field_expression = FieldExpression {
                                id,
                                subtype: FieldExpressionEnum::NamedFieldExpression(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                expression: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                woog_struct: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(named_field_expression)
                        })() {
                            Ok(named_field_expression) => {
                                let named_field_expression =
                                    Arc::new(RwLock::new(named_field_expression));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_field_expression(named_field_expression.clone());
                                let this = FieldExpressionProxy {
                                    inner: named_field_expression.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: FIELD_EXPRESSION_ID.into(),
                                    id: named_field_expression.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_unnamed_field_expression" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<FieldExpression, Error> {
                            let id = Uuid::new_v4();
                            let unnamed_field_expression = FieldExpression {
                                id,
                                subtype: FieldExpressionEnum::UnnamedFieldExpression(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                expression: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                woog_struct: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(unnamed_field_expression)
                        })() {
                            Ok(unnamed_field_expression) => {
                                let unnamed_field_expression =
                                    Arc::new(RwLock::new(unnamed_field_expression));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_field_expression(unnamed_field_expression.clone());
                                let this = FieldExpressionProxy {
                                    inner: unnamed_field_expression.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: FIELD_EXPRESSION_ID.into(),
                                    id: unnamed_field_expression.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for field_expression in self.store.read().unwrap().iter_field_expression() {
                            let this = FieldExpressionProxy {
                                inner: field_expression.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: FIELD_EXPRESSION_ID.into(),
                                id: field_expression.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "FloatLiteral" => match func {
                    "new" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<FloatLiteral, Error> {
                            let id = Uuid::new_v4();
                            let float_literal = FloatLiteral {
                                id,
                                x_value: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(float_literal)
                        })() {
                            Ok(float_literal) => {
                                let float_literal = Arc::new(RwLock::new(float_literal));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_float_literal(float_literal.clone());
                                let this = FloatLiteralProxy {
                                    inner: float_literal.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: FLOAT_LITERAL_ID.into(),
                                    id: float_literal.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for float_literal in self.store.read().unwrap().iter_float_literal() {
                            let this = FloatLiteralProxy {
                                inner: float_literal.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: FLOAT_LITERAL_ID.into(),
                                id: float_literal.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "ForLoop" => match func {
                    "new" => {
                        if args.len() != 3 {
                            return Err(Error::Uber("Expected 3 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<ForLoop, Error> {
                            let id = Uuid::new_v4();
                            let for_loop = ForLoop {
                                id,
                                ident: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                block: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                expression: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(for_loop)
                        })() {
                            Ok(for_loop) => {
                                let for_loop = Arc::new(RwLock::new(for_loop));
                                self.store.write().unwrap().inter_for_loop(for_loop.clone());
                                let this = ForLoopProxy {
                                    inner: for_loop.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: FOR_LOOP_ID.into(),
                                    id: for_loop.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for for_loop in self.store.read().unwrap().iter_for_loop() {
                            let this = ForLoopProxy {
                                inner: for_loop.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: FOR_LOOP_ID.into(),
                                id: for_loop.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Function" => match func {
                    "new" => {
                        if args.len() != 5 {
                            return Err(Error::Uber("Expected 5 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Function, Error> {
                            let id = Uuid::new_v4();
                            let function = Function {
                                id,
                                name: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                body: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                first_param: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                impl_block: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                return_type: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(function)
                        })() {
                            Ok(function) => {
                                let function = Arc::new(RwLock::new(function));
                                self.store.write().unwrap().inter_function(function.clone());
                                let this = FunctionProxy {
                                    inner: function.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: FUNCTION_ID.into(),
                                    id: function.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for function in self.store.read().unwrap().iter_function() {
                            let this = FunctionProxy {
                                inner: function.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: FUNCTION_ID.into(),
                                id: function.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "XFuture" => match func {
                    "new" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<XFuture, Error> {
                            let id = Uuid::new_v4();
                            let x_future = XFuture {
                                id,
                                x_value: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(x_future)
                        })() {
                            Ok(x_future) => {
                                let x_future = Arc::new(RwLock::new(x_future));
                                self.store.write().unwrap().inter_x_future(x_future.clone());
                                let this = XFutureProxy {
                                    inner: x_future.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: X_FUTURE_ID.into(),
                                    id: x_future.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for x_future in self.store.read().unwrap().iter_x_future() {
                            let this = XFutureProxy {
                                inner: x_future.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: X_FUTURE_ID.into(),
                                id: x_future.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Generic" => match func {
                    "new" => {
                        if args.len() != 3 {
                            return Err(Error::Uber("Expected 3 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Generic, Error> {
                            let id = Uuid::new_v4();
                            let generic = Generic {
                                id,
                                name: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                next: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                ty: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(generic)
                        })() {
                            Ok(generic) => {
                                let generic = Arc::new(RwLock::new(generic));
                                self.store.write().unwrap().inter_generic(generic.clone());
                                let this = GenericProxy {
                                    inner: generic.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: GENERIC_ID.into(),
                                    id: generic.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for generic in self.store.read().unwrap().iter_generic() {
                            let this = GenericProxy {
                                inner: generic.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: GENERIC_ID.into(),
                                id: generic.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Grouped" => match func {
                    "new" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Grouped, Error> {
                            let id = Uuid::new_v4();
                            let grouped = Grouped {
                                id,
                                expression: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(grouped)
                        })() {
                            Ok(grouped) => {
                                let grouped = Arc::new(RwLock::new(grouped));
                                self.store.write().unwrap().inter_grouped(grouped.clone());
                                let this = GroupedProxy {
                                    inner: grouped.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: GROUPED_ID.into(),
                                    id: grouped.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for grouped in self.store.read().unwrap().iter_grouped() {
                            let this = GroupedProxy {
                                inner: grouped.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: GROUPED_ID.into(),
                                id: grouped.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "XIf" => match func {
                    "new" => {
                        if args.len() != 3 {
                            return Err(Error::Uber("Expected 3 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<XIf, Error> {
                            let id = Uuid::new_v4();
                            let x_if = XIf {
                                id,
                                false_block: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                test: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                true_block: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(x_if)
                        })() {
                            Ok(x_if) => {
                                let x_if = Arc::new(RwLock::new(x_if));
                                self.store.write().unwrap().inter_x_if(x_if.clone());
                                let this = XIfProxy {
                                    inner: x_if.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: X_IF_ID.into(),
                                    id: x_if.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for x_if in self.store.read().unwrap().iter_x_if() {
                            let this = XIfProxy {
                                inner: x_if.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: X_IF_ID.into(),
                                id: x_if.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "ImplementationBlock" => match func {
                    "new" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<ImplementationBlock, Error> {
                            let id = Uuid::new_v4();
                            let implementation_block = ImplementationBlock {
                                id,
                                model_type: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                object_store: value_args.pop().unwrap().try_into().map_err(
                                    |e| Error::Uber(format!("Error converting value: {e}").into()),
                                )?,
                            };

                            Ok(implementation_block)
                        })() {
                            Ok(implementation_block) => {
                                let implementation_block =
                                    Arc::new(RwLock::new(implementation_block));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_implementation_block(implementation_block.clone());
                                let this = ImplementationBlockProxy {
                                    inner: implementation_block.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: IMPLEMENTATION_BLOCK_ID.into(),
                                    id: implementation_block.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for implementation_block in
                            self.store.read().unwrap().iter_implementation_block()
                        {
                            let this = ImplementationBlockProxy {
                                inner: implementation_block.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: IMPLEMENTATION_BLOCK_ID.into(),
                                id: implementation_block.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Import" => match func {
                    "new" => {
                        if args.len() != 5 {
                            return Err(Error::Uber("Expected 5 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Import, Error> {
                            let id = Uuid::new_v4();
                            let import = Import {
                                id,
                                alias: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                has_alias: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                name: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                x_path: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                object: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(import)
                        })() {
                            Ok(import) => {
                                let import = Arc::new(RwLock::new(import));
                                self.store.write().unwrap().inter_import(import.clone());
                                let this = ImportProxy {
                                    inner: import.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: IMPORT_ID.into(),
                                    id: import.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for import in self.store.read().unwrap().iter_import() {
                            let this = ImportProxy {
                                inner: import.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: IMPORT_ID.into(),
                                id: import.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Index" => match func {
                    "new" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Index, Error> {
                            let id = Uuid::new_v4();
                            let index = Index {
                                id,
                                index: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                target: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(index)
                        })() {
                            Ok(index) => {
                                let index = Arc::new(RwLock::new(index));
                                self.store.write().unwrap().inter_index(index.clone());
                                let this = IndexProxy {
                                    inner: index.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: INDEX_ID.into(),
                                    id: index.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for index in self.store.read().unwrap().iter_index() {
                            let this = IndexProxy {
                                inner: index.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: INDEX_ID.into(),
                                id: index.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "IntegerLiteral" => match func {
                    "new" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<IntegerLiteral, Error> {
                            let id = Uuid::new_v4();
                            let integer_literal = IntegerLiteral {
                                id,
                                x_value: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(integer_literal)
                        })() {
                            Ok(integer_literal) => {
                                let integer_literal = Arc::new(RwLock::new(integer_literal));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_integer_literal(integer_literal.clone());
                                let this = IntegerLiteralProxy {
                                    inner: integer_literal.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: INTEGER_LITERAL_ID.into(),
                                    id: integer_literal.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for integer_literal in self.store.read().unwrap().iter_integer_literal() {
                            let this = IntegerLiteralProxy {
                                inner: integer_literal.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: INTEGER_LITERAL_ID.into(),
                                id: integer_literal.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Item" => match func {
                    "new_enumeration" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Item, Error> {
                            let id = Uuid::new_v4();
                            let enumeration = Item {
                                id,
                                subtype: ItemEnum::Enumeration(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                source: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(enumeration)
                        })() {
                            Ok(enumeration) => {
                                let enumeration = Arc::new(RwLock::new(enumeration));
                                self.store.write().unwrap().inter_item(enumeration.clone());
                                let this = ItemProxy {
                                    inner: enumeration.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: ITEM_ID.into(),
                                    id: enumeration.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_function" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Item, Error> {
                            let id = Uuid::new_v4();
                            let function = Item {
                                id,
                                subtype: ItemEnum::Function(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                source: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(function)
                        })() {
                            Ok(function) => {
                                let function = Arc::new(RwLock::new(function));
                                self.store.write().unwrap().inter_item(function.clone());
                                let this = ItemProxy {
                                    inner: function.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: ITEM_ID.into(),
                                    id: function.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_implementation_block" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Item, Error> {
                            let id = Uuid::new_v4();
                            let implementation_block = Item {
                                id,
                                subtype: ItemEnum::ImplementationBlock(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                source: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(implementation_block)
                        })() {
                            Ok(implementation_block) => {
                                let implementation_block =
                                    Arc::new(RwLock::new(implementation_block));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_item(implementation_block.clone());
                                let this = ItemProxy {
                                    inner: implementation_block.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: ITEM_ID.into(),
                                    id: implementation_block.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_import" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Item, Error> {
                            let id = Uuid::new_v4();
                            let import = Item {
                                id,
                                subtype: ItemEnum::Import(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                source: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(import)
                        })() {
                            Ok(import) => {
                                let import = Arc::new(RwLock::new(import));
                                self.store.write().unwrap().inter_item(import.clone());
                                let this = ItemProxy {
                                    inner: import.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: ITEM_ID.into(),
                                    id: import.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_x_macro" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Item, Error> {
                            let id = Uuid::new_v4();
                            let x_macro = Item {
                                id,
                                subtype: ItemEnum::XMacro(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                source: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(x_macro)
                        })() {
                            Ok(x_macro) => {
                                let x_macro = Arc::new(RwLock::new(x_macro));
                                self.store.write().unwrap().inter_item(x_macro.clone());
                                let this = ItemProxy {
                                    inner: x_macro.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: ITEM_ID.into(),
                                    id: x_macro.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_woog_struct" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Item, Error> {
                            let id = Uuid::new_v4();
                            let woog_struct = Item {
                                id,
                                subtype: ItemEnum::WoogStruct(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                source: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(woog_struct)
                        })() {
                            Ok(woog_struct) => {
                                let woog_struct = Arc::new(RwLock::new(woog_struct));
                                self.store.write().unwrap().inter_item(woog_struct.clone());
                                let this = ItemProxy {
                                    inner: woog_struct.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: ITEM_ID.into(),
                                    id: woog_struct.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for item in self.store.read().unwrap().iter_item() {
                            let this = ItemProxy {
                                inner: item.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: ITEM_ID.into(),
                                id: item.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Lambda" => match func {
                    "new" => {
                        if args.len() != 3 {
                            return Err(Error::Uber("Expected 3 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Lambda, Error> {
                            let id = Uuid::new_v4();
                            let lambda = Lambda {
                                id,
                                body: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                first_param: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                return_type: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(lambda)
                        })() {
                            Ok(lambda) => {
                                let lambda = Arc::new(RwLock::new(lambda));
                                self.store.write().unwrap().inter_lambda(lambda.clone());
                                let this = LambdaProxy {
                                    inner: lambda.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: LAMBDA_ID.into(),
                                    id: lambda.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for lambda in self.store.read().unwrap().iter_lambda() {
                            let this = LambdaProxy {
                                inner: lambda.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: LAMBDA_ID.into(),
                                id: lambda.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "LambdaParameter" => match func {
                    "new" => {
                        if args.len() != 4 {
                            return Err(Error::Uber("Expected 4 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<LambdaParameter, Error> {
                            let id = Uuid::new_v4();
                            let lambda_parameter = LambdaParameter {
                                id,
                                position: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                lambda: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                next: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                ty: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(lambda_parameter)
                        })() {
                            Ok(lambda_parameter) => {
                                let lambda_parameter = Arc::new(RwLock::new(lambda_parameter));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_lambda_parameter(lambda_parameter.clone());
                                let this = LambdaParameterProxy {
                                    inner: lambda_parameter.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: LAMBDA_PARAMETER_ID.into(),
                                    id: lambda_parameter.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for lambda_parameter in self.store.read().unwrap().iter_lambda_parameter() {
                            let this = LambdaParameterProxy {
                                inner: lambda_parameter.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: LAMBDA_PARAMETER_ID.into(),
                                id: lambda_parameter.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "LetStatement" => match func {
                    "new" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<LetStatement, Error> {
                            let id = Uuid::new_v4();
                            let let_statement = LetStatement {
                                id,
                                expression: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                variable: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(let_statement)
                        })() {
                            Ok(let_statement) => {
                                let let_statement = Arc::new(RwLock::new(let_statement));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_let_statement(let_statement.clone());
                                let this = LetStatementProxy {
                                    inner: let_statement.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: LET_STATEMENT_ID.into(),
                                    id: let_statement.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for let_statement in self.store.read().unwrap().iter_let_statement() {
                            let this = LetStatementProxy {
                                inner: let_statement.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: LET_STATEMENT_ID.into(),
                                id: let_statement.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "List" => match func {
                    "new" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<List, Error> {
                            let id = Uuid::new_v4();
                            let list = List {
                                id,
                                ty: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(list)
                        })() {
                            Ok(list) => {
                                let list = Arc::new(RwLock::new(list));
                                self.store.write().unwrap().inter_list(list.clone());
                                let this = ListProxy {
                                    inner: list.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: LIST_ID.into(),
                                    id: list.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for list in self.store.read().unwrap().iter_list() {
                            let this = ListProxy {
                                inner: list.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: LIST_ID.into(),
                                id: list.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "ListElement" => match func {
                    "new" => {
                        if args.len() != 3 {
                            return Err(Error::Uber("Expected 3 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<ListElement, Error> {
                            let id = Uuid::new_v4();
                            let list_element = ListElement {
                                id,
                                position: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                expression: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                next: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(list_element)
                        })() {
                            Ok(list_element) => {
                                let list_element = Arc::new(RwLock::new(list_element));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_list_element(list_element.clone());
                                let this = ListElementProxy {
                                    inner: list_element.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: LIST_ELEMENT_ID.into(),
                                    id: list_element.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for list_element in self.store.read().unwrap().iter_list_element() {
                            let this = ListElementProxy {
                                inner: list_element.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: LIST_ELEMENT_ID.into(),
                                id: list_element.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "ListExpression" => match func {
                    "new" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<ListExpression, Error> {
                            let id = Uuid::new_v4();
                            let list_expression = ListExpression {
                                id,
                                elements: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(list_expression)
                        })() {
                            Ok(list_expression) => {
                                let list_expression = Arc::new(RwLock::new(list_expression));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_list_expression(list_expression.clone());
                                let this = ListExpressionProxy {
                                    inner: list_expression.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: LIST_EXPRESSION_ID.into(),
                                    id: list_expression.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for list_expression in self.store.read().unwrap().iter_list_expression() {
                            let this = ListExpressionProxy {
                                inner: list_expression.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: LIST_EXPRESSION_ID.into(),
                                id: list_expression.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Literal" => match func {
                    "new_boolean_literal" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Literal, Error> {
                            let boolean_literal = Literal::BooleanLiteral(
                                value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            );

                            Ok(boolean_literal)
                        })() {
                            Ok(boolean_literal) => {
                                let boolean_literal = Arc::new(RwLock::new(boolean_literal));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_literal(boolean_literal.clone());
                                let this = LiteralProxy {
                                    inner: boolean_literal.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: LITERAL_ID.into(),
                                    id: boolean_literal.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_float_literal" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Literal, Error> {
                            let float_literal = Literal::FloatLiteral(
                                value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            );

                            Ok(float_literal)
                        })() {
                            Ok(float_literal) => {
                                let float_literal = Arc::new(RwLock::new(float_literal));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_literal(float_literal.clone());
                                let this = LiteralProxy {
                                    inner: float_literal.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: LITERAL_ID.into(),
                                    id: float_literal.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_integer_literal" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Literal, Error> {
                            let integer_literal = Literal::IntegerLiteral(
                                value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            );

                            Ok(integer_literal)
                        })() {
                            Ok(integer_literal) => {
                                let integer_literal = Arc::new(RwLock::new(integer_literal));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_literal(integer_literal.clone());
                                let this = LiteralProxy {
                                    inner: integer_literal.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: LITERAL_ID.into(),
                                    id: integer_literal.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_string_literal" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Literal, Error> {
                            let string_literal = Literal::StringLiteral(
                                value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            );

                            Ok(string_literal)
                        })() {
                            Ok(string_literal) => {
                                let string_literal = Arc::new(RwLock::new(string_literal));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_literal(string_literal.clone());
                                let this = LiteralProxy {
                                    inner: string_literal.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: LITERAL_ID.into(),
                                    id: string_literal.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for literal in self.store.read().unwrap().iter_literal() {
                            let this = LiteralProxy {
                                inner: literal.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: LITERAL_ID.into(),
                                id: literal.read().unwrap().id().into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "LocalVariable" => match func {
                    "new" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<LocalVariable, Error> {
                            let id = Uuid::new_v4();
                            let local_variable = LocalVariable {
                                id,
                                bug: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(local_variable)
                        })() {
                            Ok(local_variable) => {
                                let local_variable = Arc::new(RwLock::new(local_variable));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_local_variable(local_variable.clone());
                                let this = LocalVariableProxy {
                                    inner: local_variable.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: LOCAL_VARIABLE_ID.into(),
                                    id: local_variable.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for local_variable in self.store.read().unwrap().iter_local_variable() {
                            let this = LocalVariableProxy {
                                inner: local_variable.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: LOCAL_VARIABLE_ID.into(),
                                id: local_variable.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "XMacro" => match func {
                    "new" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<XMacro, Error> {
                            let id = Uuid::new_v4();
                            let x_macro = XMacro {
                                id,
                                name: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(x_macro)
                        })() {
                            Ok(x_macro) => {
                                let x_macro = Arc::new(RwLock::new(x_macro));
                                self.store.write().unwrap().inter_x_macro(x_macro.clone());
                                let this = XMacroProxy {
                                    inner: x_macro.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: X_MACRO_ID.into(),
                                    id: x_macro.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for x_macro in self.store.read().unwrap().iter_x_macro() {
                            let this = XMacroProxy {
                                inner: x_macro.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: X_MACRO_ID.into(),
                                id: x_macro.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "XMatch" => match func {
                    "new" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<XMatch, Error> {
                            let id = Uuid::new_v4();
                            let x_match = XMatch {
                                id,
                                uniqueness_generator: value_args
                                    .pop()
                                    .unwrap()
                                    .try_into()
                                    .map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                scrutinee: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(x_match)
                        })() {
                            Ok(x_match) => {
                                let x_match = Arc::new(RwLock::new(x_match));
                                self.store.write().unwrap().inter_x_match(x_match.clone());
                                let this = XMatchProxy {
                                    inner: x_match.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: X_MATCH_ID.into(),
                                    id: x_match.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for x_match in self.store.read().unwrap().iter_x_match() {
                            let this = XMatchProxy {
                                inner: x_match.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: X_MATCH_ID.into(),
                                id: x_match.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "MethodCall" => match func {
                    "new" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<MethodCall, Error> {
                            let id = Uuid::new_v4();
                            let method_call = MethodCall {
                                id,
                                name: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(method_call)
                        })() {
                            Ok(method_call) => {
                                let method_call = Arc::new(RwLock::new(method_call));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_method_call(method_call.clone());
                                let this = MethodCallProxy {
                                    inner: method_call.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: METHOD_CALL_ID.into(),
                                    id: method_call.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for method_call in self.store.read().unwrap().iter_method_call() {
                            let this = MethodCallProxy {
                                inner: method_call.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: METHOD_CALL_ID.into(),
                                id: method_call.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "NamedFieldExpression" => match func {
                    "new" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<NamedFieldExpression, Error> {
                            let id = Uuid::new_v4();
                            let named_field_expression = NamedFieldExpression {
                                id,
                                name: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(named_field_expression)
                        })() {
                            Ok(named_field_expression) => {
                                let named_field_expression =
                                    Arc::new(RwLock::new(named_field_expression));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_named_field_expression(named_field_expression.clone());
                                let this = NamedFieldExpressionProxy {
                                    inner: named_field_expression.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: NAMED_FIELD_EXPRESSION_ID.into(),
                                    id: named_field_expression.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for named_field_expression in
                            self.store.read().unwrap().iter_named_field_expression()
                        {
                            let this = NamedFieldExpressionProxy {
                                inner: named_field_expression.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: NAMED_FIELD_EXPRESSION_ID.into(),
                                id: named_field_expression.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "ZObjectStore" => match func {
                    "new" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<ZObjectStore, Error> {
                            let id = Uuid::new_v4();
                            let z_object_store = ZObjectStore {
                                id,
                                domain: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                name: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(z_object_store)
                        })() {
                            Ok(z_object_store) => {
                                let z_object_store = Arc::new(RwLock::new(z_object_store));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_z_object_store(z_object_store.clone());
                                let this = ZObjectStoreProxy {
                                    inner: z_object_store.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: Z_OBJECT_STORE_ID.into(),
                                    id: z_object_store.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for z_object_store in self.store.read().unwrap().iter_z_object_store() {
                            let this = ZObjectStoreProxy {
                                inner: z_object_store.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: Z_OBJECT_STORE_ID.into(),
                                id: z_object_store.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "ObjectWrapper" => match func {
                    "new" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<ObjectWrapper, Error> {
                            let id = Uuid::new_v4();
                            let object_wrapper = ObjectWrapper {
                                id,
                                object: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                z_store: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(object_wrapper)
                        })() {
                            Ok(object_wrapper) => {
                                let object_wrapper = Arc::new(RwLock::new(object_wrapper));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_object_wrapper(object_wrapper.clone());
                                let this = ObjectWrapperProxy {
                                    inner: object_wrapper.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: OBJECT_WRAPPER_ID.into(),
                                    id: object_wrapper.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for object_wrapper in self.store.read().unwrap().iter_object_wrapper() {
                            let this = ObjectWrapperProxy {
                                inner: object_wrapper.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: OBJECT_WRAPPER_ID.into(),
                                id: object_wrapper.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Operator" => match func {
                    "new_binary" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Operator, Error> {
                            let id = Uuid::new_v4();
                            let binary = Operator {
                                id,
                                subtype: OperatorEnum::Binary(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                lhs: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                rhs: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(binary)
                        })() {
                            Ok(binary) => {
                                let binary = Arc::new(RwLock::new(binary));
                                self.store.write().unwrap().inter_operator(binary.clone());
                                let this = OperatorProxy {
                                    inner: binary.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: OPERATOR_ID.into(),
                                    id: binary.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_comparison" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Operator, Error> {
                            let id = Uuid::new_v4();
                            let comparison = Operator {
                                id,
                                subtype: OperatorEnum::Comparison(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                lhs: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                rhs: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(comparison)
                        })() {
                            Ok(comparison) => {
                                let comparison = Arc::new(RwLock::new(comparison));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_operator(comparison.clone());
                                let this = OperatorProxy {
                                    inner: comparison.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: OPERATOR_ID.into(),
                                    id: comparison.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_unary" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Operator, Error> {
                            let id = Uuid::new_v4();
                            let unary = Operator {
                                id,
                                subtype: OperatorEnum::Unary(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                lhs: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                rhs: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(unary)
                        })() {
                            Ok(unary) => {
                                let unary = Arc::new(RwLock::new(unary));
                                self.store.write().unwrap().inter_operator(unary.clone());
                                let this = OperatorProxy {
                                    inner: unary.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: OPERATOR_ID.into(),
                                    id: unary.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for operator in self.store.read().unwrap().iter_operator() {
                            let this = OperatorProxy {
                                inner: operator.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: OPERATOR_ID.into(),
                                id: operator.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Parameter" => match func {
                    "new" => {
                        if args.len() != 4 {
                            return Err(Error::Uber("Expected 4 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Parameter, Error> {
                            let id = Uuid::new_v4();
                            let parameter = Parameter {
                                id,
                                position: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                function: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                next: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                ty: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(parameter)
                        })() {
                            Ok(parameter) => {
                                let parameter = Arc::new(RwLock::new(parameter));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_parameter(parameter.clone());
                                let this = ParameterProxy {
                                    inner: parameter.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: PARAMETER_ID.into(),
                                    id: parameter.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for parameter in self.store.read().unwrap().iter_parameter() {
                            let this = ParameterProxy {
                                inner: parameter.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: PARAMETER_ID.into(),
                                id: parameter.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "XPath" => match func {
                    "new" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<XPath, Error> {
                            let id = Uuid::new_v4();
                            let x_path = XPath {
                                id,
                                unique: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                first: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(x_path)
                        })() {
                            Ok(x_path) => {
                                let x_path = Arc::new(RwLock::new(x_path));
                                self.store.write().unwrap().inter_x_path(x_path.clone());
                                let this = XPathProxy {
                                    inner: x_path.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: X_PATH_ID.into(),
                                    id: x_path.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for x_path in self.store.read().unwrap().iter_x_path() {
                            let this = XPathProxy {
                                inner: x_path.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: X_PATH_ID.into(),
                                id: x_path.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "PathElement" => match func {
                    "new" => {
                        if args.len() != 3 {
                            return Err(Error::Uber("Expected 3 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<PathElement, Error> {
                            let id = Uuid::new_v4();
                            let path_element = PathElement {
                                id,
                                name: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                next: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                x_path: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(path_element)
                        })() {
                            Ok(path_element) => {
                                let path_element = Arc::new(RwLock::new(path_element));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_path_element(path_element.clone());
                                let this = PathElementProxy {
                                    inner: path_element.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: PATH_ELEMENT_ID.into(),
                                    id: path_element.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for path_element in self.store.read().unwrap().iter_path_element() {
                            let this = PathElementProxy {
                                inner: path_element.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: PATH_ELEMENT_ID.into(),
                                id: path_element.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Pattern" => match func {
                    "new" => {
                        if args.len() != 3 {
                            return Err(Error::Uber("Expected 3 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Pattern, Error> {
                            let id = Uuid::new_v4();
                            let pattern = Pattern {
                                id,
                                expression: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                match_expr: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                x_match: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(pattern)
                        })() {
                            Ok(pattern) => {
                                let pattern = Arc::new(RwLock::new(pattern));
                                self.store.write().unwrap().inter_pattern(pattern.clone());
                                let this = PatternProxy {
                                    inner: pattern.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: PATTERN_ID.into(),
                                    id: pattern.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for pattern in self.store.read().unwrap().iter_pattern() {
                            let this = PatternProxy {
                                inner: pattern.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: PATTERN_ID.into(),
                                id: pattern.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "XPlugin" => match func {
                    "new" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<XPlugin, Error> {
                            let id = Uuid::new_v4();
                            let x_plugin = XPlugin {
                                id,
                                name: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(x_plugin)
                        })() {
                            Ok(x_plugin) => {
                                let x_plugin = Arc::new(RwLock::new(x_plugin));
                                self.store.write().unwrap().inter_x_plugin(x_plugin.clone());
                                let this = XPluginProxy {
                                    inner: x_plugin.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: X_PLUGIN_ID.into(),
                                    id: x_plugin.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for x_plugin in self.store.read().unwrap().iter_x_plugin() {
                            let this = XPluginProxy {
                                inner: x_plugin.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: X_PLUGIN_ID.into(),
                                id: x_plugin.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "XPrint" => match func {
                    "new" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<XPrint, Error> {
                            let id = Uuid::new_v4();
                            let x_print = XPrint {
                                id,
                                expression: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(x_print)
                        })() {
                            Ok(x_print) => {
                                let x_print = Arc::new(RwLock::new(x_print));
                                self.store.write().unwrap().inter_x_print(x_print.clone());
                                let this = XPrintProxy {
                                    inner: x_print.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: X_PRINT_ID.into(),
                                    id: x_print.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for x_print in self.store.read().unwrap().iter_x_print() {
                            let this = XPrintProxy {
                                inner: x_print.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: X_PRINT_ID.into(),
                                id: x_print.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "RangeExpression" => match func {
                    "new_from" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<RangeExpression, Error> {
                            let id = Uuid::new_v4();
                            let from = RangeExpression {
                                id,
                                subtype: RangeExpressionEnum::From(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                lhs: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                rhs: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(from)
                        })() {
                            Ok(from) => {
                                let from = Arc::new(RwLock::new(from));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_range_expression(from.clone());
                                let this = RangeExpressionProxy {
                                    inner: from.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: RANGE_EXPRESSION_ID.into(),
                                    id: from.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_full" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<RangeExpression, Error> {
                            let id = Uuid::new_v4();
                            let full = RangeExpression {
                                id,
                                subtype: RangeExpressionEnum::Full(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                lhs: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                rhs: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(full)
                        })() {
                            Ok(full) => {
                                let full = Arc::new(RwLock::new(full));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_range_expression(full.clone());
                                let this = RangeExpressionProxy {
                                    inner: full.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: RANGE_EXPRESSION_ID.into(),
                                    id: full.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_inclusive" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<RangeExpression, Error> {
                            let id = Uuid::new_v4();
                            let inclusive = RangeExpression {
                                id,
                                subtype: RangeExpressionEnum::Inclusive(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                lhs: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                rhs: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(inclusive)
                        })() {
                            Ok(inclusive) => {
                                let inclusive = Arc::new(RwLock::new(inclusive));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_range_expression(inclusive.clone());
                                let this = RangeExpressionProxy {
                                    inner: inclusive.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: RANGE_EXPRESSION_ID.into(),
                                    id: inclusive.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_to" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<RangeExpression, Error> {
                            let id = Uuid::new_v4();
                            let to = RangeExpression {
                                id,
                                subtype: RangeExpressionEnum::To(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                lhs: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                rhs: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(to)
                        })() {
                            Ok(to) => {
                                let to = Arc::new(RwLock::new(to));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_range_expression(to.clone());
                                let this = RangeExpressionProxy {
                                    inner: to.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: RANGE_EXPRESSION_ID.into(),
                                    id: to.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_to_inclusive" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<RangeExpression, Error> {
                            let id = Uuid::new_v4();
                            let to_inclusive = RangeExpression {
                                id,
                                subtype: RangeExpressionEnum::ToInclusive(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                lhs: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                rhs: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(to_inclusive)
                        })() {
                            Ok(to_inclusive) => {
                                let to_inclusive = Arc::new(RwLock::new(to_inclusive));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_range_expression(to_inclusive.clone());
                                let this = RangeExpressionProxy {
                                    inner: to_inclusive.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: RANGE_EXPRESSION_ID.into(),
                                    id: to_inclusive.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for range_expression in self.store.read().unwrap().iter_range_expression() {
                            let this = RangeExpressionProxy {
                                inner: range_expression.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: RANGE_EXPRESSION_ID.into(),
                                id: range_expression.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "ResultStatement" => match func {
                    "new" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<ResultStatement, Error> {
                            let id = Uuid::new_v4();
                            let result_statement = ResultStatement {
                                id,
                                expression: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(result_statement)
                        })() {
                            Ok(result_statement) => {
                                let result_statement = Arc::new(RwLock::new(result_statement));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_result_statement(result_statement.clone());
                                let this = ResultStatementProxy {
                                    inner: result_statement.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: RESULT_STATEMENT_ID.into(),
                                    id: result_statement.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for result_statement in self.store.read().unwrap().iter_result_statement() {
                            let this = ResultStatementProxy {
                                inner: result_statement.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: RESULT_STATEMENT_ID.into(),
                                id: result_statement.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "XReturn" => match func {
                    "new" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<XReturn, Error> {
                            let id = Uuid::new_v4();
                            let x_return = XReturn {
                                id,
                                expression: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(x_return)
                        })() {
                            Ok(x_return) => {
                                let x_return = Arc::new(RwLock::new(x_return));
                                self.store.write().unwrap().inter_x_return(x_return.clone());
                                let this = XReturnProxy {
                                    inner: x_return.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: X_RETURN_ID.into(),
                                    id: x_return.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for x_return in self.store.read().unwrap().iter_x_return() {
                            let this = XReturnProxy {
                                inner: x_return.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: X_RETURN_ID.into(),
                                id: x_return.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Span" => match func {
                    "new" => {
                        if args.len() != 5 {
                            return Err(Error::Uber("Expected 5 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Span, Error> {
                            let id = Uuid::new_v4();
                            let span = Span {
                                id,
                                end: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                start: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                source: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                ty: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                x_value: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(span)
                        })() {
                            Ok(span) => {
                                let span = Arc::new(RwLock::new(span));
                                self.store.write().unwrap().inter_span(span.clone());
                                let this = SpanProxy {
                                    inner: span.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: SPAN_ID.into(),
                                    id: span.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for span in self.store.read().unwrap().iter_span() {
                            let this = SpanProxy {
                                inner: span.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: SPAN_ID.into(),
                                id: span.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Statement" => match func {
                    "new_expression_statement" => {
                        if args.len() != 3 {
                            return Err(Error::Uber("Expected 3 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Statement, Error> {
                            let id = Uuid::new_v4();
                            let expression_statement = Statement {
                                id,
                                subtype: StatementEnum::ExpressionStatement(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                index: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                block: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                next: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(expression_statement)
                        })() {
                            Ok(expression_statement) => {
                                let expression_statement =
                                    Arc::new(RwLock::new(expression_statement));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_statement(expression_statement.clone());
                                let this = StatementProxy {
                                    inner: expression_statement.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: STATEMENT_ID.into(),
                                    id: expression_statement.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_item_statement" => {
                        if args.len() != 3 {
                            return Err(Error::Uber("Expected 3 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Statement, Error> {
                            let id = Uuid::new_v4();
                            let item_statement = Statement {
                                id,
                                subtype: StatementEnum::ItemStatement(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                index: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                block: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                next: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(item_statement)
                        })() {
                            Ok(item_statement) => {
                                let item_statement = Arc::new(RwLock::new(item_statement));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_statement(item_statement.clone());
                                let this = StatementProxy {
                                    inner: item_statement.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: STATEMENT_ID.into(),
                                    id: item_statement.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_let_statement" => {
                        if args.len() != 3 {
                            return Err(Error::Uber("Expected 3 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Statement, Error> {
                            let id = Uuid::new_v4();
                            let let_statement = Statement {
                                id,
                                subtype: StatementEnum::LetStatement(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                index: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                block: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                next: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(let_statement)
                        })() {
                            Ok(let_statement) => {
                                let let_statement = Arc::new(RwLock::new(let_statement));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_statement(let_statement.clone());
                                let this = StatementProxy {
                                    inner: let_statement.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: STATEMENT_ID.into(),
                                    id: let_statement.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_result_statement" => {
                        if args.len() != 3 {
                            return Err(Error::Uber("Expected 3 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Statement, Error> {
                            let id = Uuid::new_v4();
                            let result_statement = Statement {
                                id,
                                subtype: StatementEnum::ResultStatement(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                index: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                block: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                next: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(result_statement)
                        })() {
                            Ok(result_statement) => {
                                let result_statement = Arc::new(RwLock::new(result_statement));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_statement(result_statement.clone());
                                let this = StatementProxy {
                                    inner: result_statement.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: STATEMENT_ID.into(),
                                    id: result_statement.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for statement in self.store.read().unwrap().iter_statement() {
                            let this = StatementProxy {
                                inner: statement.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: STATEMENT_ID.into(),
                                id: statement.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "StaticMethodCall" => match func {
                    "new" => {
                        if args.len() != 3 {
                            return Err(Error::Uber("Expected 3 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<StaticMethodCall, Error> {
                            let id = Uuid::new_v4();
                            let static_method_call = StaticMethodCall {
                                id,
                                func: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                ty: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                unique: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(static_method_call)
                        })() {
                            Ok(static_method_call) => {
                                let static_method_call = Arc::new(RwLock::new(static_method_call));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_static_method_call(static_method_call.clone());
                                let this = StaticMethodCallProxy {
                                    inner: static_method_call.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: STATIC_METHOD_CALL_ID.into(),
                                    id: static_method_call.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for static_method_call in
                            self.store.read().unwrap().iter_static_method_call()
                        {
                            let this = StaticMethodCallProxy {
                                inner: static_method_call.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: STATIC_METHOD_CALL_ID.into(),
                                id: static_method_call.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "StringLiteral" => match func {
                    "new" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<StringLiteral, Error> {
                            let id = Uuid::new_v4();
                            let string_literal = StringLiteral {
                                id,
                                x_value: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(string_literal)
                        })() {
                            Ok(string_literal) => {
                                let string_literal = Arc::new(RwLock::new(string_literal));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_string_literal(string_literal.clone());
                                let this = StringLiteralProxy {
                                    inner: string_literal.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: STRING_LITERAL_ID.into(),
                                    id: string_literal.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for string_literal in self.store.read().unwrap().iter_string_literal() {
                            let this = StringLiteralProxy {
                                inner: string_literal.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: STRING_LITERAL_ID.into(),
                                id: string_literal.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "WoogStruct" => match func {
                    "new" => {
                        if args.len() != 3 {
                            return Err(Error::Uber("Expected 3 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<WoogStruct, Error> {
                            let id = Uuid::new_v4();
                            let woog_struct = WoogStruct {
                                id,
                                name: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                first_generic: value_args.pop().unwrap().try_into().map_err(
                                    |e| Error::Uber(format!("Error converting value: {e}").into()),
                                )?,
                                object: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(woog_struct)
                        })() {
                            Ok(woog_struct) => {
                                let woog_struct = Arc::new(RwLock::new(woog_struct));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_woog_struct(woog_struct.clone());
                                let this = WoogStructProxy {
                                    inner: woog_struct.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: WOOG_STRUCT_ID.into(),
                                    id: woog_struct.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for woog_struct in self.store.read().unwrap().iter_woog_struct() {
                            let this = WoogStructProxy {
                                inner: woog_struct.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: WOOG_STRUCT_ID.into(),
                                id: woog_struct.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "StructExpression" => match func {
                    "new" => {
                        if args.len() != 3 {
                            return Err(Error::Uber("Expected 3 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<StructExpression, Error> {
                            let id = Uuid::new_v4();
                            let struct_expression = StructExpression {
                                id,
                                bug: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                data: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                x_path: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(struct_expression)
                        })() {
                            Ok(struct_expression) => {
                                let struct_expression = Arc::new(RwLock::new(struct_expression));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_struct_expression(struct_expression.clone());
                                let this = StructExpressionProxy {
                                    inner: struct_expression.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: STRUCT_EXPRESSION_ID.into(),
                                    id: struct_expression.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for struct_expression in self.store.read().unwrap().iter_struct_expression()
                        {
                            let this = StructExpressionProxy {
                                inner: struct_expression.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: STRUCT_EXPRESSION_ID.into(),
                                id: struct_expression.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "StructField" => match func {
                    "new" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<StructField, Error> {
                            let id = Uuid::new_v4();
                            let struct_field = StructField {
                                id,
                                name: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(struct_field)
                        })() {
                            Ok(struct_field) => {
                                let struct_field = Arc::new(RwLock::new(struct_field));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_struct_field(struct_field.clone());
                                let this = StructFieldProxy {
                                    inner: struct_field.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: STRUCT_FIELD_ID.into(),
                                    id: struct_field.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for struct_field in self.store.read().unwrap().iter_struct_field() {
                            let this = StructFieldProxy {
                                inner: struct_field.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: STRUCT_FIELD_ID.into(),
                                id: struct_field.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "StructGeneric" => match func {
                    "new" => {
                        if args.len() != 3 {
                            return Err(Error::Uber("Expected 3 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<StructGeneric, Error> {
                            let id = Uuid::new_v4();
                            let struct_generic = StructGeneric {
                                id,
                                name: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                next: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                woog_struct: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(struct_generic)
                        })() {
                            Ok(struct_generic) => {
                                let struct_generic = Arc::new(RwLock::new(struct_generic));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_struct_generic(struct_generic.clone());
                                let this = StructGenericProxy {
                                    inner: struct_generic.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: STRUCT_GENERIC_ID.into(),
                                    id: struct_generic.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for struct_generic in self.store.read().unwrap().iter_struct_generic() {
                            let this = StructGenericProxy {
                                inner: struct_generic.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: STRUCT_GENERIC_ID.into(),
                                id: struct_generic.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "TupleField" => match func {
                    "new" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<TupleField, Error> {
                            let id = Uuid::new_v4();
                            let tuple_field = TupleField {
                                id,
                                xyzzy: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                ty: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(tuple_field)
                        })() {
                            Ok(tuple_field) => {
                                let tuple_field = Arc::new(RwLock::new(tuple_field));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_tuple_field(tuple_field.clone());
                                let this = TupleFieldProxy {
                                    inner: tuple_field.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: TUPLE_FIELD_ID.into(),
                                    id: tuple_field.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for tuple_field in self.store.read().unwrap().iter_tuple_field() {
                            let this = TupleFieldProxy {
                                inner: tuple_field.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: TUPLE_FIELD_ID.into(),
                                id: tuple_field.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "TypeCast" => match func {
                    "new" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<TypeCast, Error> {
                            let id = Uuid::new_v4();
                            let type_cast = TypeCast {
                                id,
                                lhs: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                ty: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(type_cast)
                        })() {
                            Ok(type_cast) => {
                                let type_cast = Arc::new(RwLock::new(type_cast));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_type_cast(type_cast.clone());
                                let this = TypeCastProxy {
                                    inner: type_cast.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: TYPE_CAST_ID.into(),
                                    id: type_cast.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for type_cast in self.store.read().unwrap().iter_type_cast() {
                            let this = TypeCastProxy {
                                inner: type_cast.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: TYPE_CAST_ID.into(),
                                id: type_cast.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Unary" => match func {
                    "new_negation" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Arc<RwLock<Unary>>, Error> {
                            let negation =
                                self.store.read().unwrap().exhume_unary(&NEGATION).unwrap();

                            Ok(negation)
                        })() {
                            Ok(negation) => {
                                let this = UnaryProxy {
                                    inner: negation.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: NEGATION.into(),
                                    id: negation.read().unwrap().id().into(),
                                    plugin: plugin.clone(),
                                };
                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_not" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Arc<RwLock<Unary>>, Error> {
                            let not = self.store.read().unwrap().exhume_unary(&NOT).unwrap();

                            Ok(not)
                        })() {
                            Ok(not) => {
                                let this = UnaryProxy {
                                    inner: not.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: NOT.into(),
                                    id: not.read().unwrap().id().into(),
                                    plugin: plugin.clone(),
                                };
                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for unary in self.store.read().unwrap().iter_unary() {
                            let this = UnaryProxy {
                                inner: unary.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: UNARY_ID.into(),
                                id: unary.read().unwrap().id().into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Unit" => match func {
                    "new" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Unit, Error> {
                            let id = Uuid::new_v4();
                            let unit = Unit {
                                id,
                                x_value: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(unit)
                        })() {
                            Ok(unit) => {
                                let unit = Arc::new(RwLock::new(unit));
                                self.store.write().unwrap().inter_unit(unit.clone());
                                let this = UnitProxy {
                                    inner: unit.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: UNIT_ID.into(),
                                    id: unit.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for unit in self.store.read().unwrap().iter_unit() {
                            let this = UnitProxy {
                                inner: unit.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: UNIT_ID.into(),
                                id: unit.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "UnnamedFieldExpression" => match func {
                    "new" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<UnnamedFieldExpression, Error> {
                            let id = Uuid::new_v4();
                            let unnamed_field_expression = UnnamedFieldExpression {
                                id,
                                position: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(unnamed_field_expression)
                        })() {
                            Ok(unnamed_field_expression) => {
                                let unnamed_field_expression =
                                    Arc::new(RwLock::new(unnamed_field_expression));
                                self.store.write().unwrap().inter_unnamed_field_expression(
                                    unnamed_field_expression.clone(),
                                );
                                let this = UnnamedFieldExpressionProxy {
                                    inner: unnamed_field_expression.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: UNNAMED_FIELD_EXPRESSION_ID.into(),
                                    id: unnamed_field_expression.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for unnamed_field_expression in
                            self.store.read().unwrap().iter_unnamed_field_expression()
                        {
                            let this = UnnamedFieldExpressionProxy {
                                inner: unnamed_field_expression.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: UNNAMED_FIELD_EXPRESSION_ID.into(),
                                id: unnamed_field_expression.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "XValue" => match func {
                    "new_expression" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<XValue, Error> {
                            let id = Uuid::new_v4();
                            let expression = XValue {
                                id,
                                subtype: XValueEnum::Expression(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                block: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                ty: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(expression)
                        })() {
                            Ok(expression) => {
                                let expression = Arc::new(RwLock::new(expression));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_x_value(expression.clone());
                                let this = XValueProxy {
                                    inner: expression.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: X_VALUE_ID.into(),
                                    id: expression.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_variable" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<XValue, Error> {
                            let id = Uuid::new_v4();
                            let variable = XValue {
                                id,
                                subtype: XValueEnum::Variable(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                block: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                                ty: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(variable)
                        })() {
                            Ok(variable) => {
                                let variable = Arc::new(RwLock::new(variable));
                                self.store.write().unwrap().inter_x_value(variable.clone());
                                let this = XValueProxy {
                                    inner: variable.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: X_VALUE_ID.into(),
                                    id: variable.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for x_value in self.store.read().unwrap().iter_x_value() {
                            let this = XValueProxy {
                                inner: x_value.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: X_VALUE_ID.into(),
                                id: x_value.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "ValueType" => match func {
                    "new_char" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Arc<RwLock<ValueType>>, Error> {
                            let char = self.store.read().unwrap().exhume_value_type(&CHAR).unwrap();

                            Ok(char)
                        })() {
                            Ok(char) => {
                                let this = ValueTypeProxy {
                                    inner: char.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: CHAR.into(),
                                    id: char.read().unwrap().id().into(),
                                    plugin: plugin.clone(),
                                };
                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_empty" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Arc<RwLock<ValueType>>, Error> {
                            let empty = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_value_type(&EMPTY)
                                .unwrap();

                            Ok(empty)
                        })() {
                            Ok(empty) => {
                                let this = ValueTypeProxy {
                                    inner: empty.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: EMPTY.into(),
                                    id: empty.read().unwrap().id().into(),
                                    plugin: plugin.clone(),
                                };
                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_enumeration" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<ValueType, Error> {
                            let enumeration = ValueType::Enumeration(
                                value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            );

                            Ok(enumeration)
                        })() {
                            Ok(enumeration) => {
                                let enumeration = Arc::new(RwLock::new(enumeration));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_value_type(enumeration.clone());
                                let this = ValueTypeProxy {
                                    inner: enumeration.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: VALUE_TYPE_ID.into(),
                                    id: enumeration.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_function" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<ValueType, Error> {
                            let function =
                                ValueType::Function(value_args.pop().unwrap().try_into().map_err(
                                    |e| Error::Uber(format!("Error converting value: {e}").into()),
                                )?);

                            Ok(function)
                        })() {
                            Ok(function) => {
                                let function = Arc::new(RwLock::new(function));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_value_type(function.clone());
                                let this = ValueTypeProxy {
                                    inner: function.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: VALUE_TYPE_ID.into(),
                                    id: function.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_x_future" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<ValueType, Error> {
                            let x_future =
                                ValueType::XFuture(value_args.pop().unwrap().try_into().map_err(
                                    |e| Error::Uber(format!("Error converting value: {e}").into()),
                                )?);

                            Ok(x_future)
                        })() {
                            Ok(x_future) => {
                                let x_future = Arc::new(RwLock::new(x_future));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_value_type(x_future.clone());
                                let this = ValueTypeProxy {
                                    inner: x_future.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: VALUE_TYPE_ID.into(),
                                    id: x_future.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_generic" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<ValueType, Error> {
                            let generic =
                                ValueType::Generic(value_args.pop().unwrap().try_into().map_err(
                                    |e| Error::Uber(format!("Error converting value: {e}").into()),
                                )?);

                            Ok(generic)
                        })() {
                            Ok(generic) => {
                                let generic = Arc::new(RwLock::new(generic));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_value_type(generic.clone());
                                let this = ValueTypeProxy {
                                    inner: generic.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: VALUE_TYPE_ID.into(),
                                    id: generic.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_import" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<ValueType, Error> {
                            let import =
                                ValueType::Import(value_args.pop().unwrap().try_into().map_err(
                                    |e| Error::Uber(format!("Error converting value: {e}").into()),
                                )?);

                            Ok(import)
                        })() {
                            Ok(import) => {
                                let import = Arc::new(RwLock::new(import));
                                self.store.write().unwrap().inter_value_type(import.clone());
                                let this = ValueTypeProxy {
                                    inner: import.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: VALUE_TYPE_ID.into(),
                                    id: import.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_lambda" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<ValueType, Error> {
                            let lambda =
                                ValueType::Lambda(value_args.pop().unwrap().try_into().map_err(
                                    |e| Error::Uber(format!("Error converting value: {e}").into()),
                                )?);

                            Ok(lambda)
                        })() {
                            Ok(lambda) => {
                                let lambda = Arc::new(RwLock::new(lambda));
                                self.store.write().unwrap().inter_value_type(lambda.clone());
                                let this = ValueTypeProxy {
                                    inner: lambda.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: VALUE_TYPE_ID.into(),
                                    id: lambda.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_list" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<ValueType, Error> {
                            let list =
                                ValueType::List(value_args.pop().unwrap().try_into().map_err(
                                    |e| Error::Uber(format!("Error converting value: {e}").into()),
                                )?);

                            Ok(list)
                        })() {
                            Ok(list) => {
                                let list = Arc::new(RwLock::new(list));
                                self.store.write().unwrap().inter_value_type(list.clone());
                                let this = ValueTypeProxy {
                                    inner: list.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: VALUE_TYPE_ID.into(),
                                    id: list.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_z_object_store" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<ValueType, Error> {
                            let z_object_store = ValueType::ZObjectStore(
                                value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            );

                            Ok(z_object_store)
                        })() {
                            Ok(z_object_store) => {
                                let z_object_store = Arc::new(RwLock::new(z_object_store));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_value_type(z_object_store.clone());
                                let this = ValueTypeProxy {
                                    inner: z_object_store.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: VALUE_TYPE_ID.into(),
                                    id: z_object_store.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_x_plugin" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<ValueType, Error> {
                            let x_plugin =
                                ValueType::XPlugin(value_args.pop().unwrap().try_into().map_err(
                                    |e| Error::Uber(format!("Error converting value: {e}").into()),
                                )?);

                            Ok(x_plugin)
                        })() {
                            Ok(x_plugin) => {
                                let x_plugin = Arc::new(RwLock::new(x_plugin));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_value_type(x_plugin.clone());
                                let this = ValueTypeProxy {
                                    inner: x_plugin.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: VALUE_TYPE_ID.into(),
                                    id: x_plugin.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_range" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Arc<RwLock<ValueType>>, Error> {
                            let range = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_value_type(&RANGE)
                                .unwrap();

                            Ok(range)
                        })() {
                            Ok(range) => {
                                let this = ValueTypeProxy {
                                    inner: range.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: RANGE.into(),
                                    id: range.read().unwrap().id().into(),
                                    plugin: plugin.clone(),
                                };
                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_woog_struct" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<ValueType, Error> {
                            let woog_struct = ValueType::WoogStruct(
                                value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            );

                            Ok(woog_struct)
                        })() {
                            Ok(woog_struct) => {
                                let woog_struct = Arc::new(RwLock::new(woog_struct));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_value_type(woog_struct.clone());
                                let this = ValueTypeProxy {
                                    inner: woog_struct.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: VALUE_TYPE_ID.into(),
                                    id: woog_struct.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_task" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Arc<RwLock<ValueType>>, Error> {
                            let task = self.store.read().unwrap().exhume_value_type(&TASK).unwrap();

                            Ok(task)
                        })() {
                            Ok(task) => {
                                let this = ValueTypeProxy {
                                    inner: task.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: TASK.into(),
                                    id: task.read().unwrap().id().into(),
                                    plugin: plugin.clone(),
                                };
                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_ty" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<ValueType, Error> {
                            let ty = ValueType::Ty(value_args.pop().unwrap().try_into().map_err(
                                |e| Error::Uber(format!("Error converting value: {e}").into()),
                            )?);

                            Ok(ty)
                        })() {
                            Ok(ty) => {
                                let ty = Arc::new(RwLock::new(ty));
                                self.store.write().unwrap().inter_value_type(ty.clone());
                                let this = ValueTypeProxy {
                                    inner: ty.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: VALUE_TYPE_ID.into(),
                                    id: ty.read().unwrap().id().into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_unknown" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Arc<RwLock<ValueType>>, Error> {
                            let unknown = self
                                .store
                                .read()
                                .unwrap()
                                .exhume_value_type(&UNKNOWN)
                                .unwrap();

                            Ok(unknown)
                        })() {
                            Ok(unknown) => {
                                let this = ValueTypeProxy {
                                    inner: unknown.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: UNKNOWN.into(),
                                    id: unknown.read().unwrap().id().into(),
                                    plugin: plugin.clone(),
                                };
                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for value_type in self.store.read().unwrap().iter_value_type() {
                            let this = ValueTypeProxy {
                                inner: value_type.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: VALUE_TYPE_ID.into(),
                                id: value_type.read().unwrap().id().into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "Variable" => match func {
                    "new_lambda_parameter" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Variable, Error> {
                            let id = Uuid::new_v4();
                            let lambda_parameter = Variable {
                                id,
                                subtype: VariableEnum::LambdaParameter(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                name: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(lambda_parameter)
                        })() {
                            Ok(lambda_parameter) => {
                                let lambda_parameter = Arc::new(RwLock::new(lambda_parameter));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_variable(lambda_parameter.clone());
                                let this = VariableProxy {
                                    inner: lambda_parameter.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: VARIABLE_ID.into(),
                                    id: lambda_parameter.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_local_variable" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Variable, Error> {
                            let id = Uuid::new_v4();
                            let local_variable = Variable {
                                id,
                                subtype: VariableEnum::LocalVariable(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                name: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(local_variable)
                        })() {
                            Ok(local_variable) => {
                                let local_variable = Arc::new(RwLock::new(local_variable));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_variable(local_variable.clone());
                                let this = VariableProxy {
                                    inner: local_variable.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: VARIABLE_ID.into(),
                                    id: local_variable.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "new_parameter" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<Variable, Error> {
                            let id = Uuid::new_v4();
                            let parameter = Variable {
                                id,
                                subtype: VariableEnum::Parameter(
                                    value_args.pop().unwrap().try_into().map_err(|e| {
                                        Error::Uber(format!("Error converting value: {e}").into())
                                    })?,
                                ),
                                name: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(parameter)
                        })() {
                            Ok(parameter) => {
                                let parameter = Arc::new(RwLock::new(parameter));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_variable(parameter.clone());
                                let this = VariableProxy {
                                    inner: parameter.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: VARIABLE_ID.into(),
                                    id: parameter.read().unwrap().id.into(), // d
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for variable in self.store.read().unwrap().iter_variable() {
                            let this = VariableProxy {
                                inner: variable.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: VARIABLE_ID.into(),
                                id: variable.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                "VariableExpression" => match func {
                    "new" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 arguments".into()));
                        }
                        let mut value_args: Vec<Value> = Vec::new();
                        args.reverse();
                        for arg in args.into_iter() {
                            value_args.push(arg.into());
                        }
                        match (|| -> Result<VariableExpression, Error> {
                            let id = Uuid::new_v4();
                            let variable_expression = VariableExpression {
                                id,
                                name: value_args.pop().unwrap().try_into().map_err(|e| {
                                    Error::Uber(format!("Error converting value: {e}").into())
                                })?,
                            };

                            Ok(variable_expression)
                        })() {
                            Ok(variable_expression) => {
                                let variable_expression =
                                    Arc::new(RwLock::new(variable_expression));
                                self.store
                                    .write()
                                    .unwrap()
                                    .inter_variable_expression(variable_expression.clone());
                                let this = VariableExpressionProxy {
                                    inner: variable_expression.clone(),
                                    store: self.store.clone(),
                                };
                                let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                let proxy = FfiProxy {
                                    module: module.into(),
                                    uuid: VARIABLE_EXPRESSION_ID.into(),
                                    id: variable_expression.read().unwrap().id.into(), // e
                                    plugin: plugin.clone(),
                                };

                                Ok(FfiValue::ProxyType(proxy))
                            }
                            Err(e) => Err(e),
                        }
                    }
                    "instances" => {
                        let mut instances = Vec::new();
                        for variable_expression in
                            self.store.read().unwrap().iter_variable_expression()
                        {
                            let this = VariableExpressionProxy {
                                inner: variable_expression.clone(),
                                store: self.store.clone(),
                            };
                            let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                            let proxy = FfiProxy {
                                module: module.into(),
                                uuid: VARIABLE_EXPRESSION_ID.into(),
                                id: variable_expression.read().unwrap().id.into(), // b
                                plugin: plugin.clone(),
                            };

                            instances.push(FfiValue::ProxyType(proxy));
                        }
                        Ok(FfiValue::Vector(instances.into()))
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },

                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "merlin".into()
    }

    fn close(self) {}
}

const ADDITION_ID: Uuid = uuid!("1b4e5b3a-a9b2-4316-94c4-ff34d4d3d523");

#[derive(Clone, Debug)]
pub struct AdditionProxy {
    inner: Arc<RwLock<Addition>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for AdditionProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Addition".into()
    }

    fn close(self) {}
}

impl Display for AdditionProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Addition({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const AND_ID: Uuid = uuid!("6187076b-e765-4e6b-af28-f577eba40b5e");

#[derive(Clone, Debug)]
pub struct AndProxy {
    inner: Arc<RwLock<And>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for AndProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "And".into()
    }

    fn close(self) {}
}

impl Display for AndProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "And({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const ARGUMENT_ID: Uuid = uuid!("846aa191-7b0c-4325-8c21-09fa5edf7c78");

#[derive(Clone, Debug)]
pub struct ArgumentProxy {
    inner: Arc<RwLock<Argument>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for ArgumentProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "position" => Ok(FfiValue::Integer(
                                    self.inner.read().unwrap().position.into(),
                                )),
                                "expression" => {
                                    let expression = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_expression(&self.inner.read().unwrap().expression)
                                        .unwrap();

                                    let this = ExpressionProxy {
                                        inner: expression,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: EXPRESSION_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                "function" => {
                                    let function = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_call(&self.inner.read().unwrap().function)
                                        .unwrap();

                                    let this = CallProxy {
                                        inner: function,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: CALL_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                "next" => match self.inner.read().unwrap().next {
                                    Some(next) => Ok(FfiValue::Option(ROption::RSome(RBox::new(
                                        FfiValue::Uuid(next.into()),
                                    )))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "position" => {
                                    self.inner.write().unwrap().position =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "expression" => {
                                    self.inner.write().unwrap().expression =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "function" => {
                                    self.inner.write().unwrap().function =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "next" => {
                                    self.inner.write().unwrap().next =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Argument".into()
    }

    fn close(self) {}
}

impl Display for ArgumentProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Argument({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	position: {:?},", self.inner.read().unwrap().position)?;
        writeln!(
            f,
            "	expression: {:?},",
            self.inner.read().unwrap().expression
        )?;
        writeln!(f, "	function: {:?},", self.inner.read().unwrap().function)?;
        writeln!(f, "	next: {:?},", self.inner.read().unwrap().next)?;
        writeln!(f, "}})")
    }
}

const ASSIGNMENT_ID: Uuid = uuid!("c47b8696-7e98-4733-ab33-a4dca7b61d01");

#[derive(Clone, Debug)]
pub struct AssignmentProxy {
    inner: Arc<RwLock<Assignment>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for AssignmentProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Assignment".into()
    }

    fn close(self) {}
}

impl Display for AssignmentProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Assignment({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const A_WAIT_ID: Uuid = uuid!("4856978f-20be-4b59-8bf6-b941091119a9");

#[derive(Clone, Debug)]
pub struct AWaitProxy {
    inner: Arc<RwLock<AWait>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for AWaitProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "x_future" => {
                                    let x_future = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_expression(&self.inner.read().unwrap().x_future)
                                        .unwrap();

                                    let this = ExpressionProxy {
                                        inner: x_future,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: EXPRESSION_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "x_future" => {
                                    self.inner.write().unwrap().x_future =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "AWait".into()
    }

    fn close(self) {}
}

impl Display for AWaitProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "AWait({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	x_future: {:?},", self.inner.read().unwrap().x_future)?;
        writeln!(f, "}})")
    }
}

const BINARY_ID: Uuid = uuid!("9c8bc563-b596-4348-9189-065d747f7c9f");

#[derive(Clone, Debug)]
pub struct BinaryProxy {
    inner: Arc<RwLock<Binary>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for BinaryProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Binary".into()
    }

    fn close(self) {}
}

impl Display for BinaryProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Binary({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const BLOCK_ID: Uuid = uuid!("30c31621-a4bd-4356-80b9-1226e00651c9");

#[derive(Clone, Debug)]
pub struct BlockProxy {
    inner: Arc<RwLock<Block>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for BlockProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "a_sink" => {
                                    Ok(FfiValue::Boolean(self.inner.read().unwrap().a_sink.into()))
                                }
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "parent" => match self.inner.read().unwrap().parent {
                                    Some(parent) => Ok(FfiValue::Option(ROption::RSome(
                                        RBox::new(FfiValue::Uuid(parent.into())),
                                    ))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                "statement" => match self.inner.read().unwrap().statement {
                                    Some(statement) => Ok(FfiValue::Option(ROption::RSome(
                                        RBox::new(FfiValue::Uuid(statement.into())),
                                    ))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "a_sink" => {
                                    self.inner.write().unwrap().a_sink =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "parent" => {
                                    self.inner.write().unwrap().parent =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "statement" => {
                                    self.inner.write().unwrap().statement =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Block".into()
    }

    fn close(self) {}
}

impl Display for BlockProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Block({{")?;
        writeln!(f, "	a_sink: {:?},", self.inner.read().unwrap().a_sink)?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	parent: {:?},", self.inner.read().unwrap().parent)?;
        writeln!(f, "	statement: {:?},", self.inner.read().unwrap().statement)?;
        writeln!(f, "}})")
    }
}

const BODY_ID: Uuid = uuid!("c4723d6d-1584-49bd-80f1-4c700185746e");

#[derive(Clone, Debug)]
pub struct BodyProxy {
    inner: Arc<RwLock<Body>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for BodyProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "a_sink" => {
                                    Ok(FfiValue::Boolean(self.inner.read().unwrap().a_sink.into()))
                                }
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "a_sink" => {
                                    self.inner.write().unwrap().a_sink =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Body".into()
    }

    fn close(self) {}
}

impl Display for BodyProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Body({{")?;
        writeln!(f, "	a_sink: {:?},", self.inner.read().unwrap().a_sink)?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "}})")
    }
}

const BOOLEAN_LITERAL_ID: Uuid = uuid!("d86aef6f-0a91-4f3e-81cb-b220dbe7c7b5");

#[derive(Clone, Debug)]
pub struct BooleanLiteralProxy {
    inner: Arc<RwLock<BooleanLiteral>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for BooleanLiteralProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "BooleanLiteral".into()
    }

    fn close(self) {}
}

impl Display for BooleanLiteralProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "BooleanLiteral({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const BOOLEAN_OPERATOR_ID: Uuid = uuid!("222307c0-668c-43f9-9368-34cc048f0ae3");

#[derive(Clone, Debug)]
pub struct BooleanOperatorProxy {
    inner: Arc<RwLock<BooleanOperator>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for BooleanOperatorProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "BooleanOperator".into()
    }

    fn close(self) {}
}

impl Display for BooleanOperatorProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "BooleanOperator({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const CALL_ID: Uuid = uuid!("26dba2c5-a7e9-4556-a9c2-79091a97b941");

#[derive(Clone, Debug)]
pub struct CallProxy {
    inner: Arc<RwLock<Call>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for CallProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "arg_check" => Ok(FfiValue::Boolean(
                                    self.inner.read().unwrap().arg_check.into(),
                                )),
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "argument" => match self.inner.read().unwrap().argument {
                                    Some(argument) => Ok(FfiValue::Option(ROption::RSome(
                                        RBox::new(FfiValue::Uuid(argument.into())),
                                    ))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                "expression" => match self.inner.read().unwrap().expression {
                                    Some(expression) => Ok(FfiValue::Option(ROption::RSome(
                                        RBox::new(FfiValue::Uuid(expression.into())),
                                    ))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "arg_check" => {
                                    self.inner.write().unwrap().arg_check =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "argument" => {
                                    self.inner.write().unwrap().argument =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "expression" => {
                                    self.inner.write().unwrap().expression =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Call".into()
    }

    fn close(self) {}
}

impl Display for CallProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Call({{")?;
        writeln!(f, "	arg_check: {:?},", self.inner.read().unwrap().arg_check)?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	argument: {:?},", self.inner.read().unwrap().argument)?;
        writeln!(
            f,
            "	expression: {:?},",
            self.inner.read().unwrap().expression
        )?;
        writeln!(f, "}})")
    }
}

const CHAR_ID: Uuid = uuid!("efde0481-1599-4c5c-bf30-51dbd4a8ed83");

#[derive(Clone, Debug)]
pub struct CharProxy {
    inner: Arc<RwLock<Char>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for CharProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Char".into()
    }

    fn close(self) {}
}

impl Display for CharProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Char({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const COMPARISON_ID: Uuid = uuid!("c46e6b80-0365-429a-abf9-ca75ce4f469a");

#[derive(Clone, Debug)]
pub struct ComparisonProxy {
    inner: Arc<RwLock<Comparison>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for ComparisonProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Comparison".into()
    }

    fn close(self) {}
}

impl Display for ComparisonProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Comparison({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const DATA_STRUCTURE_ID: Uuid = uuid!("31deb355-b737-43a6-ae88-199bb51f940d");

#[derive(Clone, Debug)]
pub struct DataStructureProxy {
    inner: Arc<RwLock<DataStructure>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for DataStructureProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "DataStructure".into()
    }

    fn close(self) {}
}

impl Display for DataStructureProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "DataStructure({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const DEBUGGER_ID: Uuid = uuid!("5c85a8db-e4cc-4e38-9922-58d93773f4f0");

#[derive(Clone, Debug)]
pub struct DebuggerProxy {
    inner: Arc<RwLock<Debugger>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for DebuggerProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Debugger".into()
    }

    fn close(self) {}
}

impl Display for DebuggerProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Debugger({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const DIVISION_ID: Uuid = uuid!("35b3de4e-46b8-490f-8e30-c305ed348a78");

#[derive(Clone, Debug)]
pub struct DivisionProxy {
    inner: Arc<RwLock<Division>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for DivisionProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Division".into()
    }

    fn close(self) {}
}

impl Display for DivisionProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Division({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const DWARF_SOURCE_FILE_ID: Uuid = uuid!("97f815f0-dcc4-4bd3-843d-13ff1dc5802c");

#[derive(Clone, Debug)]
pub struct DwarfSourceFileProxy {
    inner: Arc<RwLock<DwarfSourceFile>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for DwarfSourceFileProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "source" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().source.clone().into(),
                                )),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "source" => {
                                    self.inner.write().unwrap().source =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "DwarfSourceFile".into()
    }

    fn close(self) {}
}

impl Display for DwarfSourceFileProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "DwarfSourceFile({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	source: {:?},", self.inner.read().unwrap().source)?;
        writeln!(f, "}})")
    }
}

const EMPTY_ID: Uuid = uuid!("a8b86e41-5b04-4469-8a10-91bd89603e27");

#[derive(Clone, Debug)]
pub struct EmptyProxy {
    inner: Arc<RwLock<Empty>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for EmptyProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Empty".into()
    }

    fn close(self) {}
}

impl Display for EmptyProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Empty({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const EMPTY_EXPRESSION_ID: Uuid = uuid!("43bebcb3-06a1-410d-a19e-b3c1c6d1fa6b");

#[derive(Clone, Debug)]
pub struct EmptyExpressionProxy {
    inner: Arc<RwLock<EmptyExpression>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for EmptyExpressionProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "EmptyExpression".into()
    }

    fn close(self) {}
}

impl Display for EmptyExpressionProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "EmptyExpression({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const ENUM_FIELD_ID: Uuid = uuid!("7eaea922-8807-4c38-a704-0143e0594664");

#[derive(Clone, Debug)]
pub struct EnumFieldProxy {
    inner: Arc<RwLock<EnumField>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for EnumFieldProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "name" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().name.clone().into(),
                                )),
                                "woog_enum" => {
                                    let woog_enum = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_enumeration(&self.inner.read().unwrap().woog_enum)
                                        .unwrap();

                                    let this = EnumerationProxy {
                                        inner: woog_enum,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: ENUMERATION_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "name" => {
                                    self.inner.write().unwrap().name =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "woog_enum" => {
                                    self.inner.write().unwrap().woog_enum =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "EnumField".into()
    }

    fn close(self) {}
}

impl Display for EnumFieldProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "EnumField({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	name: {:?},", self.inner.read().unwrap().name)?;
        writeln!(f, "	woog_enum: {:?},", self.inner.read().unwrap().woog_enum)?;
        writeln!(f, "}})")
    }
}

const ENUMERATION_ID: Uuid = uuid!("d48d948b-5291-4eb3-ba35-7ab1c1ffa098");

#[derive(Clone, Debug)]
pub struct EnumerationProxy {
    inner: Arc<RwLock<Enumeration>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for EnumerationProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "name" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().name.clone().into(),
                                )),
                                "implementation" => match self.inner.read().unwrap().implementation
                                {
                                    Some(implementation) => Ok(FfiValue::Option(ROption::RSome(
                                        RBox::new(FfiValue::Uuid(implementation.into())),
                                    ))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "name" => {
                                    self.inner.write().unwrap().name =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "implementation" => {
                                    self.inner.write().unwrap().implementation =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Enumeration".into()
    }

    fn close(self) {}
}

impl Display for EnumerationProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Enumeration({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	name: {:?},", self.inner.read().unwrap().name)?;
        writeln!(
            f,
            "	implementation: {:?},",
            self.inner.read().unwrap().implementation
        )?;
        writeln!(f, "}})")
    }
}

const EQUAL_ID: Uuid = uuid!("0edc535b-405d-4dd5-bcd2-f5772ab116c2");

#[derive(Clone, Debug)]
pub struct EqualProxy {
    inner: Arc<RwLock<Equal>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for EqualProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Equal".into()
    }

    fn close(self) {}
}

impl Display for EqualProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Equal({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const EXPRESSION_ID: Uuid = uuid!("9352c766-9f6b-413b-9ea0-13f9c8e4d86e");

#[derive(Clone, Debug)]
pub struct ExpressionProxy {
    inner: Arc<RwLock<Expression>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for ExpressionProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Expression".into()
    }

    fn close(self) {}
}

impl Display for ExpressionProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Expression({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const EXPRESSION_STATEMENT_ID: Uuid = uuid!("59f269ab-2dbc-4b07-b9bc-48441f20e78f");

#[derive(Clone, Debug)]
pub struct ExpressionStatementProxy {
    inner: Arc<RwLock<ExpressionStatement>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for ExpressionStatementProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "expression" => {
                                    let expression = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_expression(&self.inner.read().unwrap().expression)
                                        .unwrap();

                                    let this = ExpressionProxy {
                                        inner: expression,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: EXPRESSION_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "expression" => {
                                    self.inner.write().unwrap().expression =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "ExpressionStatement".into()
    }

    fn close(self) {}
}

impl Display for ExpressionStatementProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "ExpressionStatement({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(
            f,
            "	expression: {:?},",
            self.inner.read().unwrap().expression
        )?;
        writeln!(f, "}})")
    }
}

const EXTERNAL_IMPLEMENTATION_ID: Uuid = uuid!("7794ada6-49c3-4bf0-991f-828c6583ebb8");

#[derive(Clone, Debug)]
pub struct ExternalImplementationProxy {
    inner: Arc<RwLock<ExternalImplementation>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for ExternalImplementationProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "function" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().function.clone().into(),
                                )),
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "x_model" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().x_model.clone().into(),
                                )),
                                "object" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().object.clone().into(),
                                )),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "function" => {
                                    self.inner.write().unwrap().function =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "x_model" => {
                                    self.inner.write().unwrap().x_model =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "object" => {
                                    self.inner.write().unwrap().object =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "ExternalImplementation".into()
    }

    fn close(self) {}
}

impl Display for ExternalImplementationProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "ExternalImplementation({{")?;
        writeln!(f, "	function: {:?},", self.inner.read().unwrap().function)?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	x_model: {:?},", self.inner.read().unwrap().x_model)?;
        writeln!(f, "	object: {:?},", self.inner.read().unwrap().object)?;
        writeln!(f, "}})")
    }
}

const FALSE_LITERAL_ID: Uuid = uuid!("a16027c2-9a1d-42b7-ab37-a4e8e0bb7e4d");

#[derive(Clone, Debug)]
pub struct FalseLiteralProxy {
    inner: Arc<RwLock<FalseLiteral>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for FalseLiteralProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "FalseLiteral".into()
    }

    fn close(self) {}
}

impl Display for FalseLiteralProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FalseLiteral({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const FIELD_ID: Uuid = uuid!("141350e6-b62d-4a6d-9ea2-47333e51e3ea");

#[derive(Clone, Debug)]
pub struct FieldProxy {
    inner: Arc<RwLock<Field>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for FieldProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "name" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().name.clone().into(),
                                )),
                                "x_model" => {
                                    let x_model = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_woog_struct(&self.inner.read().unwrap().x_model)
                                        .unwrap();

                                    let this = WoogStructProxy {
                                        inner: x_model,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: WOOG_STRUCT_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                "ty" => {
                                    let ty = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_value_type(&self.inner.read().unwrap().ty)
                                        .unwrap();

                                    let this = ValueTypeProxy {
                                        inner: ty,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: VALUE_TYPE_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "name" => {
                                    self.inner.write().unwrap().name =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "x_model" => {
                                    self.inner.write().unwrap().x_model =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "ty" => {
                                    self.inner.write().unwrap().ty =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Field".into()
    }

    fn close(self) {}
}

impl Display for FieldProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Field({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	name: {:?},", self.inner.read().unwrap().name)?;
        writeln!(f, "	x_model: {:?},", self.inner.read().unwrap().x_model)?;
        writeln!(f, "	ty: {:?},", self.inner.read().unwrap().ty)?;
        writeln!(f, "}})")
    }
}

const FIELD_ACCESS_ID: Uuid = uuid!("1ae9bff3-fb8a-4b35-bd3f-7120691cc7e7");

#[derive(Clone, Debug)]
pub struct FieldAccessProxy {
    inner: Arc<RwLock<FieldAccess>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for FieldAccessProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "expression" => {
                                    let expression = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_expression(&self.inner.read().unwrap().expression)
                                        .unwrap();

                                    let this = ExpressionProxy {
                                        inner: expression,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: EXPRESSION_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                "field" => {
                                    let field = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_field_access_target(
                                            &self.inner.read().unwrap().field,
                                        )
                                        .unwrap();

                                    let this = FieldAccessTargetProxy {
                                        inner: field,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: FIELD_ACCESS_TARGET_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                "woog_struct" => {
                                    let woog_struct = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_woog_struct(&self.inner.read().unwrap().woog_struct)
                                        .unwrap();

                                    let this = WoogStructProxy {
                                        inner: woog_struct,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: WOOG_STRUCT_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "expression" => {
                                    self.inner.write().unwrap().expression =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "field" => {
                                    self.inner.write().unwrap().field =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "woog_struct" => {
                                    self.inner.write().unwrap().woog_struct =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "FieldAccess".into()
    }

    fn close(self) {}
}

impl Display for FieldAccessProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FieldAccess({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(
            f,
            "	expression: {:?},",
            self.inner.read().unwrap().expression
        )?;
        writeln!(f, "	field: {:?},", self.inner.read().unwrap().field)?;
        writeln!(
            f,
            "	woog_struct: {:?},",
            self.inner.read().unwrap().woog_struct
        )?;
        writeln!(f, "}})")
    }
}

const FIELD_ACCESS_TARGET_ID: Uuid = uuid!("bf69c9af-f268-4c9b-8e67-4497eb490478");

#[derive(Clone, Debug)]
pub struct FieldAccessTargetProxy {
    inner: Arc<RwLock<FieldAccessTarget>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for FieldAccessTargetProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "FieldAccessTarget".into()
    }

    fn close(self) {}
}

impl Display for FieldAccessTargetProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FieldAccessTarget({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const FIELD_EXPRESSION_ID: Uuid = uuid!("3874760d-0104-4670-ba8b-1af413c5ec4a");

#[derive(Clone, Debug)]
pub struct FieldExpressionProxy {
    inner: Arc<RwLock<FieldExpression>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for FieldExpressionProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "expression" => {
                                    let expression = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_expression(&self.inner.read().unwrap().expression)
                                        .unwrap();

                                    let this = ExpressionProxy {
                                        inner: expression,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: EXPRESSION_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                "woog_struct" => {
                                    let woog_struct = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_struct_expression(
                                            &self.inner.read().unwrap().woog_struct,
                                        )
                                        .unwrap();

                                    let this = StructExpressionProxy {
                                        inner: woog_struct,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: STRUCT_EXPRESSION_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "expression" => {
                                    self.inner.write().unwrap().expression =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "woog_struct" => {
                                    self.inner.write().unwrap().woog_struct =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "FieldExpression".into()
    }

    fn close(self) {}
}

impl Display for FieldExpressionProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FieldExpression({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(
            f,
            "	expression: {:?},",
            self.inner.read().unwrap().expression
        )?;
        writeln!(
            f,
            "	woog_struct: {:?},",
            self.inner.read().unwrap().woog_struct
        )?;
        writeln!(f, "}})")
    }
}

const FLOAT_LITERAL_ID: Uuid = uuid!("fa42f4e2-1ff3-473f-a4b9-593c01134e96");

#[derive(Clone, Debug)]
pub struct FloatLiteralProxy {
    inner: Arc<RwLock<FloatLiteral>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for FloatLiteralProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "x_value" => {
                                    Ok(FfiValue::Float(self.inner.read().unwrap().x_value.into()))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "x_value" => {
                                    self.inner.write().unwrap().x_value =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "FloatLiteral".into()
    }

    fn close(self) {}
}

impl Display for FloatLiteralProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FloatLiteral({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	x_value: {:?},", self.inner.read().unwrap().x_value)?;
        writeln!(f, "}})")
    }
}

const FOR_LOOP_ID: Uuid = uuid!("72443b79-5645-4b5f-b317-e1a8f815b81c");

#[derive(Clone, Debug)]
pub struct ForLoopProxy {
    inner: Arc<RwLock<ForLoop>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for ForLoopProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "ident" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().ident.clone().into(),
                                )),
                                "block" => {
                                    let block = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_block(&self.inner.read().unwrap().block)
                                        .unwrap();

                                    let this = BlockProxy {
                                        inner: block,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: BLOCK_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                "expression" => {
                                    let expression = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_expression(&self.inner.read().unwrap().expression)
                                        .unwrap();

                                    let this = ExpressionProxy {
                                        inner: expression,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: EXPRESSION_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "ident" => {
                                    self.inner.write().unwrap().ident =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "block" => {
                                    self.inner.write().unwrap().block =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "expression" => {
                                    self.inner.write().unwrap().expression =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "ForLoop".into()
    }

    fn close(self) {}
}

impl Display for ForLoopProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "ForLoop({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	ident: {:?},", self.inner.read().unwrap().ident)?;
        writeln!(f, "	block: {:?},", self.inner.read().unwrap().block)?;
        writeln!(
            f,
            "	expression: {:?},",
            self.inner.read().unwrap().expression
        )?;
        writeln!(f, "}})")
    }
}

const FROM_ID: Uuid = uuid!("70932b40-f444-4341-bb19-0a29d1daecbe");

#[derive(Clone, Debug)]
pub struct FromProxy {
    inner: Arc<RwLock<From>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for FromProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "From".into()
    }

    fn close(self) {}
}

impl Display for FromProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "From({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const FULL_ID: Uuid = uuid!("122e4157-381f-400f-ac30-a1c8a2a9e8c1");

#[derive(Clone, Debug)]
pub struct FullProxy {
    inner: Arc<RwLock<Full>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for FullProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Full".into()
    }

    fn close(self) {}
}

impl Display for FullProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Full({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const FUNCTION_ID: Uuid = uuid!("d8dbc4ff-77d0-470c-a8c9-5c700376fdd5");

#[derive(Clone, Debug)]
pub struct FunctionProxy {
    inner: Arc<RwLock<Function>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for FunctionProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "name" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().name.clone().into(),
                                )),
                                "body" => {
                                    let body = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_body(&self.inner.read().unwrap().body)
                                        .unwrap();

                                    let this = BodyProxy {
                                        inner: body,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: BODY_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                "first_param" => match self.inner.read().unwrap().first_param {
                                    Some(first_param) => Ok(FfiValue::Option(ROption::RSome(
                                        RBox::new(FfiValue::Uuid(first_param.into())),
                                    ))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                "impl_block" => match self.inner.read().unwrap().impl_block {
                                    Some(impl_block) => Ok(FfiValue::Option(ROption::RSome(
                                        RBox::new(FfiValue::Uuid(impl_block.into())),
                                    ))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                "return_type" => {
                                    let return_type = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_value_type(&self.inner.read().unwrap().return_type)
                                        .unwrap();

                                    let this = ValueTypeProxy {
                                        inner: return_type,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: VALUE_TYPE_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "name" => {
                                    self.inner.write().unwrap().name =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "body" => {
                                    self.inner.write().unwrap().body =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "first_param" => {
                                    self.inner.write().unwrap().first_param =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "impl_block" => {
                                    self.inner.write().unwrap().impl_block =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "return_type" => {
                                    self.inner.write().unwrap().return_type =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Function".into()
    }

    fn close(self) {}
}

impl Display for FunctionProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Function({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	name: {:?},", self.inner.read().unwrap().name)?;
        writeln!(f, "	body: {:?},", self.inner.read().unwrap().body)?;
        writeln!(
            f,
            "	first_param: {:?},",
            self.inner.read().unwrap().first_param
        )?;
        writeln!(
            f,
            "	impl_block: {:?},",
            self.inner.read().unwrap().impl_block
        )?;
        writeln!(
            f,
            "	return_type: {:?},",
            self.inner.read().unwrap().return_type
        )?;
        writeln!(f, "}})")
    }
}

const FUNCTION_CALL_ID: Uuid = uuid!("79069fc2-4d65-4073-b610-4afc0488de5c");

#[derive(Clone, Debug)]
pub struct FunctionCallProxy {
    inner: Arc<RwLock<FunctionCall>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for FunctionCallProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "FunctionCall".into()
    }

    fn close(self) {}
}

impl Display for FunctionCallProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "FunctionCall({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const X_FUTURE_ID: Uuid = uuid!("dbada891-ca0d-4fbc-8371-9f9234867bd6");

#[derive(Clone, Debug)]
pub struct XFutureProxy {
    inner: Arc<RwLock<XFuture>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for XFutureProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "x_value" => {
                                    let x_value = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_value_type(&self.inner.read().unwrap().x_value)
                                        .unwrap();

                                    let this = ValueTypeProxy {
                                        inner: x_value,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: VALUE_TYPE_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "x_value" => {
                                    self.inner.write().unwrap().x_value =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "XFuture".into()
    }

    fn close(self) {}
}

impl Display for XFutureProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "XFuture({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	x_value: {:?},", self.inner.read().unwrap().x_value)?;
        writeln!(f, "}})")
    }
}

const GENERIC_ID: Uuid = uuid!("968ea4f4-0a3b-44d4-a266-16facf7d325f");

#[derive(Clone, Debug)]
pub struct GenericProxy {
    inner: Arc<RwLock<Generic>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for GenericProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "name" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().name.clone().into(),
                                )),
                                "next" => match self.inner.read().unwrap().next {
                                    Some(next) => Ok(FfiValue::Option(ROption::RSome(RBox::new(
                                        FfiValue::Uuid(next.into()),
                                    )))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                "ty" => match self.inner.read().unwrap().ty {
                                    Some(ty) => Ok(FfiValue::Option(ROption::RSome(RBox::new(
                                        FfiValue::Uuid(ty.into()),
                                    )))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "name" => {
                                    self.inner.write().unwrap().name =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "next" => {
                                    self.inner.write().unwrap().next =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "ty" => {
                                    self.inner.write().unwrap().ty =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Generic".into()
    }

    fn close(self) {}
}

impl Display for GenericProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Generic({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	name: {:?},", self.inner.read().unwrap().name)?;
        writeln!(f, "	next: {:?},", self.inner.read().unwrap().next)?;
        writeln!(f, "	ty: {:?},", self.inner.read().unwrap().ty)?;
        writeln!(f, "}})")
    }
}

const GREATER_THAN_ID: Uuid = uuid!("ce73a111-4670-411e-9bd2-f3308d6399c9");

#[derive(Clone, Debug)]
pub struct GreaterThanProxy {
    inner: Arc<RwLock<GreaterThan>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for GreaterThanProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "GreaterThan".into()
    }

    fn close(self) {}
}

impl Display for GreaterThanProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "GreaterThan({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const GREATER_THAN_OR_EQUAL_ID: Uuid = uuid!("d8b554d4-03ac-4613-a3e0-fc0b901bfd70");

#[derive(Clone, Debug)]
pub struct GreaterThanOrEqualProxy {
    inner: Arc<RwLock<GreaterThanOrEqual>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for GreaterThanOrEqualProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "GreaterThanOrEqual".into()
    }

    fn close(self) {}
}

impl Display for GreaterThanOrEqualProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "GreaterThanOrEqual({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const GROUPED_ID: Uuid = uuid!("0dc0e921-e7ff-4766-9738-e6e312f7f0de");

#[derive(Clone, Debug)]
pub struct GroupedProxy {
    inner: Arc<RwLock<Grouped>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for GroupedProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "expression" => {
                                    let expression = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_expression(&self.inner.read().unwrap().expression)
                                        .unwrap();

                                    let this = ExpressionProxy {
                                        inner: expression,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: EXPRESSION_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "expression" => {
                                    self.inner.write().unwrap().expression =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Grouped".into()
    }

    fn close(self) {}
}

impl Display for GroupedProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Grouped({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(
            f,
            "	expression: {:?},",
            self.inner.read().unwrap().expression
        )?;
        writeln!(f, "}})")
    }
}

const X_IF_ID: Uuid = uuid!("e1321ffa-07d5-480d-89f9-227b13d27ce1");

#[derive(Clone, Debug)]
pub struct XIfProxy {
    inner: Arc<RwLock<XIf>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for XIfProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "false_block" => match self.inner.read().unwrap().false_block {
                                    Some(false_block) => Ok(FfiValue::Option(ROption::RSome(
                                        RBox::new(FfiValue::Uuid(false_block.into())),
                                    ))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                "test" => {
                                    let test = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_expression(&self.inner.read().unwrap().test)
                                        .unwrap();

                                    let this = ExpressionProxy {
                                        inner: test,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: EXPRESSION_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                "true_block" => {
                                    let true_block = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_block(&self.inner.read().unwrap().true_block)
                                        .unwrap();

                                    let this = BlockProxy {
                                        inner: true_block,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: BLOCK_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "false_block" => {
                                    self.inner.write().unwrap().false_block =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "test" => {
                                    self.inner.write().unwrap().test =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "true_block" => {
                                    self.inner.write().unwrap().true_block =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "XIf".into()
    }

    fn close(self) {}
}

impl Display for XIfProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "XIf({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(
            f,
            "	false_block: {:?},",
            self.inner.read().unwrap().false_block
        )?;
        writeln!(f, "	test: {:?},", self.inner.read().unwrap().test)?;
        writeln!(
            f,
            "	true_block: {:?},",
            self.inner.read().unwrap().true_block
        )?;
        writeln!(f, "}})")
    }
}

const IMPLEMENTATION_BLOCK_ID: Uuid = uuid!("88687f76-5d9e-404e-a801-f6f57f9b30ca");

#[derive(Clone, Debug)]
pub struct ImplementationBlockProxy {
    inner: Arc<RwLock<ImplementationBlock>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for ImplementationBlockProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "model_type" => match self.inner.read().unwrap().model_type {
                                    Some(model_type) => Ok(FfiValue::Option(ROption::RSome(
                                        RBox::new(FfiValue::Uuid(model_type.into())),
                                    ))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                "object_store" => match self.inner.read().unwrap().object_store {
                                    Some(object_store) => Ok(FfiValue::Option(ROption::RSome(
                                        RBox::new(FfiValue::Uuid(object_store.into())),
                                    ))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "model_type" => {
                                    self.inner.write().unwrap().model_type =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "object_store" => {
                                    self.inner.write().unwrap().object_store =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "ImplementationBlock".into()
    }

    fn close(self) {}
}

impl Display for ImplementationBlockProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "ImplementationBlock({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(
            f,
            "	model_type: {:?},",
            self.inner.read().unwrap().model_type
        )?;
        writeln!(
            f,
            "	object_store: {:?},",
            self.inner.read().unwrap().object_store
        )?;
        writeln!(f, "}})")
    }
}

const IMPORT_ID: Uuid = uuid!("c89e362d-7905-4226-8713-97d3d6f05037");

#[derive(Clone, Debug)]
pub struct ImportProxy {
    inner: Arc<RwLock<Import>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for ImportProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "alias" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().alias.clone().into(),
                                )),
                                "has_alias" => Ok(FfiValue::Boolean(
                                    self.inner.read().unwrap().has_alias.into(),
                                )),
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "name" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().name.clone().into(),
                                )),
                                "x_path" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().x_path.clone().into(),
                                )),
                                "object" => match self.inner.read().unwrap().object {
                                    Some(object) => Ok(FfiValue::Option(ROption::RSome(
                                        RBox::new(FfiValue::Uuid(object.into())),
                                    ))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "alias" => {
                                    self.inner.write().unwrap().alias =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "has_alias" => {
                                    self.inner.write().unwrap().has_alias =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "name" => {
                                    self.inner.write().unwrap().name =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "x_path" => {
                                    self.inner.write().unwrap().x_path =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "object" => {
                                    self.inner.write().unwrap().object =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Import".into()
    }

    fn close(self) {}
}

impl Display for ImportProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Import({{")?;
        writeln!(f, "	alias: {:?},", self.inner.read().unwrap().alias)?;
        writeln!(f, "	has_alias: {:?},", self.inner.read().unwrap().has_alias)?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	name: {:?},", self.inner.read().unwrap().name)?;
        writeln!(f, "	x_path: {:?},", self.inner.read().unwrap().x_path)?;
        writeln!(f, "	object: {:?},", self.inner.read().unwrap().object)?;
        writeln!(f, "}})")
    }
}

const INCLUSIVE_ID: Uuid = uuid!("17db2afc-ae6c-4e53-a527-48516811fe3e");

#[derive(Clone, Debug)]
pub struct InclusiveProxy {
    inner: Arc<RwLock<Inclusive>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for InclusiveProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Inclusive".into()
    }

    fn close(self) {}
}

impl Display for InclusiveProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Inclusive({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const INDEX_ID: Uuid = uuid!("4d5720eb-da8c-493d-ab8d-cb6111dd6099");

#[derive(Clone, Debug)]
pub struct IndexProxy {
    inner: Arc<RwLock<Index>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for IndexProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "index" => {
                                    let index = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_expression(&self.inner.read().unwrap().index)
                                        .unwrap();

                                    let this = ExpressionProxy {
                                        inner: index,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: EXPRESSION_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                "target" => {
                                    let target = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_expression(&self.inner.read().unwrap().target)
                                        .unwrap();

                                    let this = ExpressionProxy {
                                        inner: target,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: EXPRESSION_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "index" => {
                                    self.inner.write().unwrap().index =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "target" => {
                                    self.inner.write().unwrap().target =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Index".into()
    }

    fn close(self) {}
}

impl Display for IndexProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Index({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	index: {:?},", self.inner.read().unwrap().index)?;
        writeln!(f, "	target: {:?},", self.inner.read().unwrap().target)?;
        writeln!(f, "}})")
    }
}

const INTEGER_LITERAL_ID: Uuid = uuid!("b1612607-a813-4bc2-896b-88ec4b249447");

#[derive(Clone, Debug)]
pub struct IntegerLiteralProxy {
    inner: Arc<RwLock<IntegerLiteral>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for IntegerLiteralProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "x_value" => {
                                    Ok(FfiValue::Integer(self.inner.read().unwrap().x_value.into()))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "x_value" => {
                                    self.inner.write().unwrap().x_value =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "IntegerLiteral".into()
    }

    fn close(self) {}
}

impl Display for IntegerLiteralProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "IntegerLiteral({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	x_value: {:?},", self.inner.read().unwrap().x_value)?;
        writeln!(f, "}})")
    }
}

const ITEM_ID: Uuid = uuid!("45644594-b418-5362-9294-a62fe2a0fa8e");

#[derive(Clone, Debug)]
pub struct ItemProxy {
    inner: Arc<RwLock<Item>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for ItemProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "source" => {
                                    let source = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_dwarf_source_file(
                                            &self.inner.read().unwrap().source,
                                        )
                                        .unwrap();

                                    let this = DwarfSourceFileProxy {
                                        inner: source,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: DWARF_SOURCE_FILE_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "source" => {
                                    self.inner.write().unwrap().source =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Item".into()
    }

    fn close(self) {}
}

impl Display for ItemProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Item({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	source: {:?},", self.inner.read().unwrap().source)?;
        writeln!(f, "}})")
    }
}

const ITEM_STATEMENT_ID: Uuid = uuid!("ce2da156-e0fd-4e56-bb31-2030d4e0c599");

#[derive(Clone, Debug)]
pub struct ItemStatementProxy {
    inner: Arc<RwLock<ItemStatement>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for ItemStatementProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "ItemStatement".into()
    }

    fn close(self) {}
}

impl Display for ItemStatementProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "ItemStatement({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const LAMBDA_ID: Uuid = uuid!("95e17479-07a5-41b1-9930-1b9b520514f6");

#[derive(Clone, Debug)]
pub struct LambdaProxy {
    inner: Arc<RwLock<Lambda>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for LambdaProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "body" => match self.inner.read().unwrap().body {
                                    Some(body) => Ok(FfiValue::Option(ROption::RSome(RBox::new(
                                        FfiValue::Uuid(body.into()),
                                    )))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                "first_param" => match self.inner.read().unwrap().first_param {
                                    Some(first_param) => Ok(FfiValue::Option(ROption::RSome(
                                        RBox::new(FfiValue::Uuid(first_param.into())),
                                    ))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                "return_type" => {
                                    let return_type = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_value_type(&self.inner.read().unwrap().return_type)
                                        .unwrap();

                                    let this = ValueTypeProxy {
                                        inner: return_type,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: VALUE_TYPE_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "body" => {
                                    self.inner.write().unwrap().body =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "first_param" => {
                                    self.inner.write().unwrap().first_param =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "return_type" => {
                                    self.inner.write().unwrap().return_type =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Lambda".into()
    }

    fn close(self) {}
}

impl Display for LambdaProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Lambda({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	body: {:?},", self.inner.read().unwrap().body)?;
        writeln!(
            f,
            "	first_param: {:?},",
            self.inner.read().unwrap().first_param
        )?;
        writeln!(
            f,
            "	return_type: {:?},",
            self.inner.read().unwrap().return_type
        )?;
        writeln!(f, "}})")
    }
}

const LAMBDA_PARAMETER_ID: Uuid = uuid!("8d86dceb-7e6e-4767-8a3f-cbbde458ad93");

#[derive(Clone, Debug)]
pub struct LambdaParameterProxy {
    inner: Arc<RwLock<LambdaParameter>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for LambdaParameterProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "position" => Ok(FfiValue::Integer(
                                    self.inner.read().unwrap().position.into(),
                                )),
                                "lambda" => {
                                    let lambda = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_lambda(&self.inner.read().unwrap().lambda)
                                        .unwrap();

                                    let this = LambdaProxy {
                                        inner: lambda,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: LAMBDA_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                "next" => match self.inner.read().unwrap().next {
                                    Some(next) => Ok(FfiValue::Option(ROption::RSome(RBox::new(
                                        FfiValue::Uuid(next.into()),
                                    )))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                "ty" => match self.inner.read().unwrap().ty {
                                    Some(ty) => Ok(FfiValue::Option(ROption::RSome(RBox::new(
                                        FfiValue::Uuid(ty.into()),
                                    )))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "position" => {
                                    self.inner.write().unwrap().position =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "lambda" => {
                                    self.inner.write().unwrap().lambda =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "next" => {
                                    self.inner.write().unwrap().next =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "ty" => {
                                    self.inner.write().unwrap().ty =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "LambdaParameter".into()
    }

    fn close(self) {}
}

impl Display for LambdaParameterProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "LambdaParameter({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	position: {:?},", self.inner.read().unwrap().position)?;
        writeln!(f, "	lambda: {:?},", self.inner.read().unwrap().lambda)?;
        writeln!(f, "	next: {:?},", self.inner.read().unwrap().next)?;
        writeln!(f, "	ty: {:?},", self.inner.read().unwrap().ty)?;
        writeln!(f, "}})")
    }
}

const LESS_THAN_ID: Uuid = uuid!("84f1c5fd-d907-4653-a132-bfd420ad9212");

#[derive(Clone, Debug)]
pub struct LessThanProxy {
    inner: Arc<RwLock<LessThan>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for LessThanProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "LessThan".into()
    }

    fn close(self) {}
}

impl Display for LessThanProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "LessThan({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const LESS_THAN_OR_EQUAL_ID: Uuid = uuid!("484e429b-bf54-45cb-9b87-baddf7fb5f5b");

#[derive(Clone, Debug)]
pub struct LessThanOrEqualProxy {
    inner: Arc<RwLock<LessThanOrEqual>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for LessThanOrEqualProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "LessThanOrEqual".into()
    }

    fn close(self) {}
}

impl Display for LessThanOrEqualProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "LessThanOrEqual({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const LET_STATEMENT_ID: Uuid = uuid!("c32fcb6d-b505-492f-95c8-5f118079a399");

#[derive(Clone, Debug)]
pub struct LetStatementProxy {
    inner: Arc<RwLock<LetStatement>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for LetStatementProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "expression" => {
                                    let expression = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_expression(&self.inner.read().unwrap().expression)
                                        .unwrap();

                                    let this = ExpressionProxy {
                                        inner: expression,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: EXPRESSION_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                "variable" => {
                                    let variable = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_local_variable(&self.inner.read().unwrap().variable)
                                        .unwrap();

                                    let this = LocalVariableProxy {
                                        inner: variable,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: LOCAL_VARIABLE_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "expression" => {
                                    self.inner.write().unwrap().expression =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "variable" => {
                                    self.inner.write().unwrap().variable =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "LetStatement".into()
    }

    fn close(self) {}
}

impl Display for LetStatementProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "LetStatement({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(
            f,
            "	expression: {:?},",
            self.inner.read().unwrap().expression
        )?;
        writeln!(f, "	variable: {:?},", self.inner.read().unwrap().variable)?;
        writeln!(f, "}})")
    }
}

const LIST_ID: Uuid = uuid!("cdb1afaf-245c-4d56-bfea-10f69e45007d");

#[derive(Clone, Debug)]
pub struct ListProxy {
    inner: Arc<RwLock<List>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for ListProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "ty" => {
                                    let ty = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_value_type(&self.inner.read().unwrap().ty)
                                        .unwrap();

                                    let this = ValueTypeProxy {
                                        inner: ty,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: VALUE_TYPE_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "ty" => {
                                    self.inner.write().unwrap().ty =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "List".into()
    }

    fn close(self) {}
}

impl Display for ListProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "List({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	ty: {:?},", self.inner.read().unwrap().ty)?;
        writeln!(f, "}})")
    }
}

const LIST_ELEMENT_ID: Uuid = uuid!("ef4fe655-79cc-4eda-ac4e-d3ed30bd189d");

#[derive(Clone, Debug)]
pub struct ListElementProxy {
    inner: Arc<RwLock<ListElement>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for ListElementProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "position" => Ok(FfiValue::Integer(
                                    self.inner.read().unwrap().position.into(),
                                )),
                                "expression" => {
                                    let expression = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_expression(&self.inner.read().unwrap().expression)
                                        .unwrap();

                                    let this = ExpressionProxy {
                                        inner: expression,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: EXPRESSION_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                "next" => match self.inner.read().unwrap().next {
                                    Some(next) => Ok(FfiValue::Option(ROption::RSome(RBox::new(
                                        FfiValue::Uuid(next.into()),
                                    )))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "position" => {
                                    self.inner.write().unwrap().position =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "expression" => {
                                    self.inner.write().unwrap().expression =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "next" => {
                                    self.inner.write().unwrap().next =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "ListElement".into()
    }

    fn close(self) {}
}

impl Display for ListElementProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "ListElement({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	position: {:?},", self.inner.read().unwrap().position)?;
        writeln!(
            f,
            "	expression: {:?},",
            self.inner.read().unwrap().expression
        )?;
        writeln!(f, "	next: {:?},", self.inner.read().unwrap().next)?;
        writeln!(f, "}})")
    }
}

const LIST_EXPRESSION_ID: Uuid = uuid!("e05ab5f3-17e7-4594-8ce0-c02d793a1df9");

#[derive(Clone, Debug)]
pub struct ListExpressionProxy {
    inner: Arc<RwLock<ListExpression>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for ListExpressionProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "elements" => match self.inner.read().unwrap().elements {
                                    Some(elements) => Ok(FfiValue::Option(ROption::RSome(
                                        RBox::new(FfiValue::Uuid(elements.into())),
                                    ))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "elements" => {
                                    self.inner.write().unwrap().elements =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "ListExpression".into()
    }

    fn close(self) {}
}

impl Display for ListExpressionProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "ListExpression({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	elements: {:?},", self.inner.read().unwrap().elements)?;
        writeln!(f, "}})")
    }
}

const LITERAL_ID: Uuid = uuid!("dbbb7d46-4072-49a6-b483-cc8b25cbb4ea");

#[derive(Clone, Debug)]
pub struct LiteralProxy {
    inner: Arc<RwLock<Literal>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for LiteralProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Literal".into()
    }

    fn close(self) {}
}

impl Display for LiteralProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Literal({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const LOCAL_VARIABLE_ID: Uuid = uuid!("0365b40c-c40a-4653-84ab-44d1c12d294f");

#[derive(Clone, Debug)]
pub struct LocalVariableProxy {
    inner: Arc<RwLock<LocalVariable>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for LocalVariableProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "bug" => Ok(FfiValue::Uuid(self.inner.read().unwrap().bug.into())),
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "bug" => {
                                    self.inner.write().unwrap().bug =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "LocalVariable".into()
    }

    fn close(self) {}
}

impl Display for LocalVariableProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "LocalVariable({{")?;
        writeln!(f, "	bug: {:?},", self.inner.read().unwrap().bug)?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "}})")
    }
}

const X_MACRO_ID: Uuid = uuid!("f6a3ce12-18e1-4675-ab94-6b2a7c91d951");

#[derive(Clone, Debug)]
pub struct XMacroProxy {
    inner: Arc<RwLock<XMacro>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for XMacroProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "name" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().name.clone().into(),
                                )),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "name" => {
                                    self.inner.write().unwrap().name =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "XMacro".into()
    }

    fn close(self) {}
}

impl Display for XMacroProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "XMacro({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	name: {:?},", self.inner.read().unwrap().name)?;
        writeln!(f, "}})")
    }
}

const MACRO_CALL_ID: Uuid = uuid!("470246f6-91ec-4993-b915-93480d0f4eb9");

#[derive(Clone, Debug)]
pub struct MacroCallProxy {
    inner: Arc<RwLock<MacroCall>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for MacroCallProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "MacroCall".into()
    }

    fn close(self) {}
}

impl Display for MacroCallProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "MacroCall({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const X_MATCH_ID: Uuid = uuid!("52143d28-8474-44bc-b63f-e654150888d3");

#[derive(Clone, Debug)]
pub struct XMatchProxy {
    inner: Arc<RwLock<XMatch>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for XMatchProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "uniqueness_generator" => Ok(FfiValue::Uuid(
                                    self.inner.read().unwrap().uniqueness_generator.into(),
                                )),
                                "scrutinee" => {
                                    let scrutinee = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_expression(&self.inner.read().unwrap().scrutinee)
                                        .unwrap();

                                    let this = ExpressionProxy {
                                        inner: scrutinee,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: EXPRESSION_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "uniqueness_generator" => {
                                    self.inner.write().unwrap().uniqueness_generator =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "scrutinee" => {
                                    self.inner.write().unwrap().scrutinee =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "XMatch".into()
    }

    fn close(self) {}
}

impl Display for XMatchProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "XMatch({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(
            f,
            "	uniqueness_generator: {:?},",
            self.inner.read().unwrap().uniqueness_generator
        )?;
        writeln!(f, "	scrutinee: {:?},", self.inner.read().unwrap().scrutinee)?;
        writeln!(f, "}})")
    }
}

const METHOD_CALL_ID: Uuid = uuid!("75a16785-d611-45ce-b52c-284a9da0b4b8");

#[derive(Clone, Debug)]
pub struct MethodCallProxy {
    inner: Arc<RwLock<MethodCall>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for MethodCallProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "name" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().name.clone().into(),
                                )),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "name" => {
                                    self.inner.write().unwrap().name =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "MethodCall".into()
    }

    fn close(self) {}
}

impl Display for MethodCallProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "MethodCall({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	name: {:?},", self.inner.read().unwrap().name)?;
        writeln!(f, "}})")
    }
}

const MULTIPLICATION_ID: Uuid = uuid!("6767c0cf-4041-4047-b2b4-d7375f33bc97");

#[derive(Clone, Debug)]
pub struct MultiplicationProxy {
    inner: Arc<RwLock<Multiplication>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for MultiplicationProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Multiplication".into()
    }

    fn close(self) {}
}

impl Display for MultiplicationProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Multiplication({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const NAMED_FIELD_EXPRESSION_ID: Uuid = uuid!("6822b78e-e5ca-4c40-ba9d-cf7a69d4fdc7");

#[derive(Clone, Debug)]
pub struct NamedFieldExpressionProxy {
    inner: Arc<RwLock<NamedFieldExpression>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for NamedFieldExpressionProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "name" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().name.clone().into(),
                                )),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "name" => {
                                    self.inner.write().unwrap().name =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "NamedFieldExpression".into()
    }

    fn close(self) {}
}

impl Display for NamedFieldExpressionProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "NamedFieldExpression({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	name: {:?},", self.inner.read().unwrap().name)?;
        writeln!(f, "}})")
    }
}

const NEGATION_ID: Uuid = uuid!("80f73c4e-caf1-4e1f-a634-00965f6ad032");

#[derive(Clone, Debug)]
pub struct NegationProxy {
    inner: Arc<RwLock<Negation>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for NegationProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Negation".into()
    }

    fn close(self) {}
}

impl Display for NegationProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Negation({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const NOT_ID: Uuid = uuid!("0ad229c4-1782-4783-b64e-0d15fe482463");

#[derive(Clone, Debug)]
pub struct NotProxy {
    inner: Arc<RwLock<Not>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for NotProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Not".into()
    }

    fn close(self) {}
}

impl Display for NotProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Not({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const NOT_EQUAL_ID: Uuid = uuid!("b8d3d40e-462e-4e4d-9fb4-b7d54f9fd03a");

#[derive(Clone, Debug)]
pub struct NotEqualProxy {
    inner: Arc<RwLock<NotEqual>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for NotEqualProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "NotEqual".into()
    }

    fn close(self) {}
}

impl Display for NotEqualProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "NotEqual({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const Z_OBJECT_STORE_ID: Uuid = uuid!("b7483723-222d-4f08-b7b9-e8b14f0308cf");

#[derive(Clone, Debug)]
pub struct ZObjectStoreProxy {
    inner: Arc<RwLock<ZObjectStore>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for ZObjectStoreProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "domain" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().domain.clone().into(),
                                )),
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "name" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().name.clone().into(),
                                )),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "domain" => {
                                    self.inner.write().unwrap().domain =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "name" => {
                                    self.inner.write().unwrap().name =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "ZObjectStore".into()
    }

    fn close(self) {}
}

impl Display for ZObjectStoreProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "ZObjectStore({{")?;
        writeln!(f, "	domain: {:?},", self.inner.read().unwrap().domain)?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	name: {:?},", self.inner.read().unwrap().name)?;
        writeln!(f, "}})")
    }
}

const OBJECT_WRAPPER_ID: Uuid = uuid!("68e7191a-fe94-423f-8a5d-5551384ae998");

#[derive(Clone, Debug)]
pub struct ObjectWrapperProxy {
    inner: Arc<RwLock<ObjectWrapper>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for ObjectWrapperProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "object" => {
                                    Err(Error::Uber("Imported object not supported.".into()))
                                }
                                "z_store" => {
                                    let z_store = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_z_object_store(&self.inner.read().unwrap().z_store)
                                        .unwrap();

                                    let this = ZObjectStoreProxy {
                                        inner: z_store,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: Z_OBJECT_STORE_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "object" => {
                                    self.inner.write().unwrap().object =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "z_store" => {
                                    self.inner.write().unwrap().z_store =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "ObjectWrapper".into()
    }

    fn close(self) {}
}

impl Display for ObjectWrapperProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "ObjectWrapper({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	object: {:?},", self.inner.read().unwrap().object)?;
        writeln!(f, "	z_store: {:?},", self.inner.read().unwrap().z_store)?;
        writeln!(f, "}})")
    }
}

const OPERATOR_ID: Uuid = uuid!("3f7fd816-518b-4b9e-8134-3059e78045a0");

#[derive(Clone, Debug)]
pub struct OperatorProxy {
    inner: Arc<RwLock<Operator>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for OperatorProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "lhs" => {
                                    let lhs = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_expression(&self.inner.read().unwrap().lhs)
                                        .unwrap();

                                    let this = ExpressionProxy {
                                        inner: lhs,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: EXPRESSION_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                "rhs" => match self.inner.read().unwrap().rhs {
                                    Some(rhs) => Ok(FfiValue::Option(ROption::RSome(RBox::new(
                                        FfiValue::Uuid(rhs.into()),
                                    )))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "lhs" => {
                                    self.inner.write().unwrap().lhs =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "rhs" => {
                                    self.inner.write().unwrap().rhs =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Operator".into()
    }

    fn close(self) {}
}

impl Display for OperatorProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Operator({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	lhs: {:?},", self.inner.read().unwrap().lhs)?;
        writeln!(f, "	rhs: {:?},", self.inner.read().unwrap().rhs)?;
        writeln!(f, "}})")
    }
}

const OR_ID: Uuid = uuid!("41b7bda7-f5a2-4c94-af22-fedbe8d6f287");

#[derive(Clone, Debug)]
pub struct OrProxy {
    inner: Arc<RwLock<Or>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for OrProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Or".into()
    }

    fn close(self) {}
}

impl Display for OrProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Or({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const PARAMETER_ID: Uuid = uuid!("f192b162-8ada-4128-8805-1953e9165c54");

#[derive(Clone, Debug)]
pub struct ParameterProxy {
    inner: Arc<RwLock<Parameter>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for ParameterProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "position" => Ok(FfiValue::Integer(
                                    self.inner.read().unwrap().position.into(),
                                )),
                                "function" => {
                                    let function = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_function(&self.inner.read().unwrap().function)
                                        .unwrap();

                                    let this = FunctionProxy {
                                        inner: function,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: FUNCTION_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                "next" => match self.inner.read().unwrap().next {
                                    Some(next) => Ok(FfiValue::Option(ROption::RSome(RBox::new(
                                        FfiValue::Uuid(next.into()),
                                    )))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                "ty" => {
                                    let ty = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_value_type(&self.inner.read().unwrap().ty)
                                        .unwrap();

                                    let this = ValueTypeProxy {
                                        inner: ty,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: VALUE_TYPE_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "position" => {
                                    self.inner.write().unwrap().position =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "function" => {
                                    self.inner.write().unwrap().function =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "next" => {
                                    self.inner.write().unwrap().next =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "ty" => {
                                    self.inner.write().unwrap().ty =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Parameter".into()
    }

    fn close(self) {}
}

impl Display for ParameterProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Parameter({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	position: {:?},", self.inner.read().unwrap().position)?;
        writeln!(f, "	function: {:?},", self.inner.read().unwrap().function)?;
        writeln!(f, "	next: {:?},", self.inner.read().unwrap().next)?;
        writeln!(f, "	ty: {:?},", self.inner.read().unwrap().ty)?;
        writeln!(f, "}})")
    }
}

const X_PATH_ID: Uuid = uuid!("ab7a5708-6d12-4dce-b488-fa3a3b480510");

#[derive(Clone, Debug)]
pub struct XPathProxy {
    inner: Arc<RwLock<XPath>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for XPathProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "unique" => {
                                    Ok(FfiValue::Uuid(self.inner.read().unwrap().unique.into()))
                                }
                                "first" => match self.inner.read().unwrap().first {
                                    Some(first) => Ok(FfiValue::Option(ROption::RSome(RBox::new(
                                        FfiValue::Uuid(first.into()),
                                    )))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "unique" => {
                                    self.inner.write().unwrap().unique =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "first" => {
                                    self.inner.write().unwrap().first =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "XPath".into()
    }

    fn close(self) {}
}

impl Display for XPathProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "XPath({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	unique: {:?},", self.inner.read().unwrap().unique)?;
        writeln!(f, "	first: {:?},", self.inner.read().unwrap().first)?;
        writeln!(f, "}})")
    }
}

const PATH_ELEMENT_ID: Uuid = uuid!("39060ea9-5d45-4954-a29f-ba88e01e7217");

#[derive(Clone, Debug)]
pub struct PathElementProxy {
    inner: Arc<RwLock<PathElement>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for PathElementProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "name" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().name.clone().into(),
                                )),
                                "next" => match self.inner.read().unwrap().next {
                                    Some(next) => Ok(FfiValue::Option(ROption::RSome(RBox::new(
                                        FfiValue::Uuid(next.into()),
                                    )))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                "x_path" => {
                                    let x_path = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_x_path(&self.inner.read().unwrap().x_path)
                                        .unwrap();

                                    let this = XPathProxy {
                                        inner: x_path,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: X_PATH_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "name" => {
                                    self.inner.write().unwrap().name =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "next" => {
                                    self.inner.write().unwrap().next =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "x_path" => {
                                    self.inner.write().unwrap().x_path =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "PathElement".into()
    }

    fn close(self) {}
}

impl Display for PathElementProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "PathElement({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	name: {:?},", self.inner.read().unwrap().name)?;
        writeln!(f, "	next: {:?},", self.inner.read().unwrap().next)?;
        writeln!(f, "	x_path: {:?},", self.inner.read().unwrap().x_path)?;
        writeln!(f, "}})")
    }
}

const PATTERN_ID: Uuid = uuid!("6094aad5-613b-42b6-8f48-c3b9e2161aa9");

#[derive(Clone, Debug)]
pub struct PatternProxy {
    inner: Arc<RwLock<Pattern>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for PatternProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "expression" => {
                                    let expression = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_expression(&self.inner.read().unwrap().expression)
                                        .unwrap();

                                    let this = ExpressionProxy {
                                        inner: expression,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: EXPRESSION_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                "match_expr" => {
                                    let match_expr = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_expression(&self.inner.read().unwrap().match_expr)
                                        .unwrap();

                                    let this = ExpressionProxy {
                                        inner: match_expr,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: EXPRESSION_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                "x_match" => {
                                    let x_match = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_x_match(&self.inner.read().unwrap().x_match)
                                        .unwrap();

                                    let this = XMatchProxy {
                                        inner: x_match,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: X_MATCH_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "expression" => {
                                    self.inner.write().unwrap().expression =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "match_expr" => {
                                    self.inner.write().unwrap().match_expr =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "x_match" => {
                                    self.inner.write().unwrap().x_match =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Pattern".into()
    }

    fn close(self) {}
}

impl Display for PatternProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Pattern({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(
            f,
            "	expression: {:?},",
            self.inner.read().unwrap().expression
        )?;
        writeln!(
            f,
            "	match_expr: {:?},",
            self.inner.read().unwrap().match_expr
        )?;
        writeln!(f, "	x_match: {:?},", self.inner.read().unwrap().x_match)?;
        writeln!(f, "}})")
    }
}

const X_PLUGIN_ID: Uuid = uuid!("a9b74602-bdc5-481f-af4c-8021553b895a");

#[derive(Clone, Debug)]
pub struct XPluginProxy {
    inner: Arc<RwLock<XPlugin>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for XPluginProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "name" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().name.clone().into(),
                                )),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "name" => {
                                    self.inner.write().unwrap().name =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "XPlugin".into()
    }

    fn close(self) {}
}

impl Display for XPluginProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "XPlugin({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	name: {:?},", self.inner.read().unwrap().name)?;
        writeln!(f, "}})")
    }
}

const X_PRINT_ID: Uuid = uuid!("6a0a9ba3-81ef-4fdc-8de1-d67e84dfb656");

#[derive(Clone, Debug)]
pub struct XPrintProxy {
    inner: Arc<RwLock<XPrint>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for XPrintProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "expression" => {
                                    let expression = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_expression(&self.inner.read().unwrap().expression)
                                        .unwrap();

                                    let this = ExpressionProxy {
                                        inner: expression,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: EXPRESSION_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "expression" => {
                                    self.inner.write().unwrap().expression =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "XPrint".into()
    }

    fn close(self) {}
}

impl Display for XPrintProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "XPrint({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(
            f,
            "	expression: {:?},",
            self.inner.read().unwrap().expression
        )?;
        writeln!(f, "}})")
    }
}

const RANGE_ID: Uuid = uuid!("ba8a3bbf-86a8-47e2-92bb-f41878981c41");

#[derive(Clone, Debug)]
pub struct RangeProxy {
    inner: Arc<RwLock<Range>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for RangeProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Range".into()
    }

    fn close(self) {}
}

impl Display for RangeProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Range({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const RANGE_EXPRESSION_ID: Uuid = uuid!("0b3e9de0-d139-4934-a043-d1913a24de0c");

#[derive(Clone, Debug)]
pub struct RangeExpressionProxy {
    inner: Arc<RwLock<RangeExpression>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for RangeExpressionProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "lhs" => match self.inner.read().unwrap().lhs {
                                    Some(lhs) => Ok(FfiValue::Option(ROption::RSome(RBox::new(
                                        FfiValue::Uuid(lhs.into()),
                                    )))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                "rhs" => match self.inner.read().unwrap().rhs {
                                    Some(rhs) => Ok(FfiValue::Option(ROption::RSome(RBox::new(
                                        FfiValue::Uuid(rhs.into()),
                                    )))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "lhs" => {
                                    self.inner.write().unwrap().lhs =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "rhs" => {
                                    self.inner.write().unwrap().rhs =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "RangeExpression".into()
    }

    fn close(self) {}
}

impl Display for RangeExpressionProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "RangeExpression({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	lhs: {:?},", self.inner.read().unwrap().lhs)?;
        writeln!(f, "	rhs: {:?},", self.inner.read().unwrap().rhs)?;
        writeln!(f, "}})")
    }
}

const RESULT_STATEMENT_ID: Uuid = uuid!("b359d531-77ae-436f-9f0d-6a5632f1648e");

#[derive(Clone, Debug)]
pub struct ResultStatementProxy {
    inner: Arc<RwLock<ResultStatement>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for ResultStatementProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "expression" => {
                                    let expression = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_expression(&self.inner.read().unwrap().expression)
                                        .unwrap();

                                    let this = ExpressionProxy {
                                        inner: expression,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: EXPRESSION_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "expression" => {
                                    self.inner.write().unwrap().expression =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "ResultStatement".into()
    }

    fn close(self) {}
}

impl Display for ResultStatementProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "ResultStatement({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(
            f,
            "	expression: {:?},",
            self.inner.read().unwrap().expression
        )?;
        writeln!(f, "}})")
    }
}

const X_RETURN_ID: Uuid = uuid!("93f288e7-d670-40a6-91f3-2006b5efa8b4");

#[derive(Clone, Debug)]
pub struct XReturnProxy {
    inner: Arc<RwLock<XReturn>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for XReturnProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "expression" => {
                                    let expression = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_expression(&self.inner.read().unwrap().expression)
                                        .unwrap();

                                    let this = ExpressionProxy {
                                        inner: expression,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: EXPRESSION_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "expression" => {
                                    self.inner.write().unwrap().expression =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "XReturn".into()
    }

    fn close(self) {}
}

impl Display for XReturnProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "XReturn({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(
            f,
            "	expression: {:?},",
            self.inner.read().unwrap().expression
        )?;
        writeln!(f, "}})")
    }
}

const SPAN_ID: Uuid = uuid!("79571896-9798-44a3-acef-5aa2d9773b93");

#[derive(Clone, Debug)]
pub struct SpanProxy {
    inner: Arc<RwLock<Span>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for SpanProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "end" => {
                                    Ok(FfiValue::Integer(self.inner.read().unwrap().end.into()))
                                }
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "start" => {
                                    Ok(FfiValue::Integer(self.inner.read().unwrap().start.into()))
                                }
                                "source" => {
                                    let source = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_dwarf_source_file(
                                            &self.inner.read().unwrap().source,
                                        )
                                        .unwrap();

                                    let this = DwarfSourceFileProxy {
                                        inner: source,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: DWARF_SOURCE_FILE_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                "ty" => match self.inner.read().unwrap().ty {
                                    Some(ty) => Ok(FfiValue::Option(ROption::RSome(RBox::new(
                                        FfiValue::Uuid(ty.into()),
                                    )))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                "x_value" => match self.inner.read().unwrap().x_value {
                                    Some(x_value) => Ok(FfiValue::Option(ROption::RSome(
                                        RBox::new(FfiValue::Uuid(x_value.into())),
                                    ))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "end" => {
                                    self.inner.write().unwrap().end =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "start" => {
                                    self.inner.write().unwrap().start =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "source" => {
                                    self.inner.write().unwrap().source =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "ty" => {
                                    self.inner.write().unwrap().ty =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "x_value" => {
                                    self.inner.write().unwrap().x_value =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Span".into()
    }

    fn close(self) {}
}

impl Display for SpanProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Span({{")?;
        writeln!(f, "	end: {:?},", self.inner.read().unwrap().end)?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	start: {:?},", self.inner.read().unwrap().start)?;
        writeln!(f, "	source: {:?},", self.inner.read().unwrap().source)?;
        writeln!(f, "	ty: {:?},", self.inner.read().unwrap().ty)?;
        writeln!(f, "	x_value: {:?},", self.inner.read().unwrap().x_value)?;
        writeln!(f, "}})")
    }
}

const STATEMENT_ID: Uuid = uuid!("6c7969f3-f150-4975-a989-a7bc8164b168");

#[derive(Clone, Debug)]
pub struct StatementProxy {
    inner: Arc<RwLock<Statement>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for StatementProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "index" => {
                                    Ok(FfiValue::Integer(self.inner.read().unwrap().index.into()))
                                }
                                "block" => {
                                    let block = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_block(&self.inner.read().unwrap().block)
                                        .unwrap();

                                    let this = BlockProxy {
                                        inner: block,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: BLOCK_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                "next" => match self.inner.read().unwrap().next {
                                    Some(next) => Ok(FfiValue::Option(ROption::RSome(RBox::new(
                                        FfiValue::Uuid(next.into()),
                                    )))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "index" => {
                                    self.inner.write().unwrap().index =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "block" => {
                                    self.inner.write().unwrap().block =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "next" => {
                                    self.inner.write().unwrap().next =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Statement".into()
    }

    fn close(self) {}
}

impl Display for StatementProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Statement({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	index: {:?},", self.inner.read().unwrap().index)?;
        writeln!(f, "	block: {:?},", self.inner.read().unwrap().block)?;
        writeln!(f, "	next: {:?},", self.inner.read().unwrap().next)?;
        writeln!(f, "}})")
    }
}

const STATIC_METHOD_CALL_ID: Uuid = uuid!("01c8907d-cb59-4fae-a3ca-8cb331d18387");

#[derive(Clone, Debug)]
pub struct StaticMethodCallProxy {
    inner: Arc<RwLock<StaticMethodCall>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for StaticMethodCallProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "func" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().func.clone().into(),
                                )),
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "ty" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().ty.clone().into(),
                                )),
                                "unique" => {
                                    Ok(FfiValue::Uuid(self.inner.read().unwrap().unique.into()))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "func" => {
                                    self.inner.write().unwrap().func =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "ty" => {
                                    self.inner.write().unwrap().ty =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "unique" => {
                                    self.inner.write().unwrap().unique =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "StaticMethodCall".into()
    }

    fn close(self) {}
}

impl Display for StaticMethodCallProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "StaticMethodCall({{")?;
        writeln!(f, "	func: {:?},", self.inner.read().unwrap().func)?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	ty: {:?},", self.inner.read().unwrap().ty)?;
        writeln!(f, "	unique: {:?},", self.inner.read().unwrap().unique)?;
        writeln!(f, "}})")
    }
}

const STRING_LITERAL_ID: Uuid = uuid!("d30d2b03-732b-41bb-89ed-d053750bf987");

#[derive(Clone, Debug)]
pub struct StringLiteralProxy {
    inner: Arc<RwLock<StringLiteral>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for StringLiteralProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "x_value" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().x_value.clone().into(),
                                )),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "x_value" => {
                                    self.inner.write().unwrap().x_value =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "StringLiteral".into()
    }

    fn close(self) {}
}

impl Display for StringLiteralProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "StringLiteral({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	x_value: {:?},", self.inner.read().unwrap().x_value)?;
        writeln!(f, "}})")
    }
}

const WOOG_STRUCT_ID: Uuid = uuid!("e68f8912-9897-4cbd-b363-cb4203a726a9");

#[derive(Clone, Debug)]
pub struct WoogStructProxy {
    inner: Arc<RwLock<WoogStruct>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for WoogStructProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "name" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().name.clone().into(),
                                )),
                                "first_generic" => match self.inner.read().unwrap().first_generic {
                                    Some(first_generic) => Ok(FfiValue::Option(ROption::RSome(
                                        RBox::new(FfiValue::Uuid(first_generic.into())),
                                    ))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                "object" => match self.inner.read().unwrap().object {
                                    Some(object) => Ok(FfiValue::Option(ROption::RSome(
                                        RBox::new(FfiValue::Uuid(object.into())),
                                    ))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "name" => {
                                    self.inner.write().unwrap().name =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "first_generic" => {
                                    self.inner.write().unwrap().first_generic =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "object" => {
                                    self.inner.write().unwrap().object =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "WoogStruct".into()
    }

    fn close(self) {}
}

impl Display for WoogStructProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "WoogStruct({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	name: {:?},", self.inner.read().unwrap().name)?;
        writeln!(
            f,
            "	first_generic: {:?},",
            self.inner.read().unwrap().first_generic
        )?;
        writeln!(f, "	object: {:?},", self.inner.read().unwrap().object)?;
        writeln!(f, "}})")
    }
}

const STRUCT_EXPRESSION_ID: Uuid = uuid!("d546feef-91df-49ea-ac61-430bdcf9832c");

#[derive(Clone, Debug)]
pub struct StructExpressionProxy {
    inner: Arc<RwLock<StructExpression>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for StructExpressionProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "bug" => Ok(FfiValue::Uuid(self.inner.read().unwrap().bug.into())),
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "data" => {
                                    let data = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_data_structure(&self.inner.read().unwrap().data)
                                        .unwrap();

                                    let this = DataStructureProxy {
                                        inner: data,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: DATA_STRUCTURE_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                "x_path" => {
                                    let x_path = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_x_path(&self.inner.read().unwrap().x_path)
                                        .unwrap();

                                    let this = XPathProxy {
                                        inner: x_path,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: X_PATH_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "bug" => {
                                    self.inner.write().unwrap().bug =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "data" => {
                                    self.inner.write().unwrap().data =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "x_path" => {
                                    self.inner.write().unwrap().x_path =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "StructExpression".into()
    }

    fn close(self) {}
}

impl Display for StructExpressionProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "StructExpression({{")?;
        writeln!(f, "	bug: {:?},", self.inner.read().unwrap().bug)?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	data: {:?},", self.inner.read().unwrap().data)?;
        writeln!(f, "	x_path: {:?},", self.inner.read().unwrap().x_path)?;
        writeln!(f, "}})")
    }
}

const STRUCT_FIELD_ID: Uuid = uuid!("e6fbeeb8-6ade-46a2-bb52-9c99d06918b2");

#[derive(Clone, Debug)]
pub struct StructFieldProxy {
    inner: Arc<RwLock<StructField>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for StructFieldProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "name" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().name.clone().into(),
                                )),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "name" => {
                                    self.inner.write().unwrap().name =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "StructField".into()
    }

    fn close(self) {}
}

impl Display for StructFieldProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "StructField({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	name: {:?},", self.inner.read().unwrap().name)?;
        writeln!(f, "}})")
    }
}

const STRUCT_GENERIC_ID: Uuid = uuid!("290f49d3-8ce7-408e-be14-611b66db9687");

#[derive(Clone, Debug)]
pub struct StructGenericProxy {
    inner: Arc<RwLock<StructGeneric>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for StructGenericProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "name" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().name.clone().into(),
                                )),
                                "next" => match self.inner.read().unwrap().next {
                                    Some(next) => Ok(FfiValue::Option(ROption::RSome(RBox::new(
                                        FfiValue::Uuid(next.into()),
                                    )))),
                                    None => Ok(FfiValue::Option(ROption::RNone)),
                                },

                                "woog_struct" => {
                                    let woog_struct = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_woog_struct(&self.inner.read().unwrap().woog_struct)
                                        .unwrap();

                                    let this = WoogStructProxy {
                                        inner: woog_struct,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: WOOG_STRUCT_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "name" => {
                                    self.inner.write().unwrap().name =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "next" => {
                                    self.inner.write().unwrap().next =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "woog_struct" => {
                                    self.inner.write().unwrap().woog_struct =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "StructGeneric".into()
    }

    fn close(self) {}
}

impl Display for StructGenericProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "StructGeneric({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	name: {:?},", self.inner.read().unwrap().name)?;
        writeln!(f, "	next: {:?},", self.inner.read().unwrap().next)?;
        writeln!(
            f,
            "	woog_struct: {:?},",
            self.inner.read().unwrap().woog_struct
        )?;
        writeln!(f, "}})")
    }
}

const SUBTRACTION_ID: Uuid = uuid!("e3329a9e-1c52-44f6-a1f7-fc85f7362e9e");

#[derive(Clone, Debug)]
pub struct SubtractionProxy {
    inner: Arc<RwLock<Subtraction>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for SubtractionProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Subtraction".into()
    }

    fn close(self) {}
}

impl Display for SubtractionProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Subtraction({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const TASK_ID: Uuid = uuid!("23a9a479-68e7-4a70-bcef-9041f10fd287");

#[derive(Clone, Debug)]
pub struct TaskProxy {
    inner: Arc<RwLock<Task>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for TaskProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Task".into()
    }

    fn close(self) {}
}

impl Display for TaskProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Task({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const TO_ID: Uuid = uuid!("32dbb54a-9693-4847-9278-7c956ea045f8");

#[derive(Clone, Debug)]
pub struct ToProxy {
    inner: Arc<RwLock<To>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for ToProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "To".into()
    }

    fn close(self) {}
}

impl Display for ToProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "To({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const TO_INCLUSIVE_ID: Uuid = uuid!("30abb231-4248-4ffa-9a69-e0eb6bb9dbbd");

#[derive(Clone, Debug)]
pub struct ToInclusiveProxy {
    inner: Arc<RwLock<ToInclusive>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for ToInclusiveProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "ToInclusive".into()
    }

    fn close(self) {}
}

impl Display for ToInclusiveProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "ToInclusive({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const TRUE_LITERAL_ID: Uuid = uuid!("dc6d1ffa-5dca-43ef-b973-0628ab580cb7");

#[derive(Clone, Debug)]
pub struct TrueLiteralProxy {
    inner: Arc<RwLock<TrueLiteral>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for TrueLiteralProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "TrueLiteral".into()
    }

    fn close(self) {}
}

impl Display for TrueLiteralProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "TrueLiteral({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const TUPLE_FIELD_ID: Uuid = uuid!("c8fcd612-6ca8-469a-824c-de218e4fd075");

#[derive(Clone, Debug)]
pub struct TupleFieldProxy {
    inner: Arc<RwLock<TupleField>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for TupleFieldProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "xyzzy" => {
                                    Ok(FfiValue::Uuid(self.inner.read().unwrap().xyzzy.into()))
                                }
                                "ty" => {
                                    let ty = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_value_type(&self.inner.read().unwrap().ty)
                                        .unwrap();

                                    let this = ValueTypeProxy {
                                        inner: ty,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: VALUE_TYPE_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "xyzzy" => {
                                    self.inner.write().unwrap().xyzzy =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "ty" => {
                                    self.inner.write().unwrap().ty =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "TupleField".into()
    }

    fn close(self) {}
}

impl Display for TupleFieldProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "TupleField({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	xyzzy: {:?},", self.inner.read().unwrap().xyzzy)?;
        writeln!(f, "	ty: {:?},", self.inner.read().unwrap().ty)?;
        writeln!(f, "}})")
    }
}

const TYPE_CAST_ID: Uuid = uuid!("1e7a66b2-f559-4c21-b8e6-969999ed171d");

#[derive(Clone, Debug)]
pub struct TypeCastProxy {
    inner: Arc<RwLock<TypeCast>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for TypeCastProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "lhs" => {
                                    let lhs = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_expression(&self.inner.read().unwrap().lhs)
                                        .unwrap();

                                    let this = ExpressionProxy {
                                        inner: lhs,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: EXPRESSION_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                "ty" => {
                                    let ty = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_value_type(&self.inner.read().unwrap().ty)
                                        .unwrap();

                                    let this = ValueTypeProxy {
                                        inner: ty,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: VALUE_TYPE_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "lhs" => {
                                    self.inner.write().unwrap().lhs =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "ty" => {
                                    self.inner.write().unwrap().ty =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "TypeCast".into()
    }

    fn close(self) {}
}

impl Display for TypeCastProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "TypeCast({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	lhs: {:?},", self.inner.read().unwrap().lhs)?;
        writeln!(f, "	ty: {:?},", self.inner.read().unwrap().ty)?;
        writeln!(f, "}})")
    }
}

const UNARY_ID: Uuid = uuid!("f7fc16ac-6a23-4f5d-a04c-1163617701c1");

#[derive(Clone, Debug)]
pub struct UnaryProxy {
    inner: Arc<RwLock<Unary>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for UnaryProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Unary".into()
    }

    fn close(self) {}
}

impl Display for UnaryProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Unary({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const UNIT_ID: Uuid = uuid!("4b6c7fde-0878-4947-b960-bc73a4558c60");

#[derive(Clone, Debug)]
pub struct UnitProxy {
    inner: Arc<RwLock<Unit>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for UnitProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "x_value" => {
                                    Ok(FfiValue::Integer(self.inner.read().unwrap().x_value.into()))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "x_value" => {
                                    self.inner.write().unwrap().x_value =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Unit".into()
    }

    fn close(self) {}
}

impl Display for UnitProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Unit({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	x_value: {:?},", self.inner.read().unwrap().x_value)?;
        writeln!(f, "}})")
    }
}

const UNKNOWN_ID: Uuid = uuid!("3a1c7f6a-459d-4eba-9291-2aebb9bf60c9");

#[derive(Clone, Debug)]
pub struct UnknownProxy {
    inner: Arc<RwLock<Unknown>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for UnknownProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Unknown".into()
    }

    fn close(self) {}
}

impl Display for UnknownProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Unknown({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const UNNAMED_FIELD_EXPRESSION_ID: Uuid = uuid!("910e3a08-5e99-47a5-bde4-3e35cf9f00da");

#[derive(Clone, Debug)]
pub struct UnnamedFieldExpressionProxy {
    inner: Arc<RwLock<UnnamedFieldExpression>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for UnnamedFieldExpressionProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "position" => Ok(FfiValue::Integer(
                                    self.inner.read().unwrap().position.into(),
                                )),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "position" => {
                                    self.inner.write().unwrap().position =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "UnnamedFieldExpression".into()
    }

    fn close(self) {}
}

impl Display for UnnamedFieldExpressionProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "UnnamedFieldExpression({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	position: {:?},", self.inner.read().unwrap().position)?;
        writeln!(f, "}})")
    }
}

const X_VALUE_ID: Uuid = uuid!("94fc0044-4b88-4f5c-ac60-3a44262ade10");

#[derive(Clone, Debug)]
pub struct XValueProxy {
    inner: Arc<RwLock<XValue>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for XValueProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "block" => {
                                    let block = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_block(&self.inner.read().unwrap().block)
                                        .unwrap();

                                    let this = BlockProxy {
                                        inner: block,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: BLOCK_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                "ty" => {
                                    let ty = self
                                        .store
                                        .read()
                                        .unwrap()
                                        .exhume_value_type(&self.inner.read().unwrap().ty)
                                        .unwrap();

                                    let this = ValueTypeProxy {
                                        inner: ty,
                                        store: self.store.clone(),
                                    };
                                    let plugin = Plugin_TO::from_value(this, TD_CanDowncast);
                                    let proxy = FfiProxy {
                                        module: module.into(),
                                        uuid: VALUE_TYPE_ID.into(),
                                        id: self.inner.read().unwrap().id.into(), // c
                                        plugin: plugin.clone(),
                                    };
                                    Ok(FfiValue::ProxyType(proxy))
                                }
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "block" => {
                                    self.inner.write().unwrap().block =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                "ty" => {
                                    self.inner.write().unwrap().ty =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "XValue".into()
    }

    fn close(self) {}
}

impl Display for XValueProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "XValue({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	block: {:?},", self.inner.read().unwrap().block)?;
        writeln!(f, "	ty: {:?},", self.inner.read().unwrap().ty)?;
        writeln!(f, "}})")
    }
}

const VALUE_TYPE_ID: Uuid = uuid!("2e277e34-ab6f-4028-9c52-935c31520fec");

#[derive(Clone, Debug)]
pub struct ValueTypeProxy {
    inner: Arc<RwLock<ValueType>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for ValueTypeProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id().into())),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "ValueType".into()
    }

    fn close(self) {}
}

impl Display for ValueTypeProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "ValueType({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id())?;
        writeln!(f, "}})")
    }
}

const VARIABLE_ID: Uuid = uuid!("954b354f-3a90-440b-ab0f-43efc00d275e");

#[derive(Clone, Debug)]
pub struct VariableProxy {
    inner: Arc<RwLock<Variable>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for VariableProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "name" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().name.clone().into(),
                                )),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "name" => {
                                    self.inner.write().unwrap().name =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "Variable".into()
    }

    fn close(self) {}
}

impl Display for VariableProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Variable({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	name: {:?},", self.inner.read().unwrap().name)?;
        writeln!(f, "}})")
    }
}

const VARIABLE_EXPRESSION_ID: Uuid = uuid!("d715c5f9-23f8-45e0-a1df-34e27acd01f5");

#[derive(Clone, Debug)]
pub struct VariableExpressionProxy {
    inner: Arc<RwLock<VariableExpression>>,
    store: Arc<RwLock<ObjectStore>>,
}

impl Plugin for VariableExpressionProxy {
    fn invoke_func(
        &mut self,
        module: RStr<'_>,
        ty: RStr<'_>,
        func: RStr<'_>,
        mut args: RVec<FfiValue>,
    ) -> RResult<FfiValue, Error> {
        (|| -> Result<FfiValue, Error> {
            let ty = ty.as_str();
            let func = func.as_str();
            debug!("type: {ty}, func: {func}, args: {args:?}");
            match ty {
                "self" => match func {
                    "get_field_value" => {
                        if args.len() != 1 {
                            return Err(Error::Uber("Expected 1 argument".into()));
                        }

                        if let FfiValue::String(field) = args.pop().unwrap() {
                            match field.as_str() {
                                "id" => Ok(FfiValue::Uuid(self.inner.read().unwrap().id.into())),
                                "name" => Ok(FfiValue::String(
                                    self.inner.read().unwrap().name.clone().into(),
                                )),
                                _ => Err(Error::Uber("Invalid field".into())),
                            }
                        } else {
                            Err(Error::Uber("Invalid Object".into()))
                        }
                    }
                    "set_field_value" => {
                        if args.len() != 2 {
                            return Err(Error::Uber("Expected 2 arguments".into()));
                        }

                        args.reverse();
                        let field = args.pop().unwrap();

                        if let FfiValue::String(field) = field {
                            let value: Value = args.pop().unwrap().into();
                            match field.as_str() {
                                "name" => {
                                    self.inner.write().unwrap().name =
                                        value.try_into().map_err(|e| {
                                            Error::Uber(
                                                format!("Error converting value: {e}").into(),
                                            )
                                        })?
                                }
                                field => {
                                    return Err(Error::Uber(
                                        format!("Invalid field {field}").into(),
                                    ))
                                }
                            }

                            Ok(FfiValue::Empty)
                        } else {
                            Err(Error::Uber(format!("Invalid field type: {field:?}").into()))
                        }
                    }
                    func => Err(Error::Uber(format!("Invalid function: {func:?}").into())),
                },
                ty => Err(Error::Uber(format!("Invalid type {ty:?}").into())),
            }
        })()
        .into()
    }

    fn name(&self) -> RStr<'_> {
        "VariableExpression".into()
    }

    fn close(self) {}
}

impl Display for VariableExpressionProxy {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "VariableExpression({{")?;
        writeln!(f, "	id: {:?},", self.inner.read().unwrap().id)?;
        writeln!(f, "	name: {:?},", self.inner.read().unwrap().name)?;
        writeln!(f, "}})")
    }
}
