// A blank domain

use std::prelude::*;

// This annotation tells the interpreter that the struct will be a proxy for
// an `ObjectStore` called lu_dog. It will find the plugin based on the name.
#[store(model = "lu_dog")]
struct LuDogStore {}

// This is just to keep the type checking happy.
#[store(model = "lu_dog")]
impl LuDogStore {
    // This is a function that exists on the ObjectStore, and the interpreter
    // will invoke it in the plugin.
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "new")]
    fn new() -> Self;
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "load")]
    fn load(path: string) -> Self;
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "persist")]
    fn save(self) -> Self;


    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_argument")]
    fn inter_argument(self, argument: Argument);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_argument")]
    fn exhume_argument(self, argument: Uuid) -> Argument;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_a_wait")]
    fn inter_a_wait(self, a_wait: Await);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_a_wait")]
    fn exhume_a_wait(self, a_wait: Uuid) -> Await;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_binary")]
    fn inter_binary(self, binary: Binary);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_binary")]
    fn exhume_binary(self, binary: Uuid) -> Binary;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_block")]
    fn inter_block(self, block: Block);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_block")]
    fn exhume_block(self, block: Uuid) -> Block;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_body")]
    fn inter_body(self, body: Body);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_body")]
    fn exhume_body(self, body: Uuid) -> Body;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_boolean_literal")]
    fn inter_boolean_literal(self, boolean_literal: BooleanLiteral);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_boolean_literal")]
    fn exhume_boolean_literal(self, boolean_literal: Uuid) -> BooleanLiteral;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_boolean_operator")]
    fn inter_boolean_operator(self, boolean_operator: BooleanOperator);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_boolean_operator")]
    fn exhume_boolean_operator(self, boolean_operator: Uuid) -> BooleanOperator;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_call")]
    fn inter_call(self, call: Call);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_call")]
    fn exhume_call(self, call: Uuid) -> Call;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_comparison")]
    fn inter_comparison(self, comparison: Comparison);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_comparison")]
    fn exhume_comparison(self, comparison: Uuid) -> Comparison;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_data_structure")]
    fn inter_data_structure(self, data_structure: DataStructure);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_data_structure")]
    fn exhume_data_structure(self, data_structure: Uuid) -> DataStructure;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_dwarf_source_file")]
    fn inter_dwarf_source_file(self, dwarf_source_file: DwarfSourceFile);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_dwarf_source_file")]
    fn exhume_dwarf_source_file(self, dwarf_source_file: Uuid) -> DwarfSourceFile;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_enum_field")]
    fn inter_enum_field(self, enum_field: EnumField);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_enum_field")]
    fn exhume_enum_field(self, enum_field: Uuid) -> EnumField;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_enum_generic")]
    fn inter_enum_generic(self, enum_generic: EnumGeneric);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_enum_generic")]
    fn exhume_enum_generic(self, enum_generic: Uuid) -> EnumGeneric;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_enumeration")]
    fn inter_enumeration(self, enumeration: Enumeration);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_enumeration")]
    fn exhume_enumeration(self, enumeration: Uuid) -> Enumeration;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_expression")]
    fn inter_expression(self, expression: Expression);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_expression")]
    fn exhume_expression(self, expression: Uuid) -> Expression;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_expression_statement")]
    fn inter_expression_statement(self, expression_statement: ExpressionStatement);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_expression_statement")]
    fn exhume_expression_statement(self, expression_statement: Uuid) -> ExpressionStatement;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_external_implementation")]
    fn inter_external_implementation(self, external_implementation: ExternalImplementation);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_external_implementation")]
    fn exhume_external_implementation(self, external_implementation: Uuid) -> ExternalImplementation;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_field")]
    fn inter_field(self, field: Field);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_field")]
    fn exhume_field(self, field: Uuid) -> Field;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_field_access")]
    fn inter_field_access(self, field_access: FieldAccess);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_field_access")]
    fn exhume_field_access(self, field_access: Uuid) -> FieldAccess;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_field_access_target")]
    fn inter_field_access_target(self, field_access_target: FieldAccessTarget);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_field_access_target")]
    fn exhume_field_access_target(self, field_access_target: Uuid) -> FieldAccessTarget;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_field_expression")]
    fn inter_field_expression(self, field_expression: FieldExpression);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_field_expression")]
    fn exhume_field_expression(self, field_expression: Uuid) -> FieldExpression;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_float_literal")]
    fn inter_float_literal(self, float_literal: FloatLiteral);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_float_literal")]
    fn exhume_float_literal(self, float_literal: Uuid) -> FloatLiteral;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_for_loop")]
    fn inter_for_loop(self, for_loop: ForLoop);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_for_loop")]
    fn exhume_for_loop(self, for_loop: Uuid) -> ForLoop;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_function")]
    fn inter_function(self, function: Function);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_function")]
    fn exhume_function(self, function: Uuid) -> Function;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_x_future")]
    fn inter_x_future(self, x_future: XFuture);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_x_future")]
    fn exhume_x_future(self, x_future: Uuid) -> XFuture;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_generic")]
    fn inter_generic(self, generic: Generic);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_generic")]
    fn exhume_generic(self, generic: Uuid) -> Generic;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_grouped")]
    fn inter_grouped(self, grouped: Grouped);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_grouped")]
    fn exhume_grouped(self, grouped: Uuid) -> Grouped;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_x_if")]
    fn inter_x_if(self, x_if: If);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_x_if")]
    fn exhume_x_if(self, x_if: Uuid) -> If;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_implementation_block")]
    fn inter_implementation_block(self, implementation_block: ImplementationBlock);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_implementation_block")]
    fn exhume_implementation_block(self, implementation_block: Uuid) -> ImplementationBlock;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_import")]
    fn inter_import(self, import: Import);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_import")]
    fn exhume_import(self, import: Uuid) -> Import;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_index")]
    fn inter_index(self, index: Index);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_index")]
    fn exhume_index(self, index: Uuid) -> Index;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_integer_literal")]
    fn inter_integer_literal(self, integer_literal: IntegerLiteral);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_integer_literal")]
    fn exhume_integer_literal(self, integer_literal: Uuid) -> IntegerLiteral;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_item")]
    fn inter_item(self, item: Item);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_item")]
    fn exhume_item(self, item: Uuid) -> Item;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_lambda")]
    fn inter_lambda(self, lambda: Lambda);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_lambda")]
    fn exhume_lambda(self, lambda: Uuid) -> Lambda;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_lambda_parameter")]
    fn inter_lambda_parameter(self, lambda_parameter: LambdaParameter);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_lambda_parameter")]
    fn exhume_lambda_parameter(self, lambda_parameter: Uuid) -> LambdaParameter;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_let_statement")]
    fn inter_let_statement(self, let_statement: LetStatement);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_let_statement")]
    fn exhume_let_statement(self, let_statement: Uuid) -> LetStatement;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_list")]
    fn inter_list(self, list: List);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_list")]
    fn exhume_list(self, list: Uuid) -> List;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_list_element")]
    fn inter_list_element(self, list_element: ListElement);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_list_element")]
    fn exhume_list_element(self, list_element: Uuid) -> ListElement;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_list_expression")]
    fn inter_list_expression(self, list_expression: ListExpression);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_list_expression")]
    fn exhume_list_expression(self, list_expression: Uuid) -> ListExpression;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_literal")]
    fn inter_literal(self, literal: Literal);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_literal")]
    fn exhume_literal(self, literal: Uuid) -> Literal;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_local_variable")]
    fn inter_local_variable(self, local_variable: LocalVariable);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_local_variable")]
    fn exhume_local_variable(self, local_variable: Uuid) -> LocalVariable;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_x_macro")]
    fn inter_x_macro(self, x_macro: Macro);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_x_macro")]
    fn exhume_x_macro(self, x_macro: Uuid) -> Macro;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_x_match")]
    fn inter_x_match(self, x_match: Match);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_x_match")]
    fn exhume_x_match(self, x_match: Uuid) -> Match;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_method_call")]
    fn inter_method_call(self, method_call: MethodCall);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_method_call")]
    fn exhume_method_call(self, method_call: Uuid) -> MethodCall;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_named_field_expression")]
    fn inter_named_field_expression(self, named_field_expression: NamedFieldExpression);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_named_field_expression")]
    fn exhume_named_field_expression(self, named_field_expression: Uuid) -> NamedFieldExpression;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_z_object_store")]
    fn inter_z_object_store(self, z_object_store: ObjectStore);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_z_object_store")]
    fn exhume_z_object_store(self, z_object_store: Uuid) -> ObjectStore;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_object_wrapper")]
    fn inter_object_wrapper(self, object_wrapper: ObjectWrapper);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_object_wrapper")]
    fn exhume_object_wrapper(self, object_wrapper: Uuid) -> ObjectWrapper;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_operator")]
    fn inter_operator(self, operator: Operator);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_operator")]
    fn exhume_operator(self, operator: Uuid) -> Operator;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_parameter")]
    fn inter_parameter(self, parameter: Parameter);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_parameter")]
    fn exhume_parameter(self, parameter: Uuid) -> Parameter;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_x_path")]
    fn inter_x_path(self, x_path: Path);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_x_path")]
    fn exhume_x_path(self, x_path: Uuid) -> Path;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_path_element")]
    fn inter_path_element(self, path_element: PathElement);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_path_element")]
    fn exhume_path_element(self, path_element: Uuid) -> PathElement;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_pattern")]
    fn inter_pattern(self, pattern: Pattern);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_pattern")]
    fn exhume_pattern(self, pattern: Uuid) -> Pattern;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_x_plugin")]
    fn inter_x_plugin(self, x_plugin: Plugin);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_x_plugin")]
    fn exhume_x_plugin(self, x_plugin: Uuid) -> Plugin;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_x_print")]
    fn inter_x_print(self, x_print: Print);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_x_print")]
    fn exhume_x_print(self, x_print: Uuid) -> Print;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_range_expression")]
    fn inter_range_expression(self, range_expression: RangeExpression);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_range_expression")]
    fn exhume_range_expression(self, range_expression: Uuid) -> RangeExpression;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_result_statement")]
    fn inter_result_statement(self, result_statement: ResultStatement);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_result_statement")]
    fn exhume_result_statement(self, result_statement: Uuid) -> ResultStatement;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_x_return")]
    fn inter_x_return(self, x_return: Return);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_x_return")]
    fn exhume_x_return(self, x_return: Uuid) -> Return;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_span")]
    fn inter_span(self, span: Span);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_span")]
    fn exhume_span(self, span: Uuid) -> Span;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_statement")]
    fn inter_statement(self, statement: Statement);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_statement")]
    fn exhume_statement(self, statement: Uuid) -> Statement;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_static_method_call")]
    fn inter_static_method_call(self, static_method_call: StaticMethodCall);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_static_method_call")]
    fn exhume_static_method_call(self, static_method_call: Uuid) -> StaticMethodCall;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_string_literal")]
    fn inter_string_literal(self, string_literal: StringLiteral);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_string_literal")]
    fn exhume_string_literal(self, string_literal: Uuid) -> StringLiteral;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_woog_struct")]
    fn inter_woog_struct(self, woog_struct: Struct);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_woog_struct")]
    fn exhume_woog_struct(self, woog_struct: Uuid) -> Struct;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_struct_expression")]
    fn inter_struct_expression(self, struct_expression: StructExpression);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_struct_expression")]
    fn exhume_struct_expression(self, struct_expression: Uuid) -> StructExpression;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_struct_field")]
    fn inter_struct_field(self, struct_field: StructField);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_struct_field")]
    fn exhume_struct_field(self, struct_field: Uuid) -> StructField;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_struct_generic")]
    fn inter_struct_generic(self, struct_generic: StructGeneric);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_struct_generic")]
    fn exhume_struct_generic(self, struct_generic: Uuid) -> StructGeneric;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_tuple_field")]
    fn inter_tuple_field(self, tuple_field: TupleField);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_tuple_field")]
    fn exhume_tuple_field(self, tuple_field: Uuid) -> TupleField;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_type_cast")]
    fn inter_type_cast(self, type_cast: TypeCast);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_type_cast")]
    fn exhume_type_cast(self, type_cast: Uuid) -> TypeCast;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_unary")]
    fn inter_unary(self, unary: Unary);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_unary")]
    fn exhume_unary(self, unary: Uuid) -> Unary;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_unit")]
    fn inter_unit(self, unit: Unit);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_unit")]
    fn exhume_unit(self, unit: Uuid) -> Unit;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_unnamed_field_expression")]
    fn inter_unnamed_field_expression(self, unnamed_field_expression: UnnamedFieldExpression);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_unnamed_field_expression")]
    fn exhume_unnamed_field_expression(self, unnamed_field_expression: Uuid) -> UnnamedFieldExpression;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_x_value")]
    fn inter_x_value(self, x_value: Value);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_x_value")]
    fn exhume_x_value(self, x_value: Uuid) -> Value;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_value_type")]
    fn inter_value_type(self, value_type: ValueType);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_value_type")]
    fn exhume_value_type(self, value_type: Uuid) -> ValueType;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_variable")]
    fn inter_variable(self, variable: Variable);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_variable")]
    fn exhume_variable(self, variable: Uuid) -> Variable;

    #[proxy(store = "lu_dog", object = "ObjectStore", func = "inter_variable_expression")]
    fn inter_variable_expression(self, variable_expression: VariableExpression);
    #[proxy(store = "lu_dog", object = "ObjectStore", func = "exhume_variable_expression")]
    fn exhume_variable_expression(self, variable_expression: Uuid) -> VariableExpression;
}

// The addition operator: `+`.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Addition" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Addition")]
struct Addition {
    id: Uuid,
    // Non-formalizing relationships
}

impl Addition {
    #[proxy(store = "lu_dog", object = "Addition", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Addition", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("The addition operator: `+`.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Addition {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// The Boolean And Operator
// 
// And, aka, `&&`.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "And" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "And")]
struct And {
    id: Uuid,
    // Non-formalizing relationships
}

impl And {
    #[proxy(store = "lu_dog", object = "And", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "And", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("The Boolean And Operator\n");
        print("\n");
        print("And, aka, `&&`.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct And {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// An Argument to a Function Call
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Argument" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Argument")]
struct Argument {
    id: Uuid,
    position: int,
    expression: Expression,
    function: Call,
    next: Option<Argument>,
    // Non-formalizing relationships
}

impl Argument {
    #[proxy(store = "lu_dog", object = "Argument", func = "new")]
    fn new(position: int, expression: Expression, function: Call, next: Option<Argument>) -> Self;

    #[proxy(store = "lu_dog", object = "Argument", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("An Argument to a Function Call\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Argument {\n");
        print("    id: Uuid,\n");
        print("    position: int,\n");
        print("    expression: Expression,\n");
        print("    function: Call,\n");
        print("    next: Option<Argument>,\n");
        print("}\n");
    }
}

// Assignment to a storage location
// 
// E.g., `a = b`.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Assignment" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Assignment")]
struct Assignment {
    id: Uuid,
    // Non-formalizing relationships
}

impl Assignment {
    #[proxy(store = "lu_dog", object = "Assignment", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Assignment", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("Assignment to a storage location\n");
        print("\n");
        print("E.g., `a = b`.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Assignment {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "Await" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Await")]
struct Await {
    id: Uuid,
    x_future: Expression,
    // Non-formalizing relationships
}

impl Await {
    #[proxy(store = "lu_dog", object = "Await", func = "new")]
    fn new(x_future: Expression) -> Self;

    #[proxy(store = "lu_dog", object = "Await", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct Await {\n");
        print("    id: Uuid,\n");
        print("    x_future: Expression,\n");
        print("}\n");
    }
}

// Binary Operators
// 
// +, -, etc.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Binary" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Binary")]
struct Binary {
    id: Uuid,
    // Non-formalizing relationships
}

impl Binary {
    #[proxy(store = "lu_dog", object = "Binary", func = "new_addition")]
    fn new_addition() -> Self;

    #[proxy(store = "lu_dog", object = "Binary", func = "new_assignment")]
    fn new_assignment() -> Self;

    #[proxy(store = "lu_dog", object = "Binary", func = "new_boolean_operator")]
    fn new_boolean_operator() -> Self;

    #[proxy(store = "lu_dog", object = "Binary", func = "new_division")]
    fn new_division() -> Self;

    #[proxy(store = "lu_dog", object = "Binary", func = "new_multiplication")]
    fn new_multiplication() -> Self;

    #[proxy(store = "lu_dog", object = "Binary", func = "new_subtraction")]
    fn new_subtraction() -> Self;

    #[proxy(store = "lu_dog", object = "Binary", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("Binary Operators\n");
        print("\n");
        print("+, -, etc.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Binary {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// A Block Expression
// 
// A block expression is an expression that consists of an ordered set of statements, living
//  between an opening `{`, and a closing `}`.
// 
// Given that it's an expression it has a Type. The type is the value of the last expression
//  in the block, if it's not closed by a `;`. If the last statement is terminated thusly, then
//  the value is `[Empty]`, or `()`.
// 
// The `bug` attribute is just there to keep this thing unique. An issue that needs addressing
// .
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Block" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Block")]
struct Block {
    a_sink: bool,
    bug: Uuid,
    id: Uuid,
    parent: Option<Block>,
    statement: Option<Statement>,
    // Non-formalizing relationships
}

impl Block {
    #[proxy(store = "lu_dog", object = "Block", func = "new")]
    fn new(a_sink: bool, bug: Uuid, parent: Option<Block>, statement: Option<Statement>) -> Self;

    #[proxy(store = "lu_dog", object = "Block", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A Block Expression\n");
        print("\n");
        print("A block expression is an expression that consists of an ordered set of statements, living\n");
        print(" between an opening `{`, and a closing `}`.\n");
        print("\n");
        print("Given that it's an expression it has a Type. The type is the value of the last expression\n");
        print(" in the block, if it's not closed by a `;`. If the last statement is terminated thusly, then\n");
        print(" the value is `[Empty]`, or `()`.\n");
        print("\n");
        print("The `bug` attribute is just there to keep this thing unique. An issue that needs addressing\n");
        print(".\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Block {\n");
        print("    a_sink: bool,\n");
        print("    bug: Uuid,\n");
        print("    id: Uuid,\n");
        print("    parent: Option<Block>,\n");
        print("    statement: Option<Statement>,\n");
        print("}\n");
    }
}

// The function body. Generally contains statements, but may point to some other implementation
// .
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Body" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Body")]
struct Body {
    a_sink: bool,
    id: Uuid,
    // Non-formalizing relationships
}

impl Body {
    #[proxy(store = "lu_dog", object = "Body", func = "new_block")]
    fn new_block(a_sink: bool, block: Block
) -> Self;

    #[proxy(store = "lu_dog", object = "Body", func = "new_external_implementation")]
    fn new_external_implementation(a_sink: bool, external_implementation: ExternalImplementation
) -> Self;

    #[proxy(store = "lu_dog", object = "Body", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("The function body. Generally contains statements, but may point to some other implementation\n");
        print(".\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Body {\n");
        print("    a_sink: bool,\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// A Boolean
// 
// It's either `true` or `false`.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "BooleanLiteral" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Boolean Literal")]
struct BooleanLiteral {
    id: Uuid,
    // Non-formalizing relationships
}

impl BooleanLiteral {
    #[proxy(store = "lu_dog", object = "Boolean Literal", func = "new_false_literal")]
    fn new_false_literal() -> Self;

    #[proxy(store = "lu_dog", object = "Boolean Literal", func = "new_true_literal")]
    fn new_true_literal() -> Self;

    #[proxy(store = "lu_dog", object = "Boolean Literal", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A Boolean\n");
        print("\n");
        print("It's either `true` or `false`.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct BooleanLiteral {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// A Boolean Operaator
// 
// There are two — || and &&.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "BooleanOperator" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Boolean Operator")]
struct BooleanOperator {
    id: Uuid,
    // Non-formalizing relationships
}

impl BooleanOperator {
    #[proxy(store = "lu_dog", object = "Boolean Operator", func = "new_and")]
    fn new_and() -> Self;

    #[proxy(store = "lu_dog", object = "Boolean Operator", func = "new_or")]
    fn new_or() -> Self;

    #[proxy(store = "lu_dog", object = "Boolean Operator", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A Boolean Operaator\n");
        print("\n");
        print("There are two — || and &&.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct BooleanOperator {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// A Call, of some sort
// 
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Call" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Call")]
struct Call {
    arg_check: bool,
    id: Uuid,
    argument: Option<Argument>,
    expression: Option<Expression>,
    // Non-formalizing relationships
}

impl Call {
    #[proxy(store = "lu_dog", object = "Call", func = "new_function_call")]
    fn new_function_call(arg_check: bool, argument: Option<Argument>, expression: Option<Expression>, function_call: FunctionCall
) -> Self;

    #[proxy(store = "lu_dog", object = "Call", func = "new_macro_call")]
    fn new_macro_call(arg_check: bool, argument: Option<Argument>, expression: Option<Expression>, macro_call: MacroCall
) -> Self;

    #[proxy(store = "lu_dog", object = "Call", func = "new_method_call")]
    fn new_method_call(arg_check: bool, argument: Option<Argument>, expression: Option<Expression>, method_call: MethodCall
) -> Self;

    #[proxy(store = "lu_dog", object = "Call", func = "new_static_method_call")]
    fn new_static_method_call(arg_check: bool, argument: Option<Argument>, expression: Option<Expression>, static_method_call: StaticMethodCall
) -> Self;

    #[proxy(store = "lu_dog", object = "Call", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A Call, of some sort\n");
        print("\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Call {\n");
        print("    arg_check: bool,\n");
        print("    id: Uuid,\n");
        print("    argument: Option<Argument>,\n");
        print("    expression: Option<Expression>,\n");
        print("}\n");
    }
}

// A char
// 
// I char is a single printable UNICODE character. It may contain multiple bytes.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Char" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Char")]
struct Char {
    id: Uuid,
    // Non-formalizing relationships
}

impl Char {
    #[proxy(store = "lu_dog", object = "Char", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Char", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A char\n");
        print("\n");
        print("I char is a single printable UNICODE character. It may contain multiple bytes.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Char {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// Comparison Operators
// 
// Things like == and !=, etc.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Comparison" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Comparison")]
struct Comparison {
    id: Uuid,
    // Non-formalizing relationships
}

impl Comparison {
    #[proxy(store = "lu_dog", object = "Comparison", func = "new_equal")]
    fn new_equal() -> Self;

    #[proxy(store = "lu_dog", object = "Comparison", func = "new_greater_than")]
    fn new_greater_than() -> Self;

    #[proxy(store = "lu_dog", object = "Comparison", func = "new_greater_than_or_equal")]
    fn new_greater_than_or_equal() -> Self;

    #[proxy(store = "lu_dog", object = "Comparison", func = "new_less_than")]
    fn new_less_than() -> Self;

    #[proxy(store = "lu_dog", object = "Comparison", func = "new_less_than_or_equal")]
    fn new_less_than_or_equal() -> Self;

    #[proxy(store = "lu_dog", object = "Comparison", func = "new_not_equal")]
    fn new_not_equal() -> Self;

    #[proxy(store = "lu_dog", object = "Comparison", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("Comparison Operators\n");
        print("\n");
        print("Things like == and !=, etc.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Comparison {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "DataStructure" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Data Structure")]
struct DataStructure {
    id: Uuid,
    // Non-formalizing relationships
}

impl DataStructure {
    #[proxy(store = "lu_dog", object = "Data Structure", func = "new_enumeration")]
    fn new_enumeration() -> Self;

    #[proxy(store = "lu_dog", object = "Data Structure", func = "new_woog_struct")]
    fn new_woog_struct() -> Self;

    #[proxy(store = "lu_dog", object = "Data Structure", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct DataStructure {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// An expresision to invoke the debugger;
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Debugger" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Debugger")]
struct Debugger {
    id: Uuid,
    // Non-formalizing relationships
}

impl Debugger {
    #[proxy(store = "lu_dog", object = "Debugger", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Debugger", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("An expresision to invoke the debugger;\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Debugger {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "Division" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Division")]
struct Division {
    id: Uuid,
    // Non-formalizing relationships
}

impl Division {
    #[proxy(store = "lu_dog", object = "Division", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Division", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct Division {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// The Source Code
// 
// The main purpose of this object is to capture the source code that contains the definitions
//  that will be parsed. This allows us to do better error reporting in the interpreter. We
//  may also be able to do something about displaying compiled functions, maybe.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "DwarfSourceFile" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Dwarf Source File")]
struct DwarfSourceFile {
    id: Uuid,
    source: string,
    // Non-formalizing relationships
}

impl DwarfSourceFile {
    #[proxy(store = "lu_dog", object = "Dwarf Source File", func = "new")]
    fn new(source: string) -> Self;

    #[proxy(store = "lu_dog", object = "Dwarf Source File", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("The Source Code\n");
        print("\n");
        print("The main purpose of this object is to capture the source code that contains the definitions\n");
        print(" that will be parsed. This allows us to do better error reporting in the interpreter. We\n");
        print(" may also be able to do something about displaying compiled functions, maybe.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct DwarfSourceFile {\n");
        print("    id: Uuid,\n");
        print("    source: string,\n");
        print("}\n");
    }
}

// The Empty Type
// 
// This type represents the lack of a type. It's actually sort of a werid construct, because
//  it also implies the lack of a value. How can you have a value without a type?
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Empty" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Empty")]
struct Empty {
    id: Uuid,
    // Non-formalizing relationships
}

impl Empty {
    #[proxy(store = "lu_dog", object = "Empty", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Empty", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("The Empty Type\n");
        print("\n");
        print("This type represents the lack of a type. It's actually sort of a werid construct, because\n");
        print(" it also implies the lack of a value. How can you have a value without a type?\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Empty {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "EmptyExpression" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Empty Expression")]
struct EmptyExpression {
    id: Uuid,
    // Non-formalizing relationships
}

impl EmptyExpression {
    #[proxy(store = "lu_dog", object = "Empty Expression", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Empty Expression", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct EmptyExpression {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// A field on an Enumeration
// 
// Note that there are three sorts of fields. Tuple, Struct, and “plain?”.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "EnumField" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Enum Field")]
struct EnumField {
    id: Uuid,
    name: string,
    woog_enum: Enumeration,
    // Non-formalizing relationships
}

impl EnumField {
    #[proxy(store = "lu_dog", object = "Enum Field", func = "new_struct_field")]
    fn new_struct_field(name: string, woog_enum: Enumeration, struct_field: StructField
) -> Self;

    #[proxy(store = "lu_dog", object = "Enum Field", func = "new_tuple_field")]
    fn new_tuple_field(name: string, woog_enum: Enumeration, tuple_field: TupleField
) -> Self;

    #[proxy(store = "lu_dog", object = "Enum Field", func = "new_unit")]
    fn new_unit(name: string, woog_enum: Enumeration, unit: Unit
) -> Self;

    #[proxy(store = "lu_dog", object = "Enum Field", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A field on an Enumeration\n");
        print("\n");
        print("Note that there are three sorts of fields. Tuple, Struct, and “plain?”.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct EnumField {\n");
        print("    id: Uuid,\n");
        print("    name: string,\n");
        print("    woog_enum: Enumeration,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "EnumGeneric" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Enum Generic")]
struct EnumGeneric {
    id: Uuid,
    name: string,
    woog_enum: Enumeration,
    next: Option<EnumGeneric>,
    // Non-formalizing relationships
}

impl EnumGeneric {
    #[proxy(store = "lu_dog", object = "Enum Generic", func = "new")]
    fn new(name: string, woog_enum: Enumeration, next: Option<EnumGeneric>) -> Self;

    #[proxy(store = "lu_dog", object = "Enum Generic", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct EnumGeneric {\n");
        print("    id: Uuid,\n");
        print("    name: string,\n");
        print("    woog_enum: Enumeration,\n");
        print("    next: Option<EnumGeneric>,\n");
        print("}\n");
    }
}

// An Enumeration
// 
// An enumeration is an algebraic type that takes on one if it’s fielsd, another type. as
//  it’s value.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Enumeration" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Enumeration")]
struct Enumeration {
    id: Uuid,
    name: string,
    first_generic: Option<EnumGeneric>,
    implementation: Option<ImplementationBlock>,
    // Non-formalizing relationships
}

impl Enumeration {
    #[proxy(store = "lu_dog", object = "Enumeration", func = "new")]
    fn new(name: string, first_generic: Option<EnumGeneric>, implementation: Option<ImplementationBlock>) -> Self;

    #[proxy(store = "lu_dog", object = "Enumeration", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("An Enumeration\n");
        print("\n");
        print("An enumeration is an algebraic type that takes on one if it’s fielsd, another type. as\n");
        print(" it’s value.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Enumeration {\n");
        print("    id: Uuid,\n");
        print("    name: string,\n");
        print("    first_generic: Option<EnumGeneric>,\n");
        print("    implementation: Option<ImplementationBlock>,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "Equal" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Equal")]
struct Equal {
    id: Uuid,
    // Non-formalizing relationships
}

impl Equal {
    #[proxy(store = "lu_dog", object = "Equal", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Equal", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct Equal {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// An Expression
// 
// Expressions are calculations that render values.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Expression" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Expression")]
struct Expression {
    id: Uuid,
    // Non-formalizing relationships
}

impl Expression {
    #[proxy(store = "lu_dog", object = "Expression", func = "new_a_wait")]
    fn new_a_wait() -> Self;

    #[proxy(store = "lu_dog", object = "Expression", func = "new_block")]
    fn new_block() -> Self;

    #[proxy(store = "lu_dog", object = "Expression", func = "new_call")]
    fn new_call() -> Self;

    #[proxy(store = "lu_dog", object = "Expression", func = "new_debugger")]
    fn new_debugger() -> Self;

    #[proxy(store = "lu_dog", object = "Expression", func = "new_empty_expression")]
    fn new_empty_expression() -> Self;

    #[proxy(store = "lu_dog", object = "Expression", func = "new_field_access")]
    fn new_field_access() -> Self;

    #[proxy(store = "lu_dog", object = "Expression", func = "new_field_expression")]
    fn new_field_expression() -> Self;

    #[proxy(store = "lu_dog", object = "Expression", func = "new_for_loop")]
    fn new_for_loop() -> Self;

    #[proxy(store = "lu_dog", object = "Expression", func = "new_grouped")]
    fn new_grouped() -> Self;

    #[proxy(store = "lu_dog", object = "Expression", func = "new_x_if")]
    fn new_x_if() -> Self;

    #[proxy(store = "lu_dog", object = "Expression", func = "new_index")]
    fn new_index() -> Self;

    #[proxy(store = "lu_dog", object = "Expression", func = "new_lambda")]
    fn new_lambda() -> Self;

    #[proxy(store = "lu_dog", object = "Expression", func = "new_list_element")]
    fn new_list_element() -> Self;

    #[proxy(store = "lu_dog", object = "Expression", func = "new_list_expression")]
    fn new_list_expression() -> Self;

    #[proxy(store = "lu_dog", object = "Expression", func = "new_literal")]
    fn new_literal() -> Self;

    #[proxy(store = "lu_dog", object = "Expression", func = "new_x_match")]
    fn new_x_match() -> Self;

    #[proxy(store = "lu_dog", object = "Expression", func = "new_operator")]
    fn new_operator() -> Self;

    #[proxy(store = "lu_dog", object = "Expression", func = "new_x_path")]
    fn new_x_path() -> Self;

    #[proxy(store = "lu_dog", object = "Expression", func = "new_x_print")]
    fn new_x_print() -> Self;

    #[proxy(store = "lu_dog", object = "Expression", func = "new_range_expression")]
    fn new_range_expression() -> Self;

    #[proxy(store = "lu_dog", object = "Expression", func = "new_x_return")]
    fn new_x_return() -> Self;

    #[proxy(store = "lu_dog", object = "Expression", func = "new_struct_expression")]
    fn new_struct_expression() -> Self;

    #[proxy(store = "lu_dog", object = "Expression", func = "new_type_cast")]
    fn new_type_cast() -> Self;

    #[proxy(store = "lu_dog", object = "Expression", func = "new_variable_expression")]
    fn new_variable_expression() -> Self;

    #[proxy(store = "lu_dog", object = "Expression", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("An Expression\n");
        print("\n");
        print("Expressions are calculations that render values.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Expression {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// A statement that consists of just an expression.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "ExpressionStatement" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Expression Statement")]
struct ExpressionStatement {
    id: Uuid,
    expression: Expression,
    // Non-formalizing relationships
}

impl ExpressionStatement {
    #[proxy(store = "lu_dog", object = "Expression Statement", func = "new")]
    fn new(expression: Expression) -> Self;

    #[proxy(store = "lu_dog", object = "Expression Statement", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A statement that consists of just an expression.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct ExpressionStatement {\n");
        print("    id: Uuid,\n");
        print("    expression: Expression,\n");
        print("}\n");
    }
}

// Some extern source of the function’s body.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "ExternalImplementation" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "External Implementation")]
struct ExternalImplementation {
    function: string,
    id: Uuid,
    x_model: string,
    object: string,
    // Non-formalizing relationships
}

impl ExternalImplementation {
    #[proxy(store = "lu_dog", object = "External Implementation", func = "new")]
    fn new(function: string, x_model: string, object: string) -> Self;

    #[proxy(store = "lu_dog", object = "External Implementation", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("Some extern source of the function’s body.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct ExternalImplementation {\n");
        print("    function: string,\n");
        print("    id: Uuid,\n");
        print("    x_model: string,\n");
        print("    object: string,\n");
        print("}\n");
    }
}

// False Literal
// 
// The literal `false`.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "False" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "False")]
struct False {
    id: Uuid,
    // Non-formalizing relationships
}

impl False {
    #[proxy(store = "lu_dog", object = "False", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "False", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("False Literal\n");
        print("\n");
        print("The literal `false`.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct False {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// A Field in a data structure
// 
// A field has a name, and a type.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Field" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Field")]
struct Field {
    id: Uuid,
    name: string,
    x_model: Struct,
    ty: ValueType,
    // Non-formalizing relationships
}

impl Field {
    #[proxy(store = "lu_dog", object = "Field", func = "new")]
    fn new(name: string, x_model: Struct, ty: ValueType) -> Self;

    #[proxy(store = "lu_dog", object = "Field", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A Field in a data structure\n");
        print("\n");
        print("A field has a name, and a type.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Field {\n");
        print("    id: Uuid,\n");
        print("    name: string,\n");
        print("    x_model: Struct,\n");
        print("    ty: ValueType,\n");
        print("}\n");
    }
}

// A Struct Field Access
// 
// Think dotted notation.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "FieldAccess" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Field Access")]
struct FieldAccess {
    id: Uuid,
    expression: Expression,
    field: FieldAccessTarget,
    woog_struct: Struct,
    // Non-formalizing relationships
}

impl FieldAccess {
    #[proxy(store = "lu_dog", object = "Field Access", func = "new")]
    fn new(expression: Expression, field: FieldAccessTarget, woog_struct: Struct) -> Self;

    #[proxy(store = "lu_dog", object = "Field Access", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A Struct Field Access\n");
        print("\n");
        print("Think dotted notation.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct FieldAccess {\n");
        print("    id: Uuid,\n");
        print("    expression: Expression,\n");
        print("    field: FieldAccessTarget,\n");
        print("    woog_struct: Struct,\n");
        print("}\n");
    }
}

// The target of a field access.
// 
// It may be either a [`Field`] or a [`Function`].
// 
// This tells the interpreter that this struct is a proxy for an object called
// "FieldAccessTarget" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Field Access Target")]
struct FieldAccessTarget {
    id: Uuid,
    // Non-formalizing relationships
}

impl FieldAccessTarget {
    #[proxy(store = "lu_dog", object = "Field Access Target", func = "new_enum_field")]
    fn new_enum_field() -> Self;

    #[proxy(store = "lu_dog", object = "Field Access Target", func = "new_field")]
    fn new_field() -> Self;

    #[proxy(store = "lu_dog", object = "Field Access Target", func = "new_function")]
    fn new_function() -> Self;

    #[proxy(store = "lu_dog", object = "Field Access Target", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("The target of a field access.\n");
        print("\n");
        print("It may be either a [`Field`] or a [`Function`].\n");
        print("\n");
    }

    fn info() -> () {
        print("struct FieldAccessTarget {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// A Struct Field Expression
// 
// This assigns a value to a field in a structure.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "FieldExpression" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Field Expression")]
struct FieldExpression {
    id: Uuid,
    expression: Expression,
    woog_struct: StructExpression,
    // Non-formalizing relationships
}

impl FieldExpression {
    #[proxy(store = "lu_dog", object = "Field Expression", func = "new_named_field_expression")]
    fn new_named_field_expression(expression: Expression, woog_struct: StructExpression, named_field_expression: NamedFieldExpression
) -> Self;

    #[proxy(store = "lu_dog", object = "Field Expression", func = "new_unnamed_field_expression")]
    fn new_unnamed_field_expression(expression: Expression, woog_struct: StructExpression, unnamed_field_expression: UnnamedFieldExpression
) -> Self;

    #[proxy(store = "lu_dog", object = "Field Expression", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A Struct Field Expression\n");
        print("\n");
        print("This assigns a value to a field in a structure.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct FieldExpression {\n");
        print("    id: Uuid,\n");
        print("    expression: Expression,\n");
        print("    woog_struct: StructExpression,\n");
        print("}\n");
    }
}

// A Floating Point Literal
// 
// Nothing fancy. No scientific notation.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "FloatLiteral" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Float Literal")]
struct FloatLiteral {
    id: Uuid,
    x_value: float,
    // Non-formalizing relationships
}

impl FloatLiteral {
    #[proxy(store = "lu_dog", object = "Float Literal", func = "new")]
    fn new(x_value: float) -> Self;

    #[proxy(store = "lu_dog", object = "Float Literal", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A Floating Point Literal\n");
        print("\n");
        print("Nothing fancy. No scientific notation.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct FloatLiteral {\n");
        print("    id: Uuid,\n");
        print("    x_value: float,\n");
        print("}\n");
    }
}

// A For Loop Expression
// 
// An expression that matches for IDENT in EXPRESSION BLOCK.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "ForLoop" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "For Loop")]
struct ForLoop {
    id: Uuid,
    ident: string,
    block: Block,
    expression: Expression,
    // Non-formalizing relationships
}

impl ForLoop {
    #[proxy(store = "lu_dog", object = "For Loop", func = "new")]
    fn new(ident: string, block: Block, expression: Expression) -> Self;

    #[proxy(store = "lu_dog", object = "For Loop", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A For Loop Expression\n");
        print("\n");
        print("An expression that matches for IDENT in EXPRESSION BLOCK.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct ForLoop {\n");
        print("    id: Uuid,\n");
        print("    ident: string,\n");
        print("    block: Block,\n");
        print("    expression: Expression,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "From" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "From")]
struct From {
    id: Uuid,
    // Non-formalizing relationships
}

impl From {
    #[proxy(store = "lu_dog", object = "From", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "From", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct From {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "Full" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Full")]
struct Full {
    id: Uuid,
    // Non-formalizing relationships
}

impl Full {
    #[proxy(store = "lu_dog", object = "Full", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Full", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct Full {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// A Function
// 
// Inputs, outputs. Stuff happens.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Function" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Function")]
struct Function {
    id: Uuid,
    name: string,
    body: Body,
    first_param: Option<Parameter>,
    impl_block: Option<ImplementationBlock>,
    return_type: ValueType,
    // Non-formalizing relationships
}

impl Function {
    #[proxy(store = "lu_dog", object = "Function", func = "new")]
    fn new(name: string, body: Body, first_param: Option<Parameter>, impl_block: Option<ImplementationBlock>, return_type: ValueType) -> Self;

    #[proxy(store = "lu_dog", object = "Function", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A Function\n");
        print("\n");
        print("Inputs, outputs. Stuff happens.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Function {\n");
        print("    id: Uuid,\n");
        print("    name: string,\n");
        print("    body: Body,\n");
        print("    first_param: Option<Parameter>,\n");
        print("    impl_block: Option<ImplementationBlock>,\n");
        print("    return_type: ValueType,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "FunctionCall" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Function Call")]
struct FunctionCall {
    id: Uuid,
    // Non-formalizing relationships
}

impl FunctionCall {
    #[proxy(store = "lu_dog", object = "Function Call", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Function Call", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct FunctionCall {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "XFuture" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Future")]
struct XFuture {
    id: Uuid,
    x_value: ValueType,
    // Non-formalizing relationships
}

impl XFuture {
    #[proxy(store = "lu_dog", object = "Future", func = "new")]
    fn new(x_value: ValueType) -> Self;

    #[proxy(store = "lu_dog", object = "Future", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct XFuture {\n");
        print("    id: Uuid,\n");
        print("    x_value: ValueType,\n");
        print("}\n");
    }
}

// This is a generic “type”.
// 
// It’s really a placeholder in the extruder/compiler. We’ll use it as a type declaration
// , and then define a new type for each use.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Generic" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Generic")]
struct Generic {
    id: Uuid,
    name: string,
    next: Option<Generic>,
    ty: Option<ValueType>,
    // Non-formalizing relationships
}

impl Generic {
    #[proxy(store = "lu_dog", object = "Generic", func = "new")]
    fn new(name: string, next: Option<Generic>, ty: Option<ValueType>) -> Self;

    #[proxy(store = "lu_dog", object = "Generic", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("This is a generic “type”.\n");
        print("\n");
        print("It’s really a placeholder in the extruder/compiler. We’ll use it as a type declaration\n");
        print(", and then define a new type for each use.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Generic {\n");
        print("    id: Uuid,\n");
        print("    name: string,\n");
        print("    next: Option<Generic>,\n");
        print("    ty: Option<ValueType>,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "GreaterThan" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Greater Than")]
struct GreaterThan {
    id: Uuid,
    // Non-formalizing relationships
}

impl GreaterThan {
    #[proxy(store = "lu_dog", object = "Greater Than", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Greater Than", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct GreaterThan {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "GreaterThanOrEqual" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Greater Than or Equal")]
struct GreaterThanOrEqual {
    id: Uuid,
    // Non-formalizing relationships
}

impl GreaterThanOrEqual {
    #[proxy(store = "lu_dog", object = "Greater Than or Equal", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Greater Than or Equal", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct GreaterThanOrEqual {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// Parens
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Grouped" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Grouped")]
struct Grouped {
    id: Uuid,
    expression: Expression,
    // Non-formalizing relationships
}

impl Grouped {
    #[proxy(store = "lu_dog", object = "Grouped", func = "new")]
    fn new(expression: Expression) -> Self;

    #[proxy(store = "lu_dog", object = "Grouped", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("Parens\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Grouped {\n");
        print("    id: Uuid,\n");
        print("    expression: Expression,\n");
        print("}\n");
    }
}

// The if Expression
// 
// It does include an else, at no extra charge!
// 
// This tells the interpreter that this struct is a proxy for an object called
// "If" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "If")]
struct If {
    id: Uuid,
    false_block: Option<Block>,
    test: Expression,
    true_block: Block,
    // Non-formalizing relationships
}

impl If {
    #[proxy(store = "lu_dog", object = "If", func = "new")]
    fn new(false_block: Option<Block>, test: Expression, true_block: Block) -> Self;

    #[proxy(store = "lu_dog", object = "If", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("The if Expression\n");
        print("\n");
        print("It does include an else, at no extra charge!\n");
        print("\n");
    }

    fn info() -> () {
        print("struct If {\n");
        print("    id: Uuid,\n");
        print("    false_block: Option<Block>,\n");
        print("    test: Expression,\n");
        print("    true_block: Block,\n");
        print("}\n");
    }
}

// An Implementation Block
// 
// Inside this block functions are defined on a [`ModellType`].
// 
// This tells the interpreter that this struct is a proxy for an object called
// "ImplementationBlock" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Implementation Block")]
struct ImplementationBlock {
    id: Uuid,
    model_type: Option<Struct>,
    object_store: Option<ObjectStore>,
    // Non-formalizing relationships
}

impl ImplementationBlock {
    #[proxy(store = "lu_dog", object = "Implementation Block", func = "new")]
    fn new(model_type: Option<Struct>, object_store: Option<ObjectStore>) -> Self;

    #[proxy(store = "lu_dog", object = "Implementation Block", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("An Implementation Block\n");
        print("\n");
        print("Inside this block functions are defined on a [`ModellType`].\n");
        print("\n");
    }

    fn info() -> () {
        print("struct ImplementationBlock {\n");
        print("    id: Uuid,\n");
        print("    model_type: Option<Struct>,\n");
        print("    object_store: Option<ObjectStore>,\n");
        print("}\n");
    }
}

// An Import of a foreign ObjectStore
// 
// This indicates to the downstream model compiler that it needs to emit code to load the imported
//  ObjectStore.
// 
// I've got this has_alias boolean here because I don't have `Option<String>`. I never needed
//  it until now, because you get an option with a 1c relationship. Not proud of this, but it's
//  the best alternative. Makes me wonder about adding an `Option` type to the primitives though
// .
// 
// I suppose if there were a way to signify a null string. Or I could check if it's length
//  is 0. I think adding the bool is cleaner.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Import" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Import")]
struct Import {
    alias: string,
    has_alias: bool,
    id: Uuid,
    name: string,
    x_path: string,
    object: Option<Object>,
    // Non-formalizing relationships
}

impl Import {
    #[proxy(store = "lu_dog", object = "Import", func = "new")]
    fn new(alias: string, has_alias: bool, name: string, x_path: string, object: Option<Object>) -> Self;

    #[proxy(store = "lu_dog", object = "Import", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("An Import of a foreign ObjectStore\n");
        print("\n");
        print("This indicates to the downstream model compiler that it needs to emit code to load the imported\n");
        print(" ObjectStore.\n");
        print("\n");
        print("I've got this has_alias boolean here because I don't have `Option<String>`. I never needed\n");
        print(" it until now, because you get an option with a 1c relationship. Not proud of this, but it's\n");
        print(" the best alternative. Makes me wonder about adding an `Option` type to the primitives though\n");
        print(".\n");
        print("\n");
        print("I suppose if there were a way to signify a null string. Or I could check if it's length\n");
        print(" is 0. I think adding the bool is cleaner.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Import {\n");
        print("    alias: string,\n");
        print("    has_alias: bool,\n");
        print("    id: Uuid,\n");
        print("    name: string,\n");
        print("    x_path: string,\n");
        print("    object: Option<Object>,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "Inclusive" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Inclusive")]
struct Inclusive {
    id: Uuid,
    // Non-formalizing relationships
}

impl Inclusive {
    #[proxy(store = "lu_dog", object = "Inclusive", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Inclusive", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct Inclusive {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// An index expression
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Index" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Index")]
struct Index {
    id: Uuid,
    index: Expression,
    target: Expression,
    // Non-formalizing relationships
}

impl Index {
    #[proxy(store = "lu_dog", object = "Index", func = "new")]
    fn new(index: Expression, target: Expression) -> Self;

    #[proxy(store = "lu_dog", object = "Index", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("An index expression\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Index {\n");
        print("    id: Uuid,\n");
        print("    index: Expression,\n");
        print("    target: Expression,\n");
        print("}\n");
    }
}

// An Integer
// 
// I'm not sure what to do about width. I think I coded it as an i64 in the parser.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "IntegerLiteral" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Integer Literal")]
struct IntegerLiteral {
    id: Uuid,
    x_value: int,
    // Non-formalizing relationships
}

impl IntegerLiteral {
    #[proxy(store = "lu_dog", object = "Integer Literal", func = "new")]
    fn new(x_value: int) -> Self;

    #[proxy(store = "lu_dog", object = "Integer Literal", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("An Integer\n");
        print("\n");
        print("I'm not sure what to do about width. I think I coded it as an i64 in the parser.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct IntegerLiteral {\n");
        print("    id: Uuid,\n");
        print("    x_value: int,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "Item" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Item")]
struct Item {
    id: Uuid,
    source: DwarfSourceFile,
    // Non-formalizing relationships
}

impl Item {
    #[proxy(store = "lu_dog", object = "Item", func = "new_enumeration")]
    fn new_enumeration(source: DwarfSourceFile, enumeration: Enumeration
) -> Self;

    #[proxy(store = "lu_dog", object = "Item", func = "new_function")]
    fn new_function(source: DwarfSourceFile, function: Function
) -> Self;

    #[proxy(store = "lu_dog", object = "Item", func = "new_implementation_block")]
    fn new_implementation_block(source: DwarfSourceFile, implementation_block: ImplementationBlock
) -> Self;

    #[proxy(store = "lu_dog", object = "Item", func = "new_import")]
    fn new_import(source: DwarfSourceFile, import: Import
) -> Self;

    #[proxy(store = "lu_dog", object = "Item", func = "new_x_macro")]
    fn new_x_macro(source: DwarfSourceFile, x_macro: Macro
) -> Self;

    #[proxy(store = "lu_dog", object = "Item", func = "new_woog_struct")]
    fn new_woog_struct(source: DwarfSourceFile, woog_struct: Struct
) -> Self;

    #[proxy(store = "lu_dog", object = "Item", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct Item {\n");
        print("    id: Uuid,\n");
        print("    source: DwarfSourceFile,\n");
        print("}\n");
    }
}

// An Item in statement position, i.e., inside of a block.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "ItemStatement" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Item Statement")]
struct ItemStatement {
    id: Uuid,
    // Non-formalizing relationships
}

impl ItemStatement {
    #[proxy(store = "lu_dog", object = "Item Statement", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Item Statement", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("An Item in statement position, i.e., inside of a block.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct ItemStatement {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// Lambda Function
// 
// It’s a function, it has a type, parameters, etc. It does not have a name, which is problematic
//  with Function having one. It’s also an Expression, unlike a Function.
// 
// I should think about creating another function subtype that contains just the name...
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Lambda" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Lambda")]
struct Lambda {
    id: Uuid,
    body: Option<Body>,
    first_param: Option<LambdaParameter>,
    return_type: ValueType,
    // Non-formalizing relationships
}

impl Lambda {
    #[proxy(store = "lu_dog", object = "Lambda", func = "new")]
    fn new(body: Option<Body>, first_param: Option<LambdaParameter>, return_type: ValueType) -> Self;

    #[proxy(store = "lu_dog", object = "Lambda", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("Lambda Function\n");
        print("\n");
        print("It’s a function, it has a type, parameters, etc. It does not have a name, which is problematic\n");
        print(" with Function having one. It’s also an Expression, unlike a Function.\n");
        print("\n");
        print("I should think about creating another function subtype that contains just the name...\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Lambda {\n");
        print("    id: Uuid,\n");
        print("    body: Option<Body>,\n");
        print("    first_param: Option<LambdaParameter>,\n");
        print("    return_type: ValueType,\n");
        print("}\n");
    }
}

// id
// 
// This tells the interpreter that this struct is a proxy for an object called
// "LambdaParameter" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Lambda Parameter")]
struct LambdaParameter {
    id: Uuid,
    position: int,
    lambda: Lambda,
    next: Option<LambdaParameter>,
    ty: Option<ValueType>,
    // Non-formalizing relationships
}

impl LambdaParameter {
    #[proxy(store = "lu_dog", object = "Lambda Parameter", func = "new")]
    fn new(position: int, lambda: Lambda, next: Option<LambdaParameter>, ty: Option<ValueType>) -> Self;

    #[proxy(store = "lu_dog", object = "Lambda Parameter", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("id\n");
        print("\n");
    }

    fn info() -> () {
        print("struct LambdaParameter {\n");
        print("    id: Uuid,\n");
        print("    position: int,\n");
        print("    lambda: Lambda,\n");
        print("    next: Option<LambdaParameter>,\n");
        print("    ty: Option<ValueType>,\n");
        print("}\n");
    }
}

// Less that operator `<`
// 
// 
// This tells the interpreter that this struct is a proxy for an object called
// "LessThan" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Less Than")]
struct LessThan {
    id: Uuid,
    // Non-formalizing relationships
}

impl LessThan {
    #[proxy(store = "lu_dog", object = "Less Than", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Less Than", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("Less that operator `<`\n");
        print("\n");
        print("\n");
    }

    fn info() -> () {
        print("struct LessThan {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// Less than or equal: `<=`.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "LessThanOrEqual" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Less Than or Equal")]
struct LessThanOrEqual {
    id: Uuid,
    // Non-formalizing relationships
}

impl LessThanOrEqual {
    #[proxy(store = "lu_dog", object = "Less Than or Equal", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Less Than or Equal", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("Less than or equal: `<=`.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct LessThanOrEqual {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// A Let Statement
// 
// This statement assigns a value from an expression to a local variable.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "LetStatement" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Let Statement")]
struct LetStatement {
    id: Uuid,
    expression: Expression,
    variable: LocalVariable,
    // Non-formalizing relationships
}

impl LetStatement {
    #[proxy(store = "lu_dog", object = "Let Statement", func = "new")]
    fn new(expression: Expression, variable: LocalVariable) -> Self;

    #[proxy(store = "lu_dog", object = "Let Statement", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A Let Statement\n");
        print("\n");
        print("This statement assigns a value from an expression to a local variable.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct LetStatement {\n");
        print("    id: Uuid,\n");
        print("    expression: Expression,\n");
        print("    variable: LocalVariable,\n");
        print("}\n");
    }
}

// A List
// 
// This is like an array, I guess. It's also like a `Vec<T>`.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "List" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "List")]
struct List {
    id: Uuid,
    ty: ValueType,
    // Non-formalizing relationships
}

impl List {
    #[proxy(store = "lu_dog", object = "List", func = "new")]
    fn new(ty: ValueType) -> Self;

    #[proxy(store = "lu_dog", object = "List", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A List\n");
        print("\n");
        print("This is like an array, I guess. It's also like a `Vec<T>`.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct List {\n");
        print("    id: Uuid,\n");
        print("    ty: ValueType,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "ListElement" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "List Element")]
struct ListElement {
    id: Uuid,
    position: int,
    expression: Expression,
    next: Option<ListElement>,
    // Non-formalizing relationships
}

impl ListElement {
    #[proxy(store = "lu_dog", object = "List Element", func = "new")]
    fn new(position: int, expression: Expression, next: Option<ListElement>) -> Self;

    #[proxy(store = "lu_dog", object = "List Element", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct ListElement {\n");
        print("    id: Uuid,\n");
        print("    position: int,\n");
        print("    expression: Expression,\n");
        print("    next: Option<ListElement>,\n");
        print("}\n");
    }
}

// A list of expressions
// 
// E.g., `let a = [0, 1, 2, 3];`
// 
// This tells the interpreter that this struct is a proxy for an object called
// "ListExpression" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "List Expression")]
struct ListExpression {
    id: Uuid,
    elements: Option<ListElement>,
    // Non-formalizing relationships
}

impl ListExpression {
    #[proxy(store = "lu_dog", object = "List Expression", func = "new")]
    fn new(elements: Option<ListElement>) -> Self;

    #[proxy(store = "lu_dog", object = "List Expression", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A list of expressions\n");
        print("\n");
        print("E.g., `let a = [0, 1, 2, 3];`\n");
        print("\n");
    }

    fn info() -> () {
        print("struct ListExpression {\n");
        print("    id: Uuid,\n");
        print("    elements: Option<ListElement>,\n");
        print("}\n");
    }
}

// A Literal Expression
// 
// This is any literal value in the program.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Literal" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Literal")]
struct Literal {
    id: Uuid,
    // Non-formalizing relationships
}

impl Literal {
    #[proxy(store = "lu_dog", object = "Literal", func = "new_boolean_literal")]
    fn new_boolean_literal() -> Self;

    #[proxy(store = "lu_dog", object = "Literal", func = "new_float_literal")]
    fn new_float_literal() -> Self;

    #[proxy(store = "lu_dog", object = "Literal", func = "new_integer_literal")]
    fn new_integer_literal() -> Self;

    #[proxy(store = "lu_dog", object = "Literal", func = "new_string_literal")]
    fn new_string_literal() -> Self;

    #[proxy(store = "lu_dog", object = "Literal", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A Literal Expression\n");
        print("\n");
        print("This is any literal value in the program.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Literal {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// A Local Variable in a Block
// 
// Note that a variable is an "l-value", so it represents a specific memory location.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "LocalVariable" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Local Variable")]
struct LocalVariable {
    bug: Uuid,
    id: Uuid,
    // Non-formalizing relationships
}

impl LocalVariable {
    #[proxy(store = "lu_dog", object = "Local Variable", func = "new")]
    fn new(bug: Uuid) -> Self;

    #[proxy(store = "lu_dog", object = "Local Variable", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A Local Variable in a Block\n");
        print("\n");
        print("Note that a variable is an ”l-value”, so it represents a specific memory location.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct LocalVariable {\n");
        print("    bug: Uuid,\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// This is a macro
// 
// It sort of interesting that the way that we create a new macro is with a macro. So it’s
//  nice and recursive like that. The macro in question, will be none other than `macro_rules
// !`!.
// 
// OK, so that means something like this:
// 
// ```no-test
// macro_rules! `ident` {
//     ($[ ( | `ident`]<,)*>[,$ident]*) => {
//     }
// }
// ```
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Macro" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Macro")]
struct Macro {
    id: Uuid,
    name: string,
    // Non-formalizing relationships
}

impl Macro {
    #[proxy(store = "lu_dog", object = "Macro", func = "new")]
    fn new(name: string) -> Self;

    #[proxy(store = "lu_dog", object = "Macro", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("This is a macro\n");
        print("\n");
        print("It sort of interesting that the way that we create a new macro is with a macro. So it’s\n");
        print(" nice and recursive like that. The macro in question, will be none other than `macro_rules\n");
        print("!`!.\n");
        print("\n");
        print("OK, so that means something like this:\n");
        print("\n");
        print("```no-test\n");
        print("macro_rules! `ident` {\n");
        print("    ($[ ( | `ident`]<,)*>[,$ident]*) => {\n");
        print("    }\n");
        print("}\n");
        print("```\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Macro {\n");
        print("    id: Uuid,\n");
        print("    name: string,\n");
        print("}\n");
    }
}

// A macro invocation
// 
// A macro invocation is a string, followed by a bang (`!`), followed by parens and arguments
// .
// 
// This tells the interpreter that this struct is a proxy for an object called
// "MacroCall" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Macro Call")]
struct MacroCall {
    id: Uuid,
    // Non-formalizing relationships
}

impl MacroCall {
    #[proxy(store = "lu_dog", object = "Macro Call", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Macro Call", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A macro invocation\n");
        print("\n");
        print("A macro invocation is a string, followed by a bang (`!`), followed by parens and arguments\n");
        print(".\n");
        print("\n");
    }

    fn info() -> () {
        print("struct MacroCall {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// Match a pattern to a scrutinee and evaluate a branch based on the results.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Match" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Match")]
struct Match {
    id: Uuid,
    uniqueness_generator: Uuid,
    scrutinee: Expression,
    // Non-formalizing relationships
}

impl Match {
    #[proxy(store = "lu_dog", object = "Match", func = "new")]
    fn new(uniqueness_generator: Uuid, scrutinee: Expression) -> Self;

    #[proxy(store = "lu_dog", object = "Match", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("Match a pattern to a scrutinee and evaluate a branch based on the results.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Match {\n");
        print("    id: Uuid,\n");
        print("    uniqueness_generator: Uuid,\n");
        print("    scrutinee: Expression,\n");
        print("}\n");
    }
}

// A Method Call
// 
// This is when you call a function on an instance of a struct. The name attribute is the name
//  of the method.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "MethodCall" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Method Call")]
struct MethodCall {
    id: Uuid,
    name: string,
    // Non-formalizing relationships
}

impl MethodCall {
    #[proxy(store = "lu_dog", object = "Method Call", func = "new")]
    fn new(name: string) -> Self;

    #[proxy(store = "lu_dog", object = "Method Call", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A Method Call\n");
        print("\n");
        print("This is when you call a function on an instance of a struct. The name attribute is the name\n");
        print(" of the method.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct MethodCall {\n");
        print("    id: Uuid,\n");
        print("    name: string,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "Multiplication" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Multiplication")]
struct Multiplication {
    id: Uuid,
    // Non-formalizing relationships
}

impl Multiplication {
    #[proxy(store = "lu_dog", object = "Multiplication", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Multiplication", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct Multiplication {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "NamedFieldExpression" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Named Field Expression")]
struct NamedFieldExpression {
    id: Uuid,
    name: string,
    // Non-formalizing relationships
}

impl NamedFieldExpression {
    #[proxy(store = "lu_dog", object = "Named Field Expression", func = "new")]
    fn new(name: string) -> Self;

    #[proxy(store = "lu_dog", object = "Named Field Expression", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct NamedFieldExpression {\n");
        print("    id: Uuid,\n");
        print("    name: string,\n");
        print("}\n");
    }
}

// The unary minus
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Negation" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Negation")]
struct Negation {
    id: Uuid,
    // Non-formalizing relationships
}

impl Negation {
    #[proxy(store = "lu_dog", object = "Negation", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Negation", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("The unary minus\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Negation {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "Not" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Not")]
struct Not {
    id: Uuid,
    // Non-formalizing relationships
}

impl Not {
    #[proxy(store = "lu_dog", object = "Not", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Not", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct Not {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// The Not Equal Expression
// 
// This is the `!=` operator expression.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "NotEqual" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Not Equal")]
struct NotEqual {
    id: Uuid,
    // Non-formalizing relationships
}

impl NotEqual {
    #[proxy(store = "lu_dog", object = "Not Equal", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Not Equal", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("The Not Equal Expression\n");
        print("\n");
        print("This is the `!=` operator expression.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct NotEqual {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// A generated ObjectStore
// 
// This is the backing store for the structs.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "ObjectStore" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Object Store")]
struct ObjectStore {
    domain: string,
    id: Uuid,
    name: string,
    // Non-formalizing relationships
}

impl ObjectStore {
    #[proxy(store = "lu_dog", object = "Object Store", func = "new")]
    fn new(domain: string, name: string) -> Self;

    #[proxy(store = "lu_dog", object = "Object Store", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A generated ObjectStore\n");
        print("\n");
        print("This is the backing store for the structs.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct ObjectStore {\n");
        print("    domain: string,\n");
        print("    id: Uuid,\n");
        print("    name: string,\n");
        print("}\n");
    }
}

// The purpose of this object is to wrap `Object`. We need to be able to store a referential
//  attribute to the `ObjectStore`, and we can’t/don’t want to add that to `Object`.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "ObjectWrapper" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Object Wrapper")]
struct ObjectWrapper {
    id: Uuid,
    object: Object,
    z_store: ObjectStore,
    // Non-formalizing relationships
}

impl ObjectWrapper {
    #[proxy(store = "lu_dog", object = "Object Wrapper", func = "new")]
    fn new(object: Object, z_store: ObjectStore) -> Self;

    #[proxy(store = "lu_dog", object = "Object Wrapper", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("The purpose of this object is to wrap `Object`. We need to be able to store a referential\n");
        print(" attribute to the `ObjectStore`, and we can’t/don’t want to add that to `Object`.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct ObjectWrapper {\n");
        print("    id: Uuid,\n");
        print("    object: Object,\n");
        print("    z_store: ObjectStore,\n");
        print("}\n");
    }
}

// Operator Expressions
// 
// Basically anything you can do with an expression is a subtype of this beasty.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Operator" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Operator")]
struct Operator {
    id: Uuid,
    lhs: Expression,
    rhs: Option<Expression>,
    // Non-formalizing relationships
}

impl Operator {
    #[proxy(store = "lu_dog", object = "Operator", func = "new_binary")]
    fn new_binary(lhs: Expression, rhs: Option<Expression>, binary: Binary
) -> Self;

    #[proxy(store = "lu_dog", object = "Operator", func = "new_comparison")]
    fn new_comparison(lhs: Expression, rhs: Option<Expression>, comparison: Comparison
) -> Self;

    #[proxy(store = "lu_dog", object = "Operator", func = "new_unary")]
    fn new_unary(lhs: Expression, rhs: Option<Expression>, unary: Unary
) -> Self;

    #[proxy(store = "lu_dog", object = "Operator", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("Operator Expressions\n");
        print("\n");
        print("Basically anything you can do with an expression is a subtype of this beasty.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Operator {\n");
        print("    id: Uuid,\n");
        print("    lhs: Expression,\n");
        print("    rhs: Option<Expression>,\n");
        print("}\n");
    }
}

// The or `||` operator
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Or" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Or")]
struct Or {
    id: Uuid,
    // Non-formalizing relationships
}

impl Or {
    #[proxy(store = "lu_dog", object = "Or", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Or", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("The or `||` operator\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Or {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// A Parameter to a Function
// 
// From inside the function it's a parameter, from outside it's an argument. No idea why I
//  wrote that — just looking for content...  I mean, what else do you say about a parameter
// ?
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Parameter" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Parameter")]
struct Parameter {
    id: Uuid,
    position: int,
    function: Function,
    next: Option<Parameter>,
    ty: ValueType,
    // Non-formalizing relationships
}

impl Parameter {
    #[proxy(store = "lu_dog", object = "Parameter", func = "new")]
    fn new(position: int, function: Function, next: Option<Parameter>, ty: ValueType) -> Self;

    #[proxy(store = "lu_dog", object = "Parameter", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A Parameter to a Function\n");
        print("\n");
        print("From inside the function it's a parameter, from outside it's an argument. No idea why I\n");
        print(" wrote that — just looking for content...  I mean, what else do you say about a parameter\n");
        print("?\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Parameter {\n");
        print("    id: Uuid,\n");
        print("    position: int,\n");
        print("    function: Function,\n");
        print("    next: Option<Parameter>,\n");
        print("    ty: ValueType,\n");
        print("}\n");
    }
}

// This is a path to a local variable, or an item. It is made up of scopes, separated by `
// ::`.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Path" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Path")]
struct Path {
    id: Uuid,
    unique: Uuid,
    first: Option<PathElement>,
    // Non-formalizing relationships
}

impl Path {
    #[proxy(store = "lu_dog", object = "Path", func = "new")]
    fn new(unique: Uuid, first: Option<PathElement>) -> Self;

    #[proxy(store = "lu_dog", object = "Path", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("This is a path to a local variable, or an item. It is made up of scopes, separated by `\n");
        print("::`.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Path {\n");
        print("    id: Uuid,\n");
        print("    unique: Uuid,\n");
        print("    first: Option<PathElement>,\n");
        print("}\n");
    }
}

// 🖕🤣
// 
// This tells the interpreter that this struct is a proxy for an object called
// "PathElement" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Path Element")]
struct PathElement {
    id: Uuid,
    name: string,
    next: Option<PathElement>,
    x_path: Path,
    // Non-formalizing relationships
}

impl PathElement {
    #[proxy(store = "lu_dog", object = "Path Element", func = "new")]
    fn new(name: string, next: Option<PathElement>, x_path: Path) -> Self;

    #[proxy(store = "lu_dog", object = "Path Element", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("🖕🤣\n");
        print("\n");
    }

    fn info() -> () {
        print("struct PathElement {\n");
        print("    id: Uuid,\n");
        print("    name: string,\n");
        print("    next: Option<PathElement>,\n");
        print("    x_path: Path,\n");
        print("}\n");
    }
}

// The pattern is a specification for extracting data from a type. It’s sort of a reverse
//  impression of what you are looking for. If the shape of the impression matches the scrutinee
// , then they “fit” and the pattern’s lvalues will be populated with data from the scrutinee
// .
// 
// There are a bunch of diffirent kinds of patterns. Literal, ident, struct, tuple, etc. Modeling
//  this will take a lot of room and time.
// 
// Doing this I’m going to cheat a bit and store the code that does matching as a string
//  on this object during compilation. During runtime the string will be evaluated (either as
//  dwrf, or perhasps using a small VM. Or maybe use the built-in VM. It should be able to handle
//  all that we need. This way, I don’t have to model all the bits because they are encoded
//  in the code attribute.
// 
// So I guess that means I’ll be writing assembly code...
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Pattern" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Pattern")]
struct Pattern {
    id: Uuid,
    expression: Expression,
    match_expr: Expression,
    x_match: Match,
    // Non-formalizing relationships
}

impl Pattern {
    #[proxy(store = "lu_dog", object = "Pattern", func = "new")]
    fn new(expression: Expression, match_expr: Expression, x_match: Match) -> Self;

    #[proxy(store = "lu_dog", object = "Pattern", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("The pattern is a specification for extracting data from a type. It’s sort of a reverse\n");
        print(" impression of what you are looking for. If the shape of the impression matches the scrutinee\n");
        print(", then they “fit” and the pattern’s lvalues will be populated with data from the scrutinee\n");
        print(".\n");
        print("\n");
        print("There are a bunch of diffirent kinds of patterns. Literal, ident, struct, tuple, etc. Modeling\n");
        print(" this will take a lot of room and time.\n");
        print("\n");
        print("Doing this I’m going to cheat a bit and store the code that does matching as a string\n");
        print(" on this object during compilation. During runtime the string will be evaluated (either as\n");
        print(" dwrf, or perhasps using a small VM. Or maybe use the built-in VM. It should be able to handle\n");
        print(" all that we need. This way, I don’t have to model all the bits because they are encoded\n");
        print(" in the code attribute.\n");
        print("\n");
        print("So I guess that means I’ll be writing assembly code...\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Pattern {\n");
        print("    id: Uuid,\n");
        print("    expression: Expression,\n");
        print("    match_expr: Expression,\n");
        print("    x_match: Match,\n");
        print("}\n");
    }
}

// An external compilation unit that may be loaded at run time.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Plugin" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Plugin")]
struct Plugin {
    id: Uuid,
    name: string,
    // Non-formalizing relationships
}

impl Plugin {
    #[proxy(store = "lu_dog", object = "Plugin", func = "new")]
    fn new(name: string) -> Self;

    #[proxy(store = "lu_dog", object = "Plugin", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("An external compilation unit that may be loaded at run time.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Plugin {\n");
        print("    id: Uuid,\n");
        print("    name: string,\n");
        print("}\n");
    }
}

// A Print Expression?
// 
// Shold this be a statement?
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Print" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Print")]
struct Print {
    id: Uuid,
    expression: Expression,
    // Non-formalizing relationships
}

impl Print {
    #[proxy(store = "lu_dog", object = "Print", func = "new")]
    fn new(expression: Expression) -> Self;

    #[proxy(store = "lu_dog", object = "Print", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A Print Expression?\n");
        print("\n");
        print("Shold this be a statement?\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Print {\n");
        print("    id: Uuid,\n");
        print("    expression: Expression,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "Range" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Range")]
struct Range {
    id: Uuid,
    // Non-formalizing relationships
}

impl Range {
    #[proxy(store = "lu_dog", object = "Range", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Range", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct Range {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "RangeExpression" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Range Expression")]
struct RangeExpression {
    id: Uuid,
    lhs: Option<Expression>,
    rhs: Option<Expression>,
    // Non-formalizing relationships
}

impl RangeExpression {
    #[proxy(store = "lu_dog", object = "Range Expression", func = "new_from")]
    fn new_from(lhs: Option<Expression>, rhs: Option<Expression>, from: From
) -> Self;

    #[proxy(store = "lu_dog", object = "Range Expression", func = "new_full")]
    fn new_full(lhs: Option<Expression>, rhs: Option<Expression>, full: Full
) -> Self;

    #[proxy(store = "lu_dog", object = "Range Expression", func = "new_inclusive")]
    fn new_inclusive(lhs: Option<Expression>, rhs: Option<Expression>, inclusive: Inclusive
) -> Self;

    #[proxy(store = "lu_dog", object = "Range Expression", func = "new_to")]
    fn new_to(lhs: Option<Expression>, rhs: Option<Expression>, to: To
) -> Self;

    #[proxy(store = "lu_dog", object = "Range Expression", func = "new_to_inclusive")]
    fn new_to_inclusive(lhs: Option<Expression>, rhs: Option<Expression>, to_inclusive: ToInclusive
) -> Self;

    #[proxy(store = "lu_dog", object = "Range Expression", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct RangeExpression {\n");
        print("    id: Uuid,\n");
        print("    lhs: Option<Expression>,\n");
        print("    rhs: Option<Expression>,\n");
        print("}\n");
    }
}

// An Expression Statement that is not terminated by a semi-colon, and this yields a result
// . This is only applicable if it's the last statement in a block.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "ResultStatement" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Result Statement")]
struct ResultStatement {
    id: Uuid,
    expression: Expression,
    // Non-formalizing relationships
}

impl ResultStatement {
    #[proxy(store = "lu_dog", object = "Result Statement", func = "new")]
    fn new(expression: Expression) -> Self;

    #[proxy(store = "lu_dog", object = "Result Statement", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("An Expression Statement that is not terminated by a semi-colon, and this yields a result\n");
        print(". This is only applicable if it's the last statement in a block.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct ResultStatement {\n");
        print("    id: Uuid,\n");
        print("    expression: Expression,\n");
        print("}\n");
    }
}

// The Return Expression
// 
// It’s an expression, and not a statement. Isn’t that interesting?
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Return" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Return")]
struct Return {
    id: Uuid,
    expression: Expression,
    // Non-formalizing relationships
}

impl Return {
    #[proxy(store = "lu_dog", object = "Return", func = "new")]
    fn new(expression: Expression) -> Self;

    #[proxy(store = "lu_dog", object = "Return", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("The Return Expression\n");
        print("\n");
        print("It’s an expression, and not a statement. Isn’t that interesting?\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Return {\n");
        print("    id: Uuid,\n");
        print("    expression: Expression,\n");
        print("}\n");
    }
}

// A span is just a two-tuple that specifies the start and end locations, in the source code
// , for an entitiy.
// 
// Looking at this, I think that this should be a supertype, and then a subtype for each relationship
// . I’m feeling lazy.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Span" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Span")]
struct Span {
    end: int,
    id: Uuid,
    start: int,
    source: DwarfSourceFile,
    ty: Option<ValueType>,
    x_value: Option<Value>,
    // Non-formalizing relationships
}

impl Span {
    #[proxy(store = "lu_dog", object = "Span", func = "new")]
    fn new(end: int, start: int, source: DwarfSourceFile, ty: Option<ValueType>, x_value: Option<Value>) -> Self;

    #[proxy(store = "lu_dog", object = "Span", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A span is just a two-tuple that specifies the start and end locations, in the source code\n");
        print(", for an entitiy.\n");
        print("\n");
        print("Looking at this, I think that this should be a supertype, and then a subtype for each relationship\n");
        print(". I’m feeling lazy.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Span {\n");
        print("    end: int,\n");
        print("    id: Uuid,\n");
        print("    start: int,\n");
        print("    source: DwarfSourceFile,\n");
        print("    ty: Option<ValueType>,\n");
        print("    x_value: Option<Value>,\n");
        print("}\n");
    }
}

// A Statement
// 
// A statement is followed by a semi-colon (`;`), and in general yields no value.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Statement" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Statement")]
struct Statement {
    id: Uuid,
    index: int,
    block: Block,
    next: Option<Statement>,
    // Non-formalizing relationships
}

impl Statement {
    #[proxy(store = "lu_dog", object = "Statement", func = "new_expression_statement")]
    fn new_expression_statement(index: int, block: Block, next: Option<Statement>, expression_statement: ExpressionStatement
) -> Self;

    #[proxy(store = "lu_dog", object = "Statement", func = "new_item_statement")]
    fn new_item_statement(index: int, block: Block, next: Option<Statement>, item_statement: ItemStatement
) -> Self;

    #[proxy(store = "lu_dog", object = "Statement", func = "new_let_statement")]
    fn new_let_statement(index: int, block: Block, next: Option<Statement>, let_statement: LetStatement
) -> Self;

    #[proxy(store = "lu_dog", object = "Statement", func = "new_result_statement")]
    fn new_result_statement(index: int, block: Block, next: Option<Statement>, result_statement: ResultStatement
) -> Self;

    #[proxy(store = "lu_dog", object = "Statement", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A Statement\n");
        print("\n");
        print("A statement is followed by a semi-colon (`;`), and in general yields no value.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Statement {\n");
        print("    id: Uuid,\n");
        print("    index: int,\n");
        print("    block: Block,\n");
        print("    next: Option<Statement>,\n");
        print("}\n");
    }
}

// A Static Method Call
// 
// This is when you call a function on the type (struct) itself. There is no instance involved
//  in this, although it may return an instance.
// 
// The name attribute is the name of the static method.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "StaticMethodCall" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Static Method Call")]
struct StaticMethodCall {
    func: string,
    id: Uuid,
    ty: string,
    unique: Uuid,
    // Non-formalizing relationships
}

impl StaticMethodCall {
    #[proxy(store = "lu_dog", object = "Static Method Call", func = "new")]
    fn new(func: string, ty: string, unique: Uuid) -> Self;

    #[proxy(store = "lu_dog", object = "Static Method Call", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A Static Method Call\n");
        print("\n");
        print("This is when you call a function on the type (struct) itself. There is no instance involved\n");
        print(" in this, although it may return an instance.\n");
        print("\n");
        print("The name attribute is the name of the static method.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct StaticMethodCall {\n");
        print("    func: string,\n");
        print("    id: Uuid,\n");
        print("    ty: string,\n");
        print("    unique: Uuid,\n");
        print("}\n");
    }
}

// A String
// 
// A string is a set of characters enclosed in double quotes. Strings are unicode strings encoded
//  as UTF-8.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "StringLiteral" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "String Literal")]
struct StringLiteral {
    id: Uuid,
    x_value: string,
    // Non-formalizing relationships
}

impl StringLiteral {
    #[proxy(store = "lu_dog", object = "String Literal", func = "new")]
    fn new(x_value: string) -> Self;

    #[proxy(store = "lu_dog", object = "String Literal", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A String\n");
        print("\n");
        print("A string is a set of characters enclosed in double quotes. Strings are unicode strings encoded\n");
        print(" as UTF-8.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct StringLiteral {\n");
        print("    id: Uuid,\n");
        print("    x_value: string,\n");
        print("}\n");
    }
}

// A Type from the Model
// 
// This is really just an alias for `[Object]`.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Struct" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Struct")]
struct Struct {
    id: Uuid,
    name: string,
    first_generic: Option<StructGeneric>,
    object: Option<Object>,
    // Non-formalizing relationships
}

impl Struct {
    #[proxy(store = "lu_dog", object = "Struct", func = "new")]
    fn new(name: string, first_generic: Option<StructGeneric>, object: Option<Object>) -> Self;

    #[proxy(store = "lu_dog", object = "Struct", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A Type from the Model\n");
        print("\n");
        print("This is really just an alias for `[Object]`.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Struct {\n");
        print("    id: Uuid,\n");
        print("    name: string,\n");
        print("    first_generic: Option<StructGeneric>,\n");
        print("    object: Option<Object>,\n");
        print("}\n");
    }
}

// A Structure Expression
// 
// This is how we create instances in dwarf.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "StructExpression" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Struct Expression")]
struct StructExpression {
    bug: Uuid,
    id: Uuid,
    data: DataStructure,
    x_path: Path,
    // Non-formalizing relationships
}

impl StructExpression {
    #[proxy(store = "lu_dog", object = "Struct Expression", func = "new")]
    fn new(bug: Uuid, data: DataStructure, x_path: Path) -> Self;

    #[proxy(store = "lu_dog", object = "Struct Expression", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A Structure Expression\n");
        print("\n");
        print("This is how we create instances in dwarf.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct StructExpression {\n");
        print("    bug: Uuid,\n");
        print("    id: Uuid,\n");
        print("    data: DataStructure,\n");
        print("    x_path: Path,\n");
        print("}\n");
    }
}

// A field that is a structure.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "StructField" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Struct Field")]
struct StructField {
    id: Uuid,
    name: string,
    // Non-formalizing relationships
}

impl StructField {
    #[proxy(store = "lu_dog", object = "Struct Field", func = "new")]
    fn new(name: string) -> Self;

    #[proxy(store = "lu_dog", object = "Struct Field", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A field that is a structure.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct StructField {\n");
        print("    id: Uuid,\n");
        print("    name: string,\n");
        print("}\n");
    }
}

// A generic type applied to the struct.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "StructGeneric" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Struct Generic")]
struct StructGeneric {
    id: Uuid,
    name: string,
    next: Option<StructGeneric>,
    woog_struct: Struct,
    // Non-formalizing relationships
}

impl StructGeneric {
    #[proxy(store = "lu_dog", object = "Struct Generic", func = "new")]
    fn new(name: string, next: Option<StructGeneric>, woog_struct: Struct) -> Self;

    #[proxy(store = "lu_dog", object = "Struct Generic", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A generic type applied to the struct.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct StructGeneric {\n");
        print("    id: Uuid,\n");
        print("    name: string,\n");
        print("    next: Option<StructGeneric>,\n");
        print("    woog_struct: Struct,\n");
        print("}\n");
    }
}

// The subtraction operator: `-`.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Subtraction" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Subtraction")]
struct Subtraction {
    id: Uuid,
    // Non-formalizing relationships
}

impl Subtraction {
    #[proxy(store = "lu_dog", object = "Subtraction", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Subtraction", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("The subtraction operator: `-`.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Subtraction {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// A type to contain a task.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Task" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Task")]
struct Task {
    id: Uuid,
    // Non-formalizing relationships
}

impl Task {
    #[proxy(store = "lu_dog", object = "Task", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Task", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A type to contain a task.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Task {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "To" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "To")]
struct To {
    id: Uuid,
    // Non-formalizing relationships
}

impl To {
    #[proxy(store = "lu_dog", object = "To", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "To", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct To {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "ToInclusive" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "To Inclusive")]
struct ToInclusive {
    id: Uuid,
    // Non-formalizing relationships
}

impl ToInclusive {
    #[proxy(store = "lu_dog", object = "To Inclusive", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "To Inclusive", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct ToInclusive {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// True Literal
// 
// The literal `true`.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "True" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "True")]
struct True {
    id: Uuid,
    // Non-formalizing relationships
}

impl True {
    #[proxy(store = "lu_dog", object = "True", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "True", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("True Literal\n");
        print("\n");
        print("The literal `true`.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct True {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// A field that is a tuple.
// 
// Currently in this implementation we are cheating, as we don’t yet actually have tuples
// . So this is limited to a single item.
// 
// Note the `hack` attribute. What’s happening is that during generic substitution?, expansion
// ?, whatever. During that we are cloning the enum, and it’s fields. This is to create a
//  new type. When we do this we don’t want the store optimizing away a duplicate Tuple Field
// .
// 
// I deb thee hack because I think the right thing to do is something else, I’m just not
//  sure what it is yet.
// 
// I renamed it to `xyzzy`, because I think `hack` does magic in the compiler.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "TupleField" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Tuple Field")]
struct TupleField {
    id: Uuid,
    xyzzy: Uuid,
    ty: ValueType,
    // Non-formalizing relationships
}

impl TupleField {
    #[proxy(store = "lu_dog", object = "Tuple Field", func = "new")]
    fn new(xyzzy: Uuid, ty: ValueType) -> Self;

    #[proxy(store = "lu_dog", object = "Tuple Field", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A field that is a tuple.\n");
        print("\n");
        print("Currently in this implementation we are cheating, as we don’t yet actually have tuples\n");
        print(". So this is limited to a single item.\n");
        print("\n");
        print("Note the `hack` attribute. What’s happening is that during generic substitution?, expansion\n");
        print("?, whatever. During that we are cloning the enum, and it’s fields. This is to create a\n");
        print(" new type. When we do this we don’t want the store optimizing away a duplicate Tuple Field\n");
        print(".\n");
        print("\n");
        print("I deb thee hack because I think the right thing to do is something else, I’m just not\n");
        print(" sure what it is yet.\n");
        print("\n");
        print("I renamed it to `xyzzy`, because I think `hack` does magic in the compiler.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct TupleField {\n");
        print("    id: Uuid,\n");
        print("    xyzzy: Uuid,\n");
        print("    ty: ValueType,\n");
        print("}\n");
    }
}

// Typecast Operator Expression
// 
// This is the `as` operator.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "TypeCast" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Type Cast")]
struct TypeCast {
    id: Uuid,
    lhs: Expression,
    ty: ValueType,
    // Non-formalizing relationships
}

impl TypeCast {
    #[proxy(store = "lu_dog", object = "Type Cast", func = "new")]
    fn new(lhs: Expression, ty: ValueType) -> Self;

    #[proxy(store = "lu_dog", object = "Type Cast", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("Typecast Operator Expression\n");
        print("\n");
        print("This is the `as` operator.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct TypeCast {\n");
        print("    id: Uuid,\n");
        print("    lhs: Expression,\n");
        print("    ty: ValueType,\n");
        print("}\n");
    }
}

// Unary Operators
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Unary" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Unary")]
struct Unary {
    id: Uuid,
    // Non-formalizing relationships
}

impl Unary {
    #[proxy(store = "lu_dog", object = "Unary", func = "new_negation")]
    fn new_negation() -> Self;

    #[proxy(store = "lu_dog", object = "Unary", func = "new_not")]
    fn new_not() -> Self;

    #[proxy(store = "lu_dog", object = "Unary", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("Unary Operators\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Unary {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// Just a marker, no other value.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Unit" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Unit")]
struct Unit {
    id: Uuid,
    x_value: int,
    // Non-formalizing relationships
}

impl Unit {
    #[proxy(store = "lu_dog", object = "Unit", func = "new")]
    fn new(x_value: int) -> Self;

    #[proxy(store = "lu_dog", object = "Unit", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("Just a marker, no other value.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Unit {\n");
        print("    id: Uuid,\n");
        print("    x_value: int,\n");
        print("}\n");
    }
}

// Unknown Type
// 
// The type is unknown.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Unknown" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Unknown")]
struct Unknown {
    id: Uuid,
    // Non-formalizing relationships
}

impl Unknown {
    #[proxy(store = "lu_dog", object = "Unknown", func = "new")]
    fn new() -> Self;

    #[proxy(store = "lu_dog", object = "Unknown", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("Unknown Type\n");
        print("\n");
        print("The type is unknown.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Unknown {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "UnnamedFieldExpression" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Unnamed Field Expression")]
struct UnnamedFieldExpression {
    id: Uuid,
    position: int,
    // Non-formalizing relationships
}

impl UnnamedFieldExpression {
    #[proxy(store = "lu_dog", object = "Unnamed Field Expression", func = "new")]
    fn new(position: int) -> Self;

    #[proxy(store = "lu_dog", object = "Unnamed Field Expression", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct UnnamedFieldExpression {\n");
        print("    id: Uuid,\n");
        print("    position: int,\n");
        print("}\n");
    }
}

// A Value
// 
// A value has a Type.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Value" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Value")]
struct Value {
    id: Uuid,
    block: Block,
    ty: ValueType,
    // Non-formalizing relationships
}

impl Value {
    #[proxy(store = "lu_dog", object = "Value", func = "new_expression")]
    fn new_expression(block: Block, ty: ValueType, expression: Expression
) -> Self;

    #[proxy(store = "lu_dog", object = "Value", func = "new_variable")]
    fn new_variable(block: Block, ty: ValueType, variable: Variable
) -> Self;

    #[proxy(store = "lu_dog", object = "Value", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A Value\n");
        print("\n");
        print("A value has a Type.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Value {\n");
        print("    id: Uuid,\n");
        print("    block: Block,\n");
        print("    ty: ValueType,\n");
        print("}\n");
    }
}

// Value Type
// 
// This is the main type abstraction used in Lu Dog. We mostly rely on what is available in
//  Sarzak, with two additions: ...
// 
// Two? I know that I need an Option<>. I'm not so sure about a & though. Everything from the
//  store is going to be by UUID, so all of my references are really "pointers" underneath.
//  I want them to be typed in the code though.
// 
// So how will the code work? We could store the type next to the pointer: (type, uuid). Huh
// . This is the eventual output domain. How does that affect my thinking?
// 
// This should end up looking like woog, but simpler. Woog was for generating rust. I want
//  to generate dwarf. Dwarf needs to be typed? If so, when are they resolved to uuid's eventually
// ? 
// 
// Option for now. We'll see later...
// 
// This tells the interpreter that this struct is a proxy for an object called
// "ValueType" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Value Type")]
struct ValueType {
    id: Uuid,
    // Non-formalizing relationships
}

impl ValueType {
    #[proxy(store = "lu_dog", object = "Value Type", func = "new_char")]
    fn new_char() -> Self;

    #[proxy(store = "lu_dog", object = "Value Type", func = "new_empty")]
    fn new_empty() -> Self;

    #[proxy(store = "lu_dog", object = "Value Type", func = "new_enumeration")]
    fn new_enumeration() -> Self;

    #[proxy(store = "lu_dog", object = "Value Type", func = "new_function")]
    fn new_function() -> Self;

    #[proxy(store = "lu_dog", object = "Value Type", func = "new_x_future")]
    fn new_x_future() -> Self;

    #[proxy(store = "lu_dog", object = "Value Type", func = "new_generic")]
    fn new_generic() -> Self;

    #[proxy(store = "lu_dog", object = "Value Type", func = "new_import")]
    fn new_import() -> Self;

    #[proxy(store = "lu_dog", object = "Value Type", func = "new_lambda")]
    fn new_lambda() -> Self;

    #[proxy(store = "lu_dog", object = "Value Type", func = "new_list")]
    fn new_list() -> Self;

    #[proxy(store = "lu_dog", object = "Value Type", func = "new_z_object_store")]
    fn new_z_object_store() -> Self;

    #[proxy(store = "lu_dog", object = "Value Type", func = "new_x_plugin")]
    fn new_x_plugin() -> Self;

    #[proxy(store = "lu_dog", object = "Value Type", func = "new_range")]
    fn new_range() -> Self;

    #[proxy(store = "lu_dog", object = "Value Type", func = "new_woog_struct")]
    fn new_woog_struct() -> Self;

    #[proxy(store = "lu_dog", object = "Value Type", func = "new_task")]
    fn new_task() -> Self;

    #[proxy(store = "lu_dog", object = "Value Type", func = "new_ty")]
    fn new_ty() -> Self;

    #[proxy(store = "lu_dog", object = "Value Type", func = "new_unknown")]
    fn new_unknown() -> Self;

    #[proxy(store = "lu_dog", object = "Value Type", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("Value Type\n");
        print("\n");
        print("This is the main type abstraction used in Lu Dog. We mostly rely on what is available in\n");
        print(" Sarzak, with two additions: ...\n");
        print("\n");
        print("Two? I know that I need an Option<>. I'm not so sure about a & though. Everything from the\n");
        print(" store is going to be by UUID, so all of my references are really ”pointers” underneath\n");
        print(". I want them to be typed in the code though.\n");
        print("\n");
        print("So how will the code work? We could store the type next to the pointer: (type, uuid). Huh\n");
        print(". This is the eventual output domain. How does that affect my thinking?\n");
        print("\n");
        print("This should end up looking like woog, but simpler. Woog was for generating rust. I want\n");
        print(" to generate dwarf. Dwarf needs to be typed? If so, when are they resolved to uuid's eventually\n");
        print("? \n");
        print("\n");
        print("Option for now. We'll see later...\n");
        print("\n");
    }

    fn info() -> () {
        print("struct ValueType {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// A Variable
// 
// A variable in a function. It may be either a local variable or a parameter.
// 
// A variable has a name, and and indirectly, via [`Value`], a type.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Variable" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Variable")]
struct Variable {
    id: Uuid,
    name: string,
    // Non-formalizing relationships
}

impl Variable {
    #[proxy(store = "lu_dog", object = "Variable", func = "new_lambda_parameter")]
    fn new_lambda_parameter(name: string, lambda_parameter: LambdaParameter
) -> Self;

    #[proxy(store = "lu_dog", object = "Variable", func = "new_local_variable")]
    fn new_local_variable(name: string, local_variable: LocalVariable
) -> Self;

    #[proxy(store = "lu_dog", object = "Variable", func = "new_parameter")]
    fn new_parameter(name: string, parameter: Parameter
) -> Self;

    #[proxy(store = "lu_dog", object = "Variable", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A Variable\n");
        print("\n");
        print("A variable in a function. It may be either a local variable or a parameter.\n");
        print("\n");
        print("A variable has a name, and and indirectly, via [`Value`], a type.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Variable {\n");
        print("    id: Uuid,\n");
        print("    name: string,\n");
        print("}\n");
    }
}

// A Local Variable Expression
// 
// This is what happens when a variable is an r-value.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "VariableExpression" in the store named "lu_dog"; declared above.
#[proxy(store = "lu_dog", object = "Variable Expression")]
struct VariableExpression {
    id: Uuid,
    name: string,
    // Non-formalizing relationships
}

impl VariableExpression {
    #[proxy(store = "lu_dog", object = "Variable Expression", func = "new")]
    fn new(name: string) -> Self;

    #[proxy(store = "lu_dog", object = "Variable Expression", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A Local Variable Expression\n");
        print("\n");
        print("This is what happens when a variable is an r-value.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct VariableExpression {\n");
        print("    id: Uuid,\n");
        print("    name: string,\n");
        print("}\n");
    }
}

