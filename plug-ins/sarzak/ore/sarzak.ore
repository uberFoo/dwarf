// The _Metamodel_
// 
// This is the model of the model. From here all is generated...

use std::prelude::*;

// This annotation tells the interpreter that the struct will be a proxy for
// an `ObjectStore` called sarzak. It will find the plugin based on the name.
#[store(model = "sarzak")]
struct SarzakStore {}

// This is just to keep the type checking happy.
#[store(model = "sarzak")]
impl SarzakStore {
    // This is a function that exists on the ObjectStore, and the interpreter
    // will invoke it in the plugin.
    #[proxy(store = "sarzak", object = "ObjectStore", func = "new")]
    fn new() -> Self;
    #[proxy(store = "sarzak", object = "ObjectStore", func = "load")]
    fn load(path: string) -> Self;
    #[proxy(store = "sarzak", object = "ObjectStore", func = "persist")]
    fn save(self) -> Self;


    #[proxy(store = "sarzak", object = "ObjectStore", func = "inter_acknowledged_event")]
    fn inter_acknowledged_event(self, acknowledged_event: AcknowledgedEvent);
    #[proxy(store = "sarzak", object = "ObjectStore", func = "exhume_acknowledged_event")]
    fn exhume_acknowledged_event(self, acknowledged_event: Uuid) -> AcknowledgedEvent;

    #[proxy(store = "sarzak", object = "ObjectStore", func = "inter_an_associative_referent")]
    fn inter_an_associative_referent(self, an_associative_referent: AnAssociativeReferent);
    #[proxy(store = "sarzak", object = "ObjectStore", func = "exhume_an_associative_referent")]
    fn exhume_an_associative_referent(self, an_associative_referent: Uuid) -> AnAssociativeReferent;

    #[proxy(store = "sarzak", object = "ObjectStore", func = "inter_associative")]
    fn inter_associative(self, associative: Associative);
    #[proxy(store = "sarzak", object = "ObjectStore", func = "exhume_associative")]
    fn exhume_associative(self, associative: Uuid) -> Associative;

    #[proxy(store = "sarzak", object = "ObjectStore", func = "inter_associative_referent")]
    fn inter_associative_referent(self, associative_referent: AssociativeReferent);
    #[proxy(store = "sarzak", object = "ObjectStore", func = "exhume_associative_referent")]
    fn exhume_associative_referent(self, associative_referent: Uuid) -> AssociativeReferent;

    #[proxy(store = "sarzak", object = "ObjectStore", func = "inter_associative_referrer")]
    fn inter_associative_referrer(self, associative_referrer: AssociativeReferrer);
    #[proxy(store = "sarzak", object = "ObjectStore", func = "exhume_associative_referrer")]
    fn exhume_associative_referrer(self, associative_referrer: Uuid) -> AssociativeReferrer;

    #[proxy(store = "sarzak", object = "ObjectStore", func = "inter_attribute")]
    fn inter_attribute(self, attribute: Attribute);
    #[proxy(store = "sarzak", object = "ObjectStore", func = "exhume_attribute")]
    fn exhume_attribute(self, attribute: Uuid) -> Attribute;

    #[proxy(store = "sarzak", object = "ObjectStore", func = "inter_binary")]
    fn inter_binary(self, binary: Binary);
    #[proxy(store = "sarzak", object = "ObjectStore", func = "exhume_binary")]
    fn exhume_binary(self, binary: Uuid) -> Binary;

    #[proxy(store = "sarzak", object = "ObjectStore", func = "inter_cardinality")]
    fn inter_cardinality(self, cardinality: Cardinality);
    #[proxy(store = "sarzak", object = "ObjectStore", func = "exhume_cardinality")]
    fn exhume_cardinality(self, cardinality: Uuid) -> Cardinality;

    #[proxy(store = "sarzak", object = "ObjectStore", func = "inter_conditionality")]
    fn inter_conditionality(self, conditionality: Conditionality);
    #[proxy(store = "sarzak", object = "ObjectStore", func = "exhume_conditionality")]
    fn exhume_conditionality(self, conditionality: Uuid) -> Conditionality;

    #[proxy(store = "sarzak", object = "ObjectStore", func = "inter_event")]
    fn inter_event(self, event: Event);
    #[proxy(store = "sarzak", object = "ObjectStore", func = "exhume_event")]
    fn exhume_event(self, event: Uuid) -> Event;

    #[proxy(store = "sarzak", object = "ObjectStore", func = "inter_external")]
    fn inter_external(self, external: External);
    #[proxy(store = "sarzak", object = "ObjectStore", func = "exhume_external")]
    fn exhume_external(self, external: Uuid) -> External;

    #[proxy(store = "sarzak", object = "ObjectStore", func = "inter_isa")]
    fn inter_isa(self, isa: Isa);
    #[proxy(store = "sarzak", object = "ObjectStore", func = "exhume_isa")]
    fn exhume_isa(self, isa: Uuid) -> Isa;

    #[proxy(store = "sarzak", object = "ObjectStore", func = "inter_object")]
    fn inter_object(self, object: Object);
    #[proxy(store = "sarzak", object = "ObjectStore", func = "exhume_object")]
    fn exhume_object(self, object: Uuid) -> Object;

    #[proxy(store = "sarzak", object = "ObjectStore", func = "inter_referent")]
    fn inter_referent(self, referent: Referent);
    #[proxy(store = "sarzak", object = "ObjectStore", func = "exhume_referent")]
    fn exhume_referent(self, referent: Uuid) -> Referent;

    #[proxy(store = "sarzak", object = "ObjectStore", func = "inter_referrer")]
    fn inter_referrer(self, referrer: Referrer);
    #[proxy(store = "sarzak", object = "ObjectStore", func = "exhume_referrer")]
    fn exhume_referrer(self, referrer: Uuid) -> Referrer;

    #[proxy(store = "sarzak", object = "ObjectStore", func = "inter_relationship")]
    fn inter_relationship(self, relationship: Relationship);
    #[proxy(store = "sarzak", object = "ObjectStore", func = "exhume_relationship")]
    fn exhume_relationship(self, relationship: Uuid) -> Relationship;

    #[proxy(store = "sarzak", object = "ObjectStore", func = "inter_state")]
    fn inter_state(self, state: State);
    #[proxy(store = "sarzak", object = "ObjectStore", func = "exhume_state")]
    fn exhume_state(self, state: Uuid) -> State;

    #[proxy(store = "sarzak", object = "ObjectStore", func = "inter_subtype")]
    fn inter_subtype(self, subtype: Subtype);
    #[proxy(store = "sarzak", object = "ObjectStore", func = "exhume_subtype")]
    fn exhume_subtype(self, subtype: Uuid) -> Subtype;

    #[proxy(store = "sarzak", object = "ObjectStore", func = "inter_supertype")]
    fn inter_supertype(self, supertype: Supertype);
    #[proxy(store = "sarzak", object = "ObjectStore", func = "exhume_supertype")]
    fn exhume_supertype(self, supertype: Uuid) -> Supertype;

    #[proxy(store = "sarzak", object = "ObjectStore", func = "inter_ty")]
    fn inter_ty(self, ty: Type);
    #[proxy(store = "sarzak", object = "ObjectStore", func = "exhume_ty")]
    fn exhume_ty(self, ty: Uuid) -> Type;
}

// An Event that Does Something
// 
// An acknowledged event is an event that a [`State`] knows how to handle.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "AcknowledgedEvent" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "Acknowledged Event")]
struct AcknowledgedEvent {
    id: Uuid,
    event_id: Event,
    state_id: State,
    // Non-formalizing relationships
}

impl AcknowledgedEvent {
    #[proxy(store = "sarzak", object = "Acknowledged Event", func = "new")]
    fn new(event_id: Event, state_id: State) -> Self;

    #[proxy(store = "sarzak", object = "Acknowledged Event", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("An Event that Does Something\n");
        print("\n");
        print("An acknowledged event is an event that a [`State`] knows how to handle.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct AcknowledgedEvent {\n");
        print("    id: Uuid,\n");
        print("    event_id: Event,\n");
        print("    state_id: State,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "AnAssociativeReferent" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "An Associative Referent")]
struct AnAssociativeReferent {
    id: Uuid,
    referential_attribute: string,
    associative: Associative,
    referent: AssociativeReferent,
    // Non-formalizing relationships
}

impl AnAssociativeReferent {
    #[proxy(store = "sarzak", object = "An Associative Referent", func = "new")]
    fn new(referential_attribute: string, associative: Associative, referent: AssociativeReferent) -> Self;

    #[proxy(store = "sarzak", object = "An Associative Referent", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct AnAssociativeReferent {\n");
        print("    id: Uuid,\n");
        print("    referential_attribute: string,\n");
        print("    associative: Associative,\n");
        print("    referent: AssociativeReferent,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "Associative" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "Associative")]
struct Associative {
    id: Uuid,
    number: int,
    from: AssociativeReferrer,
    // Non-formalizing relationships
}

impl Associative {
    #[proxy(store = "sarzak", object = "Associative", func = "new")]
    fn new(number: int, from: AssociativeReferrer) -> Self;

    #[proxy(store = "sarzak", object = "Associative", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct Associative {\n");
        print("    id: Uuid,\n");
        print("    number: int,\n");
        print("    from: AssociativeReferrer,\n");
        print("}\n");
    }
}

// The other objects in an Associative Relationship
// 
// This represents one of the two objects that are related in an [`Associative`] relationhip
// . 
// 
// This tells the interpreter that this struct is a proxy for an object called
// "AssociativeReferent" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "Associative Referent")]
struct AssociativeReferent {
    description: string,
    id: Uuid,
    cardinality: Cardinality,
    conditionality: Conditionality,
    obj_id: Object,
    // Non-formalizing relationships
}

impl AssociativeReferent {
    #[proxy(store = "sarzak", object = "Associative Referent", func = "new")]
    fn new(description: string, cardinality: Cardinality, conditionality: Conditionality, obj_id: Object) -> Self;

    #[proxy(store = "sarzak", object = "Associative Referent", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("The other objects in an Associative Relationship\n");
        print("\n");
        print("This represents one of the two objects that are related in an [`Associative`] relationhip\n");
        print(". \n");
        print("\n");
    }

    fn info() -> () {
        print("struct AssociativeReferent {\n");
        print("    description: string,\n");
        print("    id: Uuid,\n");
        print("    cardinality: Cardinality,\n");
        print("    conditionality: Conditionality,\n");
        print("    obj_id: Object,\n");
        print("}\n");
    }
}

// Associative Object
// 
// This is used in an [`Associative`] relationship to point to the Associative object itself
// . It's the box with the line pointing at another line.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "AssociativeReferrer" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "Associative Referrer")]
struct AssociativeReferrer {
    id: Uuid,
    cardinality: Cardinality,
    obj_id: Object,
    // Non-formalizing relationships
}

impl AssociativeReferrer {
    #[proxy(store = "sarzak", object = "Associative Referrer", func = "new")]
    fn new(cardinality: Cardinality, obj_id: Object) -> Self;

    #[proxy(store = "sarzak", object = "Associative Referrer", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("Associative Object\n");
        print("\n");
        print("This is used in an [`Associative`] relationship to point to the Associative object itself\n");
        print(". It's the box with the line pointing at another line.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct AssociativeReferrer {\n");
        print("    id: Uuid,\n");
        print("    cardinality: Cardinality,\n");
        print("    obj_id: Object,\n");
        print("}\n");
    }
}

// An `Attribute` represents a single value. Each value must have a 
// [`Type`], which constrains the values of data that may be assigned to
// an `Attribute`.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Attribute" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "Attribute")]
struct Attribute {
    id: Uuid,
    name: string,
    obj_id: Object,
    ty: Type,
    // Non-formalizing relationships
}

impl Attribute {
    #[proxy(store = "sarzak", object = "Attribute", func = "new")]
    fn new(name: string, obj_id: Object, ty: Type) -> Self;

    #[proxy(store = "sarzak", object = "Attribute", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("An `Attribute` represents a single value. Each value must have a \n");
        print("[`Type`], which constrains the values of data that may be assigned to\n");
        print("an `Attribute`.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Attribute {\n");
        print("    id: Uuid,\n");
        print("    name: string,\n");
        print("    obj_id: Object,\n");
        print("    ty: Type,\n");
        print("}\n");
    }
}

// A `Binary` relationship, as itâ€™s name implies, is a relationship between
// two objects. It consists of two parts, the `Dependent` end of the 
// relationship and the `Independent` end.
// 
// The former is so named because it has the job of formalizing the
// relationship. It stores a pointer to the independent object as an attribute.
// 
// The latter is aware of the relationship, but it does not store any 
// information about the relationship. That said, there are means of
// traversing the relationship from the `Independent` object. 
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Binary" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "Binary")]
struct Binary {
    id: Uuid,
    number: int,
    from: Referrer,
    to: Referent,
    // Non-formalizing relationships
}

impl Binary {
    #[proxy(store = "sarzak", object = "Binary", func = "new")]
    fn new(number: int, from: Referrer, to: Referent) -> Self;

    #[proxy(store = "sarzak", object = "Binary", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A `Binary` relationship, as itâ€™s name implies, is a relationship between\n");
        print("two objects. It consists of two parts, the `Dependent` end of the \n");
        print("relationship and the `Independent` end.\n");
        print("\n");
        print("The former is so named because it has the job of formalizing the\n");
        print("relationship. It stores a pointer to the independent object as an attribute.\n");
        print("\n");
        print("The latter is aware of the relationship, but it does not store any \n");
        print("information about the relationship. That said, there are means of\n");
        print("traversing the relationship from the `Independent` object. \n");
        print("\n");
    }

    fn info() -> () {
        print("struct Binary {\n");
        print("    id: Uuid,\n");
        print("    number: int,\n");
        print("    from: Referrer,\n");
        print("    to: Referent,\n");
        print("}\n");
    }
}

// The Boolean Type
// 
// This type holds `true` and `false` values. This type is just a placeholder. It's implementation
//  is determined downstream by the code generator.
// 
// â—ï¸{"singleton_object": true}
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Boolean" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "Boolean")]
struct Boolean {
    id: Uuid,
    // Non-formalizing relationships
}

impl Boolean {
    #[proxy(store = "sarzak", object = "Boolean", func = "new")]
    fn new() -> Self;

    #[proxy(store = "sarzak", object = "Boolean", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("The Boolean Type\n");
        print("\n");
        print("This type holds `true` and `false` values. This type is just a placeholder. It's implementation\n");
        print(" is determined downstream by the code generator.\n");
        print("\n");
        print("â—ï¸{â€singleton_objectâ€: true}\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Boolean {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "Cardinality" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "Cardinality")]
struct Cardinality {
    id: Uuid,
    // Non-formalizing relationships
}

impl Cardinality {
    #[proxy(store = "sarzak", object = "Cardinality", func = "new_many")]
    fn new_many() -> Self;

    #[proxy(store = "sarzak", object = "Cardinality", func = "new_one")]
    fn new_one() -> Self;

    #[proxy(store = "sarzak", object = "Cardinality", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct Cardinality {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// A constant value that indicates a conditionality of _conditional_.
// 
// â—ï¸{"singleton_object": true}
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Conditional" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "Conditional")]
struct Conditional {
    id: Uuid,
    // Non-formalizing relationships
}

impl Conditional {
    #[proxy(store = "sarzak", object = "Conditional", func = "new")]
    fn new() -> Self;

    #[proxy(store = "sarzak", object = "Conditional", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A constant value that indicates a conditionality of _conditional_.\n");
        print("\n");
        print("â—ï¸{â€singleton_objectâ€: true}\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Conditional {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "Conditionality" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "Conditionality")]
struct Conditionality {
    id: Uuid,
    // Non-formalizing relationships
}

impl Conditionality {
    #[proxy(store = "sarzak", object = "Conditionality", func = "new_conditional")]
    fn new_conditional() -> Self;

    #[proxy(store = "sarzak", object = "Conditionality", func = "new_unconditional")]
    fn new_unconditional() -> Self;

    #[proxy(store = "sarzak", object = "Conditionality", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct Conditionality {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// An event is sent to an object, and processed by the current state. Assuming it accepts the
//  event. Otherwise itâ€™s dropped on the floor.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Event" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "Event")]
struct Event {
    id: Uuid,
    name: string,
    obj_id: Object,
    // Non-formalizing relationships
}

impl Event {
    #[proxy(store = "sarzak", object = "Event", func = "new")]
    fn new(name: string, obj_id: Object) -> Self;

    #[proxy(store = "sarzak", object = "Event", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("An event is sent to an object, and processed by the current state. Assuming it accepts the\n");
        print(" event. Otherwise itâ€™s dropped on the floor.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Event {\n");
        print("    id: Uuid,\n");
        print("    name: string,\n");
        print("    obj_id: Object,\n");
        print("}\n");
    }
}

// External Type
// 
// This may literally be anything. It's used during code generation to generate variables names
//  and type names for things that are outside of a modeled domain. For example, a timer would
//  be an external type. The specifics of how it is used is up to the model compiler.
// 
// In grace, the `name` attribute is used during code generation to create variable names by
//  converting it to `snake_case`. When used as a type, it is converted to `UpperCamelCase`
// .
// 
// We use `path` as the path is a `use` statement.
// 
// I'm updating this while trying to use it, so this description is going to be rather incoherent
//  until things settle down.
// 
// The way I'm using this, and hopefully the way that will always accommodate, is as a singleton
//  within a particular function scope. Maybe it's a system-wide singleton? I dunno. But it's
//  a singleton.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "External" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "External")]
struct External {
    ctor: string,
    id: Uuid,
    name: string,
    x_path: string,
    // Non-formalizing relationships
}

impl External {
    #[proxy(store = "sarzak", object = "External", func = "new")]
    fn new(ctor: string, name: string, x_path: string) -> Self;

    #[proxy(store = "sarzak", object = "External", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("External Type\n");
        print("\n");
        print("This may literally be anything. It's used during code generation to generate variables names\n");
        print(" and type names for things that are outside of a modeled domain. For example, a timer would\n");
        print(" be an external type. The specifics of how it is used is up to the model compiler.\n");
        print("\n");
        print("In grace, the `name` attribute is used during code generation to create variable names by\n");
        print(" converting it to `snake_case`. When used as a type, it is converted to `UpperCamelCase`\n");
        print(".\n");
        print("\n");
        print("We use `path` as the path is a `use` statement.\n");
        print("\n");
        print("I'm updating this while trying to use it, so this description is going to be rather incoherent\n");
        print(" until things settle down.\n");
        print("\n");
        print("The way I'm using this, and hopefully the way that will always accommodate, is as a singleton\n");
        print(" within a particular function scope. Maybe it's a system-wide singleton? I dunno. But it's\n");
        print(" a singleton.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct External {\n");
        print("    ctor: string,\n");
        print("    id: Uuid,\n");
        print("    name: string,\n");
        print("    x_path: string,\n");
        print("}\n");
    }
}

// The Floating Point Type
// 
// This type holds numbers from â„. This type is just a placeholder. It's implementation is
//  determined downstream by the code generator.
// 
// â—ï¸{"singleton_object": true}
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Float" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "Float")]
struct Float {
    id: Uuid,
    // Non-formalizing relationships
}

impl Float {
    #[proxy(store = "sarzak", object = "Float", func = "new")]
    fn new() -> Self;

    #[proxy(store = "sarzak", object = "Float", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("The Floating Point Type\n");
        print("\n");
        print("This type holds numbers from â„. This type is just a placeholder. It's implementation is\n");
        print(" determined downstream by the code generator.\n");
        print("\n");
        print("â—ï¸{â€singleton_objectâ€: true}\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Float {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// The Integer Type
// 
// This is an interger that can hold positive and negative values. This type is just a placeholder
// . It's implementation is determined downstream by the code generator.
// 
// â—ï¸{"singleton_object": true}
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Integer" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "Integer")]
struct Integer {
    id: Uuid,
    // Non-formalizing relationships
}

impl Integer {
    #[proxy(store = "sarzak", object = "Integer", func = "new")]
    fn new() -> Self;

    #[proxy(store = "sarzak", object = "Integer", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("The Integer Type\n");
        print("\n");
        print("This is an interger that can hold positive and negative values. This type is just a placeholder\n");
        print(". It's implementation is determined downstream by the code generator.\n");
        print("\n");
        print("â—ï¸{â€singleton_objectâ€: true}\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Integer {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// This tells the interpreter that this struct is a proxy for an object called
// "Isa" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "Isa")]
struct Isa {
    id: Uuid,
    number: int,
    supertype: Supertype,
    // Non-formalizing relationships
}

impl Isa {
    #[proxy(store = "sarzak", object = "Isa", func = "new")]
    fn new(number: int, supertype: Supertype) -> Self;

    #[proxy(store = "sarzak", object = "Isa", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
    }

    fn info() -> () {
        print("struct Isa {\n");
        print("    id: Uuid,\n");
        print("    number: int,\n");
        print("    supertype: Supertype,\n");
        print("}\n");
    }
}

// A constant value that indicates a cardinality of _many_.
// 
// â—ï¸{"singleton_object": true}
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Many" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "Many")]
struct Many {
    id: Uuid,
    // Non-formalizing relationships
}

impl Many {
    #[proxy(store = "sarzak", object = "Many", func = "new")]
    fn new() -> Self;

    #[proxy(store = "sarzak", object = "Many", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A constant value that indicates a cardinality of _many_.\n");
        print("\n");
        print("â—ï¸{â€singleton_objectâ€: true}\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Many {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// An `Object` is a collection of related data. By creating `Object`s, and 
// connecting them with `Relationships` we build a powerful abstraction.
// 
// `Object`s contain [Attribute]s that represent the data that the 
// `Object`encapsulates. All `Object`s have an attribute called `id`, which 
// is a unique identifier for each class of `Object`. The `id` attribute is a
// version 5 UUID.
// 
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Object" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "Object")]
struct Object {
    description: string,
    id: Uuid,
    key_letters: string,
    name: string,
    // Non-formalizing relationships
}

impl Object {
    #[proxy(store = "sarzak", object = "Object", func = "new")]
    fn new(description: string, key_letters: string, name: string) -> Self;

    #[proxy(store = "sarzak", object = "Object", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("An `Object` is a collection of related data. By creating `Object`s, and \n");
        print("connecting them with `Relationships` we build a powerful abstraction.\n");
        print("\n");
        print("`Object`s contain [Attribute]s that represent the data that the \n");
        print("`Object`encapsulates. All `Object`s have an attribute called `id`, which \n");
        print("is a unique identifier for each class of `Object`. The `id` attribute is a\n");
        print("version 5 UUID.\n");
        print("\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Object {\n");
        print("    description: string,\n");
        print("    id: Uuid,\n");
        print("    key_letters: string,\n");
        print("    name: string,\n");
        print("}\n");
    }
}

// A constant value that indicates a cardinality of _one_.
// 
// â—ï¸{"singleton_object": true}
// 
// This tells the interpreter that this struct is a proxy for an object called
// "One" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "One")]
struct One {
    id: Uuid,
    // Non-formalizing relationships
}

impl One {
    #[proxy(store = "sarzak", object = "One", func = "new")]
    fn new() -> Self;

    #[proxy(store = "sarzak", object = "One", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A constant value that indicates a cardinality of _one_.\n");
        print("\n");
        print("â—ï¸{â€singleton_objectâ€: true}\n");
        print("\n");
    }

    fn info() -> () {
        print("struct One {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// This is the side being referred to in a binary relationship. It is the â€œtoâ€ side.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Referent" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "Referent")]
struct Referent {
    description: string,
    id: Uuid,
    cardinality: Cardinality,
    conditionality: Conditionality,
    obj_id: Object,
    // Non-formalizing relationships
}

impl Referent {
    #[proxy(store = "sarzak", object = "Referent", func = "new")]
    fn new(description: string, cardinality: Cardinality, conditionality: Conditionality, obj_id: Object) -> Self;

    #[proxy(store = "sarzak", object = "Referent", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("This is the side being referred to in a binary relationship. It is the â€œtoâ€ side.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Referent {\n");
        print("    description: string,\n");
        print("    id: Uuid,\n");
        print("    cardinality: Cardinality,\n");
        print("    conditionality: Conditionality,\n");
        print("    obj_id: Object,\n");
        print("}\n");
    }
}

// This is the side of a binary relationship that is doing the pointing, thus it contains the
//  referential attribute. It is connected to the â€œfromâ€ side of a binary relationship.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Referrer" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "Referrer")]
struct Referrer {
    description: string,
    id: Uuid,
    referential_attribute: string,
    cardinality: Cardinality,
    conditionality: Conditionality,
    obj_id: Object,
    // Non-formalizing relationships
}

impl Referrer {
    #[proxy(store = "sarzak", object = "Referrer", func = "new")]
    fn new(description: string, referential_attribute: string, cardinality: Cardinality, conditionality: Conditionality, obj_id: Object) -> Self;

    #[proxy(store = "sarzak", object = "Referrer", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("This is the side of a binary relationship that is doing the pointing, thus it contains the\n");
        print(" referential attribute. It is connected to the â€œfromâ€ side of a binary relationship.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Referrer {\n");
        print("    description: string,\n");
        print("    id: Uuid,\n");
        print("    referential_attribute: string,\n");
        print("    cardinality: Cardinality,\n");
        print("    conditionality: Conditionality,\n");
        print("    obj_id: Object,\n");
        print("}\n");
    }
}

// A `Relationship` indicates that a set of objects are connected to each other in some manner
// . Typically it is a _real world_ relationship. In the 
// case of this model it is strictly an abstraction.
// 
// There are three types of `Relationship`: [`Isa`], [`Binary`], and [`Associative`]. Thus
//  `Relationship` is itself the *supertype* in an [`Isa`] relationship. It is a partitioning
//  *supertype-subtype* relationship, rather one of inheritance. As such, itâ€™s  perfectly
//  suited to a rust `enum`! ðŸ˜ƒ
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Relationship" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "Relationship")]
struct Relationship {
    id: Uuid,
    // Non-formalizing relationships
}

impl Relationship {
    #[proxy(store = "sarzak", object = "Relationship", func = "new_associative")]
    fn new_associative() -> Self;

    #[proxy(store = "sarzak", object = "Relationship", func = "new_binary")]
    fn new_binary() -> Self;

    #[proxy(store = "sarzak", object = "Relationship", func = "new_isa")]
    fn new_isa() -> Self;

    #[proxy(store = "sarzak", object = "Relationship", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A `Relationship` indicates that a set of objects are connected to each other in some manner\n");
        print(". Typically it is a _real world_ relationship. In the \n");
        print("case of this model it is strictly an abstraction.\n");
        print("\n");
        print("There are three types of `Relationship`: [`Isa`], [`Binary`], and [`Associative`]. Thus\n");
        print(" `Relationship` is itself the *supertype* in an [`Isa`] relationship. It is a partitioning\n");
        print(" *supertype-subtype* relationship, rather one of inheritance. As such, itâ€™s  perfectly\n");
        print(" suited to a rust `enum`! ðŸ˜ƒ\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Relationship {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// An [Object] state, more precisely, a set of states, is where all the action happens.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "State" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "State")]
struct State {
    id: Uuid,
    name: string,
    obj_id: Object,
    // Non-formalizing relationships
}

impl State {
    #[proxy(store = "sarzak", object = "State", func = "new")]
    fn new(name: string, obj_id: Object) -> Self;

    #[proxy(store = "sarzak", object = "State", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("An [Object] state, more precisely, a set of states, is where all the action happens.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct State {\n");
        print("    id: Uuid,\n");
        print("    name: string,\n");
        print("    obj_id: Object,\n");
        print("}\n");
    }
}

// The String Type
// 
// This type holds unicode characters. This type is just a placeholder. It's implementation
//  is determined downstream by the code generator.
// 
// â—ï¸{"singleton_object": true}
// 
// This tells the interpreter that this struct is a proxy for an object called
// "String" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "String")]
struct String {
    id: Uuid,
    // Non-formalizing relationships
}

impl String {
    #[proxy(store = "sarzak", object = "String", func = "new")]
    fn new() -> Self;

    #[proxy(store = "sarzak", object = "String", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("The String Type\n");
        print("\n");
        print("This type holds unicode characters. This type is just a placeholder. It's implementation\n");
        print(" is determined downstream by the code generator.\n");
        print("\n");
        print("â—ï¸{â€singleton_objectâ€: true}\n");
        print("\n");
    }

    fn info() -> () {
        print("struct String {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// The *subtype* in a *supertype-subtype* relationship.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Subtype" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "Subtype")]
struct Subtype {
    id: Uuid,
    isa: Isa,
    obj_id: Object,
    // Non-formalizing relationships
}

impl Subtype {
    #[proxy(store = "sarzak", object = "Subtype", func = "new")]
    fn new(isa: Isa, obj_id: Object) -> Self;

    #[proxy(store = "sarzak", object = "Subtype", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("The *subtype* in a *supertype-subtype* relationship.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Subtype {\n");
        print("    id: Uuid,\n");
        print("    isa: Isa,\n");
        print("    obj_id: Object,\n");
        print("}\n");
    }
}

// This object represents the *supertype* in a *supertype-subtype* 
// relationship.
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Supertype" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "Supertype")]
struct Supertype {
    id: Uuid,
    obj_id: Object,
    // Non-formalizing relationships
}

impl Supertype {
    #[proxy(store = "sarzak", object = "Supertype", func = "new")]
    fn new(obj_id: Object) -> Self;

    #[proxy(store = "sarzak", object = "Supertype", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("This object represents the *supertype* in a *supertype-subtype* \n");
        print("relationship.\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Supertype {\n");
        print("    id: Uuid,\n");
        print("    obj_id: Object,\n");
        print("}\n");
    }
}

// The type of a value
// 
// There are several values available: [Integer], [Boolean], [Float], [String], and [UUID]
// .
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Type" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "Type")]
struct Type {
    id: Uuid,
    // Non-formalizing relationships
}

impl Type {
    #[proxy(store = "sarzak", object = "Type", func = "new_boolean")]
    fn new_boolean() -> Self;

    #[proxy(store = "sarzak", object = "Type", func = "new_external")]
    fn new_external() -> Self;

    #[proxy(store = "sarzak", object = "Type", func = "new_float")]
    fn new_float() -> Self;

    #[proxy(store = "sarzak", object = "Type", func = "new_integer")]
    fn new_integer() -> Self;

    #[proxy(store = "sarzak", object = "Type", func = "new_object")]
    fn new_object() -> Self;

    #[proxy(store = "sarzak", object = "Type", func = "new_z_string")]
    fn new_z_string() -> Self;

    #[proxy(store = "sarzak", object = "Type", func = "new_z_uuid")]
    fn new_z_uuid() -> Self;

    #[proxy(store = "sarzak", object = "Type", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("The type of a value\n");
        print("\n");
        print("There are several values available: [Integer], [Boolean], [Float], [String], and [UUID]\n");
        print(".\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Type {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// The UUID Type
// 
// I feel like there are too many implementation details here. 
// 
// This UUID is expected to be version 5. Generally we produce input
// to the hash function from other UUIDs, coupled with additional 
// information from the creator to ensure a unique UUID.
// 
// The `ns` attribute is the namespace used to generate generate UUIDs
// given a particular instance of `UUID`.
// 
// â—ï¸{"singleton_object": true, "translation_name": "SarzakUuid"}
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Uuid" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "UUID")]
struct Uuid {
    id: Uuid,
    // Non-formalizing relationships
}

impl Uuid {
    #[proxy(store = "sarzak", object = "UUID", func = "new")]
    fn new() -> Self;

    #[proxy(store = "sarzak", object = "UUID", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("The UUID Type\n");
        print("\n");
        print("I feel like there are too many implementation details here. \n");
        print("\n");
        print("This UUID is expected to be version 5. Generally we produce input\n");
        print("to the hash function from other UUIDs, coupled with additional \n");
        print("information from the creator to ensure a unique UUID.\n");
        print("\n");
        print("The `ns` attribute is the namespace used to generate generate UUIDs\n");
        print("given a particular instance of `UUID`.\n");
        print("\n");
        print("â—ï¸{â€singleton_objectâ€: true, â€translation_nameâ€: â€SarzakUuidâ€}\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Uuid {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

// A constant value that indicates a conditionality of _unconditional_.
// 
// â—ï¸{"singleton_object": true}
// 
// This tells the interpreter that this struct is a proxy for an object called
// "Unconditional" in the store named "sarzak"; declared above.
#[proxy(store = "sarzak", object = "Unconditional")]
struct Unconditional {
    id: Uuid,
    // Non-formalizing relationships
}

impl Unconditional {
    #[proxy(store = "sarzak", object = "Unconditional", func = "new")]
    fn new() -> Self;

    #[proxy(store = "sarzak", object = "Unconditional", func = "instances")]
    fn instances() -> [Self];

    fn help() -> () {
        print("A constant value that indicates a conditionality of _unconditional_.\n");
        print("\n");
        print("â—ï¸{â€singleton_objectâ€: true}\n");
        print("\n");
    }

    fn info() -> () {
        print("struct Unconditional {\n");
        print("    id: Uuid,\n");
        print("}\n");
    }
}

